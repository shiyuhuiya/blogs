<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>前端面试---vue部分 | 三叶的博客</title><meta name="author" content="三叶sanye"><meta name="copyright" content="三叶sanye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="vue2+vue3面试题（笔记）"><meta property="og:type" content="article"><meta property="og:title" content="前端面试---vue部分"><meta property="og:url" content="https://www.sanye.blog/posts/f33bd2b9.html"><meta property="og:site_name" content="三叶的博客"><meta property="og:description" content="vue2+vue3面试题（笔记）"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.sanye.blog/images/cover/%E5%B0%8F%E9%95%87.jpg"><meta property="article:published_time" content="2024-12-13T10:56:10.000Z"><meta property="article:modified_time" content="2025-05-02T05:26:07.809Z"><meta property="article:author" content="三叶sanye"><meta property="article:tag" content="vue"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.sanye.blog/images/cover/%E5%B0%8F%E9%95%87.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.sanye.blog/posts/f33bd2b9.html"><link rel="preconnect"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",(()=>{void 0===t.get("theme")&&(e.matches?o():a())}))}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-center"},infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"前端面试---vue部分",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/time.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/bilibiliBanner/banner.css"><link rel="stylesheet" href="/gallery/background.css"><link href="/animeClips/play/index.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i:0"></div><div class="iron-coil" style="--i:1"></div><div class="iron-coil" style="--i:2"></div><div class="iron-coil" style="--i:3"></div><div class="iron-coil" style="--i:4"></div><div class="iron-coil" style="--i:5"></div><div class="iron-coil" style="--i:6"></div><div class="iron-coil" style="--i:7"></div></div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/%E4%B8%89%E5%8F%B6.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i> <span>图库</span></a></div><div class="menus_item"><a class="site-page" href="/materials/"><i class="fa-fw fas fa-book"></i> <span>资料</span></a></div><div class="menus_item"><a class="site-page" href="/animeClips/"><i class="fa-fw fa-solid fa-video"></i> <span>剪辑</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/cover/小镇.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name iconfont icon-sanyecao">三叶的博客</span></a><a class="nav-page-title" href="/"><span class="site-name iconfont icon-sanyecao">前端面试---vue部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i> <span>图库</span></a></div><div class="menus_item"><a class="site-page" href="/materials/"><i class="fa-fw fas fa-book"></i> <span>资料</span></a></div><div class="menus_item"><a class="site-page" href="/animeClips/"><i class="fa-fw fa-solid fa-video"></i> <span>剪辑</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端面试---vue部分<a class="post-edit-link" href="https://github.com/shiyuhuiya/shiyuhuiya.github.io/issues_posts/前端面试-vue.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-13T10:56:10.000Z" title="发表于 2024-12-13 18:56:10">2024-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-02T05:26:07.809Z" title="更新于 2025-05-02 13:26:07">2025-05-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">36.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>131分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-05-02 13:26:07&quot;}" hidden></div><h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="headerlink" title="说说你对vue的理解"></a>说说你对vue的理解</h2><h3 id="前端发展背景"><a href="#前端发展背景" class="headerlink" title="前端发展背景"></a>前端发展背景</h3><p>最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，就是<code>纯静态页面</code></p><p>直到<code>CGI</code>技术的出现，通过 CGI Perl 运行一小段代码，与数据库或文件系统进行<code>交互</code>(前后端交互)</p><p>后来JSP(Java Server Pages)技术取代了CGI技术，其实就是Java + HTML</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=utf-8&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;JSP demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=<span class="string">&quot;http://localhost:8080/web05_session/1.jpg&quot;</span> width=<span class="string">&quot;200&quot;</span> height=<span class="string">&quot;100&quot;</span> alt=<span class="string">&quot;示例图片&quot;</span> /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>JSP有一个很大的<code>缺点</code>，就是不太灵活。JSP使用 <code>Java</code> 而不是 <code>JavaScript</code>，并且 Java 代码只能在服务器端运行。我们每次的请求：获取的数据、内容的加载，服务器都会做对应的处理，并渲染dom然后返回渲染好的dom，简单的来说，JSP把页面的渲染工作完全交给后端服务器。</p><p>后来<code>ajax</code>火了，它允许用户在不刷新整个页面的前提下，和后端服务器交换数据，并由浏览器执行js代码，更新部分页面。</p><p>随后移动设备的普及，Jquery的出现，以及SPA（Single Page Application 单页面应用）的雏形，Backbone EmberJS AngularJS 这样一批前端框架随之出现，但当时SPA的路不好走，例如SEO问题，SPA 过多的页面、复杂场景下 View 的绑定等，都没有很好的处理。</p><p>经过这几年的飞速发展，节约了开发人员大量的精力、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度。我们可以看到Web技术的变化之大与快，每一种新的技术出现都是一些特定场景的解决方案，那我们今天的主角Vue又是为了解决什么呢？</p><h3 id="Vue是什么"><a href="#Vue是什么" class="headerlink" title="Vue是什么"></a>Vue是什么</h3><p>是一个用于创建<code>用户界面</code>的开源<code>JavaScript框架</code>，也是一个创建<code>单页应用（SPA）</code>的前端框架。</p><h3 id="Vue核心特性"><a href="#Vue核心特性" class="headerlink" title="Vue核心特性"></a><strong>Vue核心特性</strong></h3><ul><li><p><strong>数据驱动视图更新</strong></p><p>数据驱动(MVVM)，相比于react，开发者无需手动调用 <code>setState</code>来提示视图更新。</p><p>MVVM表示的是 Model-View-ViewModel</p><ul><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁，在vue中这个桥梁是vue实例</li></ul></li><li><p><strong>组件化</strong></p><p>降低了代码的耦合度，可维护性，可扩展性高，便于调试。vue中的组件可分为单文件组件和多文件组件，vue中的组件是能实现部分功能的css，js，html等代码和资源的集合。</p></li><li><p><strong>指令系统</strong></p><p>指令 (Directives) 是带有 <code>v- 前缀</code>的<code>特殊属性</code>，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。简单的来说，vue中的指令系统简化了dom操作，而react中没有指令系统。</p></li></ul><h2 id="Vue的学习路线"><a href="#Vue的学习路线" class="headerlink" title="Vue的学习路线"></a><strong>Vue的学习路线</strong></h2><h3 id="原生开发"><a href="#原生开发" class="headerlink" title="原生开发"></a><strong>原生开发</strong></h3><p>通过script标签引入vue.js,src属性通常是http链接，或者下载到本地的vue.js文件的路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果是http链接，当浏览器加载这个脚本，会发送一个get请求获取并执行vue的js代码，类似jsonp请求。</p><p>引入vue.js后，<strong>Vue</strong>这个构造函数成为<strong>全局变量</strong>，挂载到<strong>window</strong>对象上</p><p>然后我们在页面的<strong>script</strong>标签中写些代码，创建一个vue实例，传入一个配置对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时我们还未引入<strong>组件</strong>的概念，但是我们已经能够学习vue的大部分知识点了。包括模板语法，数据绑定，数据代理如何实现，vue的常用指令，计算属性，数据监听，vue的生命周期等等。</p><h3 id="原生开发之组件化开发"><a href="#原生开发之组件化开发" class="headerlink" title="原生开发之组件化开发"></a><strong>原生开发之组件化开发</strong></h3><p>什么组件？组件化开发有什么好处？</p><p>在vue中，组件就是能实现<code>局部功能</code>的<code>html，css，js</code>代码的集合，组件化开发有利于<strong>代码复用</strong>，提高开发效率，同时把功能上密切相关的html，css，js代码放到一起，<strong>依赖关系明确</strong>，易于维护。</p><p>vue的组件可分为<strong>单文件组件</strong>和<strong>非单文件组件</strong>，非单文件组件就是通过<strong>Vue.extend({})<strong>，返回一个</strong>VueComponent</strong>构造函数，这个</p><p>构造函数被用来创建<strong>组件实例</strong>，依赖的<strong>配置对象</strong>就是<code>Vue.extend(&#123;&#125;)</code>传入的对象，这个配置对象的结构和<code>new Vue()</code>传入的配置对象的结构几乎一致。存在如下关系，即<code>Vuecomponent</code>是Vue的<code>子类</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组件实例.<span class="property">_proto_</span> = <span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_proto_</span> = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\vue.png" style="zoom:80%"><h3 id="非单文件组件使用"><a href="#非单文件组件使用" class="headerlink" title="非单文件组件使用"></a><strong>非单文件组件使用</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">:name</span>=<span class="string">&quot;str&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;str&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">School</span>&gt;</span><span class="tag">&lt;/<span class="name">School</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个school组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">School</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">str</span>: <span class="string">&quot;haha&quot;</span>,</span><br><span class="line">      <span class="attr">keyword</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//组件注册</span></span><br><span class="line">    <span class="attr">components</span>:&#123;<span class="title class_">School</span>&#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a><strong>单文件组件</strong></h3><p>单文件组件就是我们熟知的<code>.vue</code>文件, 单文件组件解决了非单文件组件<code>无法复用css代码</code>的问题，我们开发过程中使用的最多的组件也是单文件组件。</p><p>显然，<code>.vue</code>文件是vue团队开发的文件，无法在浏览器上运行，所以我们需要借助打包工具webpack来处理这个文件，webpack又是基于<code>nodejs</code>的，<code>nodejs</code>是使用模块化开发的。这样vue的开发就过渡到了基于nodejs+webpack的<strong>模块化</strong>开发，为了简化模块化开发过程中webpack的配置，vue团队就开发了<code>vue-cli</code>，即vue的脚手架</p><p>单文件组件的大致结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>export default &#123;&#125;</code>由<code>export default Vue.extend(&#123;&#125;)</code>简化而来的，组件注册的时候会自动处理：如果发现注册的组件是一个对象，则使用<code>Vue.extend</code>包裹，否则直接注册。</p><p>组件之间通过嵌套确定层级关系，所有其他组件都在根组件App.vue内，根组件直接嵌入<code>index.html</code>文件；</p><p>组件化开发后不需要直接在html页面中写结构，内容被分解为一个一个vue组件。</p><h2 id="谈谈对el和template属性的理解"><a href="#谈谈对el和template属性的理解" class="headerlink" title="谈谈对el和template属性的理解"></a>谈谈对el和template属性的理解</h2><p>当我们在学习Vue的基础语法，vue的组件的时候一定涉及到了这两个容易混淆的属性。</p><ul><li><p><strong>创建Vue根实例必须要给出el属性</strong>，指明要为哪个容器服务，这个容器会成为<strong>模板</strong>；创建<code>组件实例</code><strong>不能</strong>传入el属性，<strong>简单的来说，el属性是Vue根实例独有的</strong>。</p></li><li><p>如果创建<strong>vue根实例</strong>同时配置了el和template属性，则template将<strong>替换el</strong>指定的容器成为模板(可以参考<code>vm.$mount</code>源码，template属性优先级更高)，不过要注意的是nodejs开发环境中，通过<code>import</code>导入的<code>vue</code>是精简版的，<strong>没有模板解析器的</strong>, 模板解析器被单独提取出来，作为一个开发环境的包(生产环境打包就不会将模板解析器包含进去，从而减小最终文件的体积)，用来处理<code>.vue</code>文件中的<code>template</code>，所以在创建vue根实例的时候不能使用<code>template</code>，所以无法借助它实现在页面中自动插入Vue.app的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;App&gt;&lt;/App&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123;<span class="title class_">App</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码会报错，不能配置<code>template</code></p><p>应当修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">render</span>:<span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)<span class="comment">//传入的h是createElement函数，用来创建VNode</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者引入完整版的vue.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue/dist/vue.js&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>创建组件必须指定组件的结构，即template，组件的模板，不必指定组件为哪个容器服务（不要el）</p></li><li><p>el指定的容器中的<code>结构</code>可以被抽离为一个一个单独的模板<code>template</code>，一个个单独的组件，也就是说模板中可以不写实际结构，只写组件标签，这些组件标签会在模板解析的时候被解析。</p></li><li><p>其实组件中的<code>template</code>也能被拆分，从而形成一个一个组件，这就是组件的嵌套。</p></li></ul><h2 id="说说Vue的生命周期"><a href="#说说Vue的生命周期" class="headerlink" title="说说Vue的生命周期"></a><strong>说说Vue的生命周期</strong></h2><p>vue的生命周期指的是<strong>vue实例</strong>从创建到销毁的过程，可分为vue实例初始化前后，dom挂载前后，数据更新前后，vue实例销毁前后四个阶段。这四个阶段分别对应了<code>8</code>个生命周期函数。</p><p>生命周期函数指的是在vue实例特定时间段执行的函数。</p><p>这里拿vue2的生命周期函数举例。</p><ul><li>beforeCreate：vue实例刚被创建，能拿到this，部分初始化工作完成，但是<strong>数据代理</strong>还未开始(未调用<code>initState</code>方法)，此时无法通过this获取<strong>data和methods等</strong></li><li>created: 此时几乎所有配置属性比如inject，data，method，computed，props，watch，provide都初始化完成，但是<strong>模板解析（是为了得到render函数，render函数是用来创建虚拟dom的）</strong>还未开始（未调用<code>vm.$mount</code>方法），页面展示的是<strong>未经vue编译的dom</strong>。</li><li>beforeMount：<strong>template模板解析结束，render函数创建完毕</strong>，但是render函数还未调用，还没生成虚拟dom，此时展示的还是旧的页面（未经编译的页面）</li><li>mounted：此时render函数已经被调用，虚拟 DOM 已转换为真实 DOM，挂载到页面上，此时对DOM的操作是有效的。</li><li>beforeUpdate：此时数据是新的，页面展示的内容是旧的，因为vue视图是异步更新的。</li><li>updated: 此时<code>新旧虚拟dom比较</code>完毕，页面已更新。</li><li>beforeDestroy：当执行beforeDestroy的钩子的时候，Vue实例就已经从运行阶段进入销毁阶段，但身上所有的data和methods，以及过滤器、指令等，都处于可用状态，还未真正执行销毁的过程</li><li>destroyed: 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器；并不能清除DOM，仅仅销毁实例。所以页面并不会改变，但是变得无法响应交互。</li></ul><img src="..\images\前端面试-vue\生命周期.png" style="zoom:150%"><p><strong>数据请求在created和mouted的区别</strong></p><ul><li>这两个阶段<code>数据</code>和<code>方法</code>都已经初始化，都能通过<code>this</code>访问到，因为<code>created</code>的执行时期更早，所以能更早的发送请求，更快的返回数据。</li><li>一个组件中有子组件，它们的生命周期函数的执行顺序是先执行父组件的前三个声明周期函数，再执行子组件的前四个生命周期函数，然后在执行哦父组件的<code>mouted</code>函数。</li></ul><p>对于vue3中的生命周期的介绍，参考《vue》一文。</p><h2 id="说说你对vue双向绑定的理解"><a href="#说说你对vue双向绑定的理解" class="headerlink" title="说说你对vue双向绑定的理解"></a>说说你对vue双向绑定的理解</h2><p><code>双向绑定</code>不等同于<code>响应式</code>了，这两个东西是有区别的。</p><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>当更改<code>响应式数据</code>时，视图会随即<code>自动更新</code>，那在vue中是如何实现<strong>数据的响应式</strong>的呢？其实主要就分为2部分，给数据添加响应式和依赖收集</p><ol><li><code>new Vue()</code>首先执行初始化，对<code>data</code>执行响应化处理，这个过程发生<code>constructor-&gt;_init-&gt;initState-&gt;initData-&gt;observe</code>中</li><li>同时对模板执行编译，找到其中动态绑定的数据，从<code>data</code>中获取并初始化视图，这个过程发生在<code>Compile</code>中</li><li>同时定义⼀个更新函数和<code>Watcher</code>，将来对应数据变化时，<code>Watcher</code>会调用更新函数</li><li>由于<code>data</code>的某个<code>key</code>在⼀个视图中可能出现多次，所以每个<code>key</code>都需要⼀个管家<code>dep</code>来管理多个<code>Watcher</code></li><li>将来<code>data</code>中数据⼀旦发生变化，会首先找到对应的<code>dep</code>，通知所有<code>Watcher</code>执行更新函数</li></ol><p>具体代码参考《说说Vue实例挂载过程中发生了什么》其中有详细的介绍。</p><ul><li>如果一个组件内的某个响应式属性没有任何依赖，即便修改这个响应式属性，也不会触发组件的<code>beforeUpdate，updated</code>钩子</li><li><code>updated</code> 只在<strong>组件自身的 DOM 或子组件的 DOM 被重新渲染</strong>后才会触发，简单的来说，只有<strong>视图</strong>更新了，<code>beforeUpdate，updated</code>才会触发</li><li>如果修改的数据未影响到模板中的任何部分（例如只是修改了一个未被使用的变量），则不会触发<code>beforeUpdate，updated</code></li></ul><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>双向绑定，是<strong>数据变化驱动视图更新，视图更新触发数据变化</strong>。其实就是<code>v-model</code>的功能，而我们知道<code>v-model</code>只是一个语法糖。因此如果要问双向绑定的原理，思路应该是<strong>如何实现这个语法糖</strong>。其原理是把<code>input</code>的value绑定data的一个值，当原生input的事件触发时，用事件的值来更新data的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 v-model --&gt;</span><br><span class="line">&lt;input v-model=&quot;message&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 编译后的等效代码 --&gt;</span><br><span class="line">&lt;input :value=&quot;message&quot; @input=&quot;e =&gt; &#123;message = e.target.value&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="说说Vue实例挂载过程中发生了什么"><a href="#说说Vue实例挂载过程中发生了什么" class="headerlink" title="说说Vue实例挂载过程中发生了什么"></a>说说Vue实例挂载过程中发生了什么</h2><p>我们都听过知其然知其所以然这句话</p><p>那么不知道大家是否思考过<code>new Vue()</code>这个过程中究竟做了些什么？</p><p>过程中是如何完成<code>数据的绑定</code>，又是如何将<code>数据渲染到视图</code>的等等。下面给出简要流程：</p><ul><li><p>在构造函数中调用<code>_init</code>方法</p></li><li><p>在<code>_init</code>方法内部：</p><ul><li>做一些初始化工作</li><li>调用<code>beforeCreate</code>钩子</li><li>初始化<code>Injections</code></li><li>初始化<code>state</code></li><li>初始化<code>Provide</code></li><li>调用<code>created</code>钩子</li><li>调用<code>vm.$mount</code>方法</li></ul></li><li><p>在<code>initState</code>方法内部，依次调用：</p><ul><li><code>initProps</code></li><li><code>initMethods</code></li><li><code>initData</code></li><li><code>initComputed</code></li><li><code>initWatch</code></li></ul></li><li><p>在<code>initData</code>方法内部</p><ul><li>检查data中的属性，是否和props和method中的属性有冲突</li><li>调用proxy方法，把数据代理到this上，简化访问路径</li><li>调用observe方法，给数据添加响应式</li></ul></li><li><p>在<code>initProps</code>方法内部</p><ul><li><p>创建一个空对象，赋值给<code>vm._props</code></p></li><li><p>校验props中的key是否合法，得到一个value</p></li><li><p>把这个value和对应的key，响应式地添加到<code>vm._props</code>，最终代理到vm。</p></li></ul></li></ul><h3 id="vue构造函数源码"><a href="#vue构造函数源码" class="headerlink" title="vue构造函数源码"></a>vue构造函数源码</h3><p>首先找到<code>vue</code>的构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：src\core\instance\index.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>) ) &#123;</span><br><span class="line">    <span class="comment">//如果不说生产环境且不是Vue实例调用这个构造函数就报错</span></span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//this指向创建的Vue实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>options</code>是用户传递入的配置对象，包含<code>data、methods</code>等常用属性。</p><p><code>vue</code>构建函数调用了<code>_init</code>方法，并传入了<code>options</code>，所以我们关注的核心就是<code>_init</code>方法：</p><h3 id="init"><a href="#init" class="headerlink" title="_init"></a>_init</h3><img src="..\images\前端面试-vue\vue挂载.png" style="zoom:80%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：src\core\instance\init.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="comment">//vm = this = vue实例</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    ....</span><br><span class="line">	<span class="comment">// 初始化组件生命周期标志位</span></span><br><span class="line">	<span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">	<span class="comment">// 初始化组件事件侦听</span></span><br><span class="line">	<span class="title function_">initEvents</span>(vm)</span><br><span class="line">	<span class="comment">// 初始化渲染方法</span></span><br><span class="line">	<span class="title function_">initRender</span>(vm)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用生命周期钩子&#x27;beforeCreate&#x27;</span></span><br><span class="line">	<span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 初始化注入内容，在初始化data、props之前。</span></span><br><span class="line">	<span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">	<span class="comment">// 初始化 props/data/method/watch/methods/computed</span></span><br><span class="line">	<span class="title function_">initState</span>(vm)</span><br><span class="line">	<span class="comment">//之所以最后初始化Provide，因为Provide引用的数据就是data或者computed等属性中的。</span></span><br><span class="line">	<span class="title function_">initProvide</span>(vm)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用生命周期钩子&#x27;created&#x27;，此时不光是data，props，method，watch，provide等几乎所有配置属性都完成了初始化的工作</span></span><br><span class="line">	<span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">// 挂载元素</span></span><br><span class="line">	<span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">	   vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析后得出如下结论：</p><ul><li>在调用<code>beforeCreate</code>之前，主要做一些数据初始化的工作，<code>数据初始化</code>并未完成，像<code>data</code>、<code>props</code>这些对象内部属性无法通过<code>this</code>访问到。所以说<code>beforeCreate</code>的执行时机<code>先于data()函数调用</code>，data函数调用，是在初始化data的时候被触发的。</li><li>执行<code>created</code>的时候，数据已经初始化完成，能够通过<code>this</code>访问<code>data</code>、<code>props</code>这些对象的属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</li><li>通过调用<code>vm.$mount</code>方法实现了dom挂载</li></ul><p>我们先主要分析<code>initState</code>方法</p><h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><img src="..\images\前端面试-vue\vue挂载2.png" style="zoom:67%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：src\core\instance\state.js</span></span><br><span class="line"><span class="comment">//vm是vue实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化组件的watcher列表</span></span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="comment">// 初始化methods，要做的其实很简单，单纯把methods中的全部方法挂载到this上就行</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化data  </span></span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化computed</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="comment">// 初始化watch</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析后发现，<code>initState</code>方法<strong>依次，统一</strong>初始化了<code>props/methods/data/computed/watch</code>，说明在<code>created</code>的时候，这些东西都准备好了，或者说初始化工作都完成了。</p><p>我们继续分析<code>initState</code>中的<code>initData</code>方法，关于<code>initProps</code>和<code>initComputed</code>等其他属性的初始化做了什么，这里暂时不深入研究。</p><h4 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  <span class="comment">// 判断data的类型是不是函数，如果是则调用函数，并把返回值赋予局部变量data，同时赋值给vm._data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  .....</span><br><span class="line">  <span class="comment">//获取data中所有可枚举属性</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 属性名不能与methods中的属性名重复</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性名不能与props名称重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123; <span class="comment">// 验证key值的合法性</span></span><br><span class="line">      <span class="comment">// 将vm._data中的key属性，代理到vm上, 这样就可以通过this.key访问到vm._data.key的值（this=vm）</span></span><br><span class="line">      <span class="comment">// 所以说vm._data指向的对象是代理源对象</span></span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 监听data中数据的变化，data中的数据改变会触发视图更新</span></span><br><span class="line">  <span class="comment">// 由第一行代码可知data指的是一个局部变量，它和vm._data指向同一个数据对象，由于添加了数据代理</span></span><br><span class="line">  <span class="comment">// 修改this.key的值也会触发视图更新</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读源码后发现：</p><ul><li><code>props</code>和<code>method</code>在<code>data</code>之前就被初始化了，所以<code>data</code>中的属性值不能与<code>props</code>和<code>methods</code>中的属性值<code>重复</code>；之所以要防止重复，因为它们都会被代理到<code>this(vm)</code>上（是的，包括props中的数据），都是直接通过<code>this</code>来访问，重复了就会产生冲突。同时我们也可以发现，<code>props</code>中的数据的优先级是高于<code>data</code>中的数据的，<strong>因为初始化的时机更早</strong>。</li><li><code>data</code>定义的时候可选择<code>函数形式</code>或者<code>对象形式</code>（组件只能为函数形式），<code>data()</code>函数调用是为了产出数据，挂载到<code>vm._data</code>上，然后再给数据<code>添加代理</code>，<code>添加响应式</code>，所以<code>data</code>函数被调用的时候，内部是无法通过<code>this</code>来访问其他数据的。</li><li><code>initData</code>方法把<code>vm._data</code>中的属性代理到<code>vm</code>上并给<code>vm._data</code>上的数据添加了<code>响应式</code>（实现了数据的代理，给数据添了响应式）。</li></ul><p>vue的<strong>数据代理</strong>核心在于<code>proxy</code>方法，我们来看看它做了什么</p><p><strong>proxy方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">target, sourceKey, key</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[sourceKey][key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      target[sourceKey][key] = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span> <span class="comment">// 允许后续删除或重新定义该属性</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br></pre></td></tr></table></figure><p>再次之后，访问<code>target.key</code>返回的就是<code>target.sourceKey.key</code>，说到底还是从target上面取数据，只不过简化了访问的路径。</p><p>vue<strong>给数据添加响应式</strong>的核心在于<code>observe</code>方法，我们来分析一下这个方法</p><p><strong>observe方法源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">  <span class="comment">//如果传入的不是对象或者传入的是null（typeof null返回的也是object）就直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Observer</span>(obj);  <span class="comment">//返回一个Observer实例，这个实例的value属性就是添加了响应式的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = obj;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(value);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;  </span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, key, obj[key]);  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>我们很容易发现这个类的核心是<code>defineReactive</code>方法，那么这个方法内部到底做了些什么呢？其实它主要就做了2个工作：<strong>劫持属性和收集属性的依赖。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, value</span>) &#123;</span><br><span class="line">  <span class="comment">//如果是对象，则递归添加响应式</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> )&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observe</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//为每个key创建一个Dep实例</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//触发getter收集依赖</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)&#123;</span><br><span class="line">          dep.<span class="title function_">addDep</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这里不能写成obj[key]，否则会陷入无限递归，即在get中触发了get</span></span><br><span class="line">      <span class="comment">//返回的是闭包中的value值，也就是说再添加getter之前，先把数据取出来</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 修改的是闭包中的value值，并没有直接修改obj中的数据。</span></span><br><span class="line">      <span class="comment">// 修改obj[key]也会陷入无限递归，因为再set中触发了set</span></span><br><span class="line">      <span class="keyword">if</span>(value === val)&#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      value = val</span><br><span class="line">      <span class="comment">//通知依赖更新</span></span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// this指向某个key的dep实例</span></span><br><span class="line">    <span class="comment">// 这个数组中存储的是一个一个的Watcher实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = [];  <span class="comment">// 依赖管理 </span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">addDep</span>(<span class="params">dep</span>) &#123;</span><br><span class="line">    <span class="comment">//添加依赖，其实dep就是一个Watcher实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="title function_">push</span>(dep);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//通知所有Watcher</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep</span>) =&gt;</span> dep.<span class="title function_">update</span>());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负责更新视图  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, updater</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">updaterFn</span> = updater  </span><br><span class="line">    <span class="comment">// 创建实例时，把当前实例指定到Dep.target静态属性上</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>  </span><br><span class="line">    <span class="comment">// 读一下key，触发get，收集依赖</span></span><br><span class="line">    vm[key]  </span><br><span class="line">    <span class="comment">// 置空，因为已经收集到依赖了</span></span><br><span class="line">    <span class="comment">// 这就意味着在创建Watcher实例的时候，已经收集到依赖了</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 未来执行dom更新函数，由dep调用的  </span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//这行代码的作用是将当前Watcher实例，push到异步更新队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">updaterFn</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>])  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>)&#123;<span class="comment">//进行具体的更新工作&#125;</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li><p><code>defineReactive</code>方法的核心在于使用<code>Object.defineProperty</code>给对象属性<code>添加监听</code>，<strong>且没有借助其他源对象</strong>。而是闭包中的数据。</p></li><li><p>如果<code>val</code>的值是对象，则递归添加响应式</p></li><li><p>触发get要收集依赖，为每个key都创建一个Dep实例，来管理这个key的所有依赖（Watcher）</p></li><li><p>触发set的时候，调用<code>dep.notify()</code>，通知这个key的所有依赖更新</p></li><li><p>每个Watcher实例的三大属性：<code>vm，key，updateFn</code>，创建Watcher实例是在模板编译的时候进行的。</p></li><li><p>修改后的Obj对象结构如图，可以看到原来的属性被<code>覆盖</code>了，变得不可枚举。</p></li></ul><img src="..\images\前端面试-vue\defineReactive.png" style="zoom:90%"><p><strong>补充：Watcher类别</strong></p><ul><li><p>渲染 Watcher（Render Watcher）</p><ul><li><p>作用：负责组件的视图更新，每个组件对应一个渲染 Watcher。</p></li><li><p>run方法行为：执行getter函数（即updateComponent），触发 <code>_render()</code>生成新虚拟DOM，调用<code>_update()</code>对比新旧虚拟 DOM（Diff 算法），最终更新真实 DOM</p></li><li><p>结论：渲染 Watcher 的 <code>run</code> 方法一定会触发 <code>render</code> 方法。</p></li></ul></li><li><p>计算属性 Watcher（Computed Watcher）</p><ul><li><p>作用：追踪计算属性的依赖，缓存计算结果</p></li><li><p>run方法行为：重新计算计算属性的值，但不会触发 <code>render</code> 方法，除非计算结果变化且被模板引用</p></li></ul></li><li><p>用户自定义 Watcher（通过 <code>watch</code> 选项）</p><ul><li><p>作用：监听数据变化并执行回调函数</p></li><li><p>run方法行为：执行用户定义的回调函数（如 <code>handler</code>），不会触发 <code>render</code> 方法</p></li></ul></li></ul><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/3d3a1289620e">彻底理解vue里面的各种watcher及其作用 - 简书</a></p><p><strong>总结</strong></p><p>分析之后我们发现，vue2中的<code>数据代理</code>和<code>数据监听</code>都是通过<code>Object.defineProperty</code>实现的。</p><h4 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的第二个参数是子组件中的props属性的值（props配置对象）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initProps</span>(<span class="params">vm, propsOptions</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> propsData = vm.<span class="property">$options</span>.<span class="property">propsData</span> || &#123;&#125;;</span><br><span class="line">  <span class="comment">//创建一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">_props</span> = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历 Props 配置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">//使用propsOptions校验propsData</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm);</span><br><span class="line">    <span class="comment">// 给创建的props（空对象）添加响应式</span></span><br><span class="line">    <span class="title function_">defineReactive</span>(props, key, value);</span><br><span class="line">    <span class="comment">// 代理到实例（this），然后就能直接通过this访问</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">&#x27;_props&#x27;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当父数据是响应式时，子组件通过<code>依赖收集</code>成为订阅者，父数据变化自动触发子组件更新。</p><p>vue的构造函数中使用的挂载方法是<code>vm.$mount</code>，我们尝试分析它的源码：</p><h3 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a>vm.$mount</h3><img src="..\images\前端面试-vue\vue挂载3.png" style="zoom:67%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el?: string | Element,hydrating?: boolean</span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 如果目标元素存在，捕获它，得到它的dom</span></span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line">  <span class="comment">// vue不允许直接挂载到body或着html上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//提取出options，后续使用不需要通过this</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">  <span class="comment">//如果没有render属性,也就是说没有render函数,解析 template/el 并转换为 render 函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="comment">//如果配置对象中没有render，则提取出template</span></span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">    <span class="comment">// 存在template模板，解析vue模板文件</span></span><br><span class="line">    <span class="comment">// 第一个if主要是为了处理template属性的另类值，比如id选择器，dom对象，最终都是为了转换成模板字符串</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//如果template是id选择器</span></span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">//将id选择转化成模板</span></span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line">          .....</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;<span class="comment">//这个条件语句用于检查 template 是否是一个 DOM节点对象</span></span><br><span class="line">        <span class="comment">//返回的是一个字符串，代表了template元素内部的 HTML 内容，将他作为模板</span></span><br><span class="line">        template = template.<span class="property">innerHTML</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        .....</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">// 如果没有template属性，通过选择器获取元素内容（即获取tempalte）</span></span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//此时template的值如果存在，一定是HTML字符串的形式，比如&#x27;&lt;p&gt;123&lt;/p&gt;&#x27;</span></span><br><span class="line">    <span class="comment">//然后再进行模板编译，得到渲染函数</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">        <span class="comment">//省略.....</span></span><br><span class="line">      &#125;, <span class="variable language_">this</span>)</span><br><span class="line">      options.<span class="property">render</span> = render</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line">      .......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">mountComponent</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读上面代码，我们能得到以下结论：</p><ul><li><p>根元素不能是<code>body</code>或者<code>html</code>，也就是说<code>el</code>的指向不能是这两个元素。</p></li><li><p><code>$mount</code>方法的工作流程就是：</p></li></ul><ul><li><p>如果有<code>render</code>函数则直接调用<code>mountComponent</code>方法</p></li><li><p>如果没有<code>render</code>函数，则尝试生成这个函数：</p><ul><li><p>如果有<code>template</code>属性，再考虑这个属性的值，我们期望是一个html字符串，但实际还可能是dom对象，我们把它转化成html字符串</p></li><li><p>如果既没有<code>render</code>也没有<code>template</code>，那就必须有<code>el</code>，通过<code>getOuterHTML(el)</code>得到的值来代替<code>template</code></p></li><li><p>无论如何，最终<code>template</code>属性的值是一个html字符串</p></li><li><p>解析，编译模板字符串，得到<code>render</code>函数，挂载到<code>options</code>上</p></li></ul></li></ul><p>生成<code>render</code>函数，挂载到<code>options</code>上后，再调用<code>mountComponent</code>开始开始渲染</p><h4 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  el: ?Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 如果没有获取解析的render函数，则会抛出警告</span></span><br><span class="line">  <span class="comment">// render是解析模板文件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">	....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行beforeMount钩子</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">//调用_render方法生成vnode</span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">//调用_update方法将虚拟dom转化成真实dom并放入页面</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定义更新函数</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听当前组件状态，当有数据变化时，更新组件</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    <span class="title function_">before</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据更新引发的组件更新</span></span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，在beforeMount钩子被调用的时候，模板已经编译完毕，render函数已经准备好了，不过还没有被调用。</p><p><strong>_render方法源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// render函数来自于组件的option</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中。</p><h2 id="手写一个简单的Vue"><a href="#手写一个简单的Vue" class="headerlink" title="手写一个简单的Vue"></a>手写一个简单的Vue</h2><p>了解了Vue实例的挂载过程后，我们应该就能够模拟实现一个简单的Vue。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>你好啊&#123;&#123;str&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    &#123;&#123;num&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app =  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    	<span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    	<span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">     	 <span class="attr">str</span>: <span class="string">&#x27;tom&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      	 <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    	&#125;,</span></span><br><span class="line"><span class="language-javascript">    	<span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      		<span class="title function_">add</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        		<span class="variable language_">this</span>.<span class="property">num</span>++</span></span><br><span class="line"><span class="language-javascript">      		&#125;</span></span><br><span class="line"><span class="language-javascript">    	&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span><span class="comment">//假设是个对象，不是函数data()</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">         <span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//递归进行模板解析</span></span><br><span class="line">          <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点,进行模板替换</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    $replace(item)&#123;</span><br><span class="line">      <span class="comment">//非贪婪匹配</span></span><br><span class="line">      <span class="comment">//通过textContent拿到文本结点的内容</span></span><br><span class="line">      item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key.<span class="title function_">trim</span>()]<span class="comment">//必须返回用来替换的字符串</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>vue2的生命周期函数很好实现，无非就是在特定时期调用特定的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line">        <span class="keyword">if</span>(options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">$el</span>= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line">		<span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a><strong>添加事件</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//@click</span></span><br><span class="line">          <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//最终还是使用了原生语法</span></span><br><span class="line">            item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// 如果此处使用的不是箭头函数，this的指向就是item了,我们要让this的指向变为vue实例。</span></span><br><span class="line">              <span class="comment">// item.getAttribute(&#x27;@click&#x27;).trim() 获取@click属性的值</span></span><br><span class="line">              <span class="comment">// 获取到这个属性的值，去除前后空格，假设是一个已有的方法名</span></span><br><span class="line">              <span class="comment">// 调用这个方法，同时修改函数的指向，使它指向vue实例，同时传入事件对象e</span></span><br><span class="line">              <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//递归</span></span><br><span class="line">          <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">    $proxy() &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">          <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="comment">//数据未改变直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$data</span>[key]===newVal)&#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加响应式"><a href="#添加响应式" class="headerlink" title="添加响应式"></a>添加响应式</h3><img src="..\images\前端面试-vue\响应式.png" style="zoom:80%"><p>至此，我们修改数据，视图显然是不会更新的，即没有实现<code>数据驱动视图更新的效果</code>，简单来说，就是没有实现<strong>响应式</strong>。</p><p>想要实现响应式，<strong>我们需要监听数据，并收集依赖</strong></p><p>所谓<strong>收集依赖</strong>，就是要知道<code>data</code>中的某个属性，到底在哪些文本结点(或者计算属性)中使用过了，换句话说，就是这些文本结点依赖data中的那个数据；这个数据改变时，我们需要<strong>监听</strong>到这个数据的变化，然后通知依赖这个数据的文本结点(或者计算属性)更新内容。</p><p><strong>依赖收集</strong>主要是在<code>模板解析</code>过程中进行的，在监听到数据的<code>getter</code>被触发的时候，收集它的依赖。</p><p>我们定义一个<code>Watcher</code>类来记录<code>文本结点</code>，<code>文本结点内部未编译前的字符串</code>，和它<code>依赖的数据(vm.key)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">vm,key,node,str</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">str</span> = str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">str</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">         &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;<span class="comment">//其实如果data是函数的话，还要调用函数。</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span> = &#123;&#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span>(options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">        <span class="variable language_">this</span>.$proxy()</span><br><span class="line">        <span class="comment">//监听this.$data中的数据的变化</span></span><br><span class="line">        <span class="variable language_">this</span>.$observe()</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        .......</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">$el</span>= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line">        <span class="comment">//编译模板</span></span><br><span class="line">		<span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">        ......</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点和元素结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//@click</span></span><br><span class="line">          <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//本质基于原生js语法</span></span><br><span class="line">            item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    $replace(item)&#123;</span><br><span class="line">      item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">          	key = key.<span class="title function_">trim</span>()</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$Watcher</span>[key])&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>,key,item,item.<span class="property">textContent</span>))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>,key,item,item.<span class="property">textContent</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[key]<span class="comment">//返回用来替换的字符串,就是data中的值</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用来给数据添加代理</span></span><br><span class="line">	$proxy() &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">          <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="comment">//数据未改变直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$data</span>[key]===newVal)&#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//用来给数据添加监听，即监听this.$data中数据的改变</span></span><br><span class="line">    $observe()&#123;</span><br><span class="line">        <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//先取出值，防止无限递归</span></span><br><span class="line">            <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>,key,&#123;</span><br><span class="line">                <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> value</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">                    <span class="comment">//get,set中的this指向的是this.$data</span></span><br><span class="line">                    <span class="keyword">if</span>(value===newVal)&#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果newVal是obj，还要递归添加响应式。</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                        <span class="variable language_">this</span>.$observe(newVal)</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = newVal</span><br><span class="line">                    <span class="comment">//通知依赖更新</span></span><br><span class="line">                    vm.<span class="property">$Watcher</span>[key].<span class="title function_">forEach</span>(<span class="function"><span class="params">w</span>=&gt;</span>&#123;</span><br><span class="line">                        w.<span class="title function_">update</span>()</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果值是对象，则递归添加响应式</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> value == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.$observe(value)   </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向绑定-1"><a href="#双向绑定-1" class="headerlink" title="双向绑定"></a><strong>双向绑定</strong></h3><p><code>双向绑定</code>并不等同于<code>响应式</code>了，这两个东西是有区别的。</p><p><code>响应性</code>简单来讲就是当更改响应式数据时，视图会随即自动更新，即<code>数据驱动视图更新</code>。而实现这个功能的原理就是<code>劫持(监听)数据</code>，<code>收集依赖</code>，当数据发生变化时，执行相应的依赖（副作用&#x2F;更新视图）。</p><p><code>双向绑定</code>是数据变化驱动视图更新，视图更新触发数据变化。其实就是<code>v-model</code>的功能，而我们知道<code>v-model</code>只是一个语法糖。因此如果要问<code>双向绑定</code>的原理，思路应该是<code>如何实现这个语法糖</code>。</p><p>只需完善<code>$compile</code>方法和<code>update</code>方法。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, node, str</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//如果不是文本结点，即没有模板字符串，更新的是元素结点的属性值</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">str</span> === <span class="literal">undefined</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">str</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">      <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;<span class="comment">//只考虑data是对象的情况</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$Watcher</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">    <span class="variable language_">this</span>.$proxy()</span><br><span class="line">    <span class="comment">//监听this.$data中的数据改变</span></span><br><span class="line">    <span class="variable language_">this</span>.$observe()</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line">    <span class="comment">//模板解析</span></span><br><span class="line">    <span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  $compile(node) &#123;</span><br><span class="line">    <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">    node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//nodeType 结点类型</span></span><br><span class="line">      <span class="comment">// 1 表示元素结点</span></span><br><span class="line">      <span class="comment">// 3 表示文本结点</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//@click</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">          <span class="comment">//本质还是使用了原生语法</span></span><br><span class="line">          item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果此处使用的不是箭头函数，this的指向就是item了,我们要让this的指向变为vue实例。</span></span><br><span class="line">            <span class="comment">// item.getAttribute(&#x27;@click&#x27;).trim() 获取@click属性的值</span></span><br><span class="line">            <span class="comment">// 获取到这个属性的值，去除前后空格，假设是一个已有的方法名</span></span><br><span class="line">            <span class="comment">// 调用这个方法，同时修改函数的指向，使它指向vue实例，同时传入事件对象e</span></span><br><span class="line">            <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//v-model</span></span><br><span class="line">        <span class="keyword">if</span>(item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>))&#123;</span><br><span class="line">          <span class="keyword">const</span> key = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">          item.<span class="property">value</span> = <span class="variable language_">this</span>[key] <span class="comment">//赋值</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$Watcher</span>.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item))</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item))</span><br><span class="line">          &#125;</span><br><span class="line">          item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>[key] = item.<span class="property">value</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果是文本结点</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  $replace(item) &#123;</span><br><span class="line">    <span class="comment">//非贪婪匹配</span></span><br><span class="line">    <span class="comment">//通过textContent拿到文本结点的内容</span></span><br><span class="line">    <span class="comment">//如果文本节点中没有使用模板字符串，则匹配不到任何内容，回调函数中的代码也不会执行。</span></span><br><span class="line">    item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">      <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">      key = key.<span class="title function_">trim</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$Watcher</span>[key]) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item, item.<span class="property">textContent</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item, item.<span class="property">textContent</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>[key]<span class="comment">//返回用来替换的字符串,就是data中的值</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来给数据添加代理</span></span><br><span class="line">  $proxy() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">        <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">          <span class="comment">//数据未改变直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$data</span>[key] === newVal) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来给数据添加监听，即监听this.$data中数据的改变</span></span><br><span class="line">  $observe() &#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//先取出值，防止无限递归</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">          <span class="comment">//set函数内部的this指向this.$data</span></span><br><span class="line">          <span class="keyword">if</span> (value === newVal) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.$observe(newVal)</span><br><span class="line">          &#125;</span><br><span class="line">          value = newVal</span><br><span class="line">          vm.<span class="property">$Watcher</span>[key].<span class="title function_">forEach</span>(<span class="function"><span class="params">w</span> =&gt;</span> &#123;</span><br><span class="line">            w.<span class="title function_">update</span>()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//如果值是对象，则递归添加响应式</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.$observe(value)   </span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app =  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">str</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">num</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue-observable你有了解过吗？说说看"><a href="#Vue-observable你有了解过吗？说说看" class="headerlink" title="Vue.observable你有了解过吗？说说看"></a>Vue.observable你有了解过吗？说说看</h2><p><code>Vue.observable</code>，让一个对象变成响应式数据。<code>Vue</code> 内部会用它来处理 <code>data</code> 函数返回的对象</p><p>在 <code>Vue 2.x</code> 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，它和被返回的对象是同一个对象，不过在原来的基础上添加了响应式，这一点，看看前面对<code>defineReactive</code>方法的介绍就很容易理解了。</p><p>在 <code>Vue 3.x</code> 中，则会返回一个可响应的代理对象，而对源对象直接进行变更仍然是不可响应的，因为在vue3中响应式的实现是基于<code>Proxy</code>这个构造函数，传入一个对象，会返回一个<code>新的</code>代理对象，对代理对象的修改会映射到源对象。</p><p><strong>使用场景</strong></p><p>创建一个<code>js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue</span></span><br><span class="line"><span class="string">// 创建state对象，使用observable让state对象可响应</span></span><br><span class="line"><span class="string">export let state = Vue.observable(&#123;</span></span><br><span class="line"><span class="string">  name: &#x27;</span>张三<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">  &#x27;</span>age<span class="string">&#x27;: 38</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>在<code>.vue</code>文件中直接使用即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    姓名：&#123;&#123; name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    年龄：&#123;&#123; age &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName(&#x27;李四&#x27;)&quot;</span>&gt;</span>改变姓名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;setAge(18)&quot;</span>&gt;</span>改变年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; state, mutations &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  // 在计算属性中拿到值</span></span><br><span class="line"><span class="string">  computed: &#123;</span></span><br><span class="line"><span class="string">    name() &#123;</span></span><br><span class="line"><span class="string">      return state.name</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    age() &#123;</span></span><br><span class="line"><span class="string">      return state.age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  // 调用mutations里面的方法，更新数据</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    changeName(name) &#123;</span></span><br><span class="line"><span class="string">       state.name = name</span></span><br><span class="line"><span class="string">  	&#125;,</span></span><br><span class="line"><span class="string">  	setAge(age) &#123;</span></span><br><span class="line"><span class="string">       state.age = age</span></span><br><span class="line"><span class="string">  	&#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>详细解释</strong></p><p><code>依赖收集</code>是组件初始化过程中，模板解析时候的工作，组件模板解析的时候，如果使用到了某个<code>响应式对象</code>的某个属性，就会<code>new</code>一个<code>watcher</code>，存储到<code>Dep.target</code>中，然后取值的时候会触发<code>getter</code>，<code>getter</code>内部会判断<code>Dep.target</code>是否为空，不为空则收集依赖，把这个<code>watcher</code>取出来，<code>push</code>到这个属性（key）的<code>deps</code>（依赖数组）中。然后某个属性值修改的时候就会触发对应的<code>setter</code>，通知这些依赖的<code>watcher</code>更新内容，即调用依赖这个属性（key）的<code>watcher</code>的<code>update</code>方法。</p><p>所以说<code>Vue.observable</code>只能给数据添加响应式，但是想要实现数据修改，依赖这些数据的组件也重新渲染，就需要在模板解析过程中收集依赖。</p><h2 id="说说你对slot的理解？slot使用场景有哪些？"><a href="#说说你对slot的理解？slot使用场景有哪些？" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些？"></a>说说你对slot的理解？slot使用场景有哪些？</h2><p><code>slot</code>的作用就是用来<strong>自定义组件内部的结构</strong></p><p><code>slot</code>可以分来以下三种：</p><ul><li>默认插槽</li><li>具名插槽</li><li>作用域插槽</li></ul><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>子组件用<code>&lt;slot&gt;</code>标签，来确定渲染的位置，标签里面可以放<code>DOM</code>结构，当父组件没有往插槽传入内容，标签内<code>DOM</code>结构，就会显示在页面</p><p>父组件在使用的时候，直接在子组件的标签内写入内容即可</p><p>子组件<code>Child.vue</code>，使用slot标签占位，标签体内的结构是默认结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件向子组件传递结构，只需要在子组件标签体内写结构就好了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>默认插槽<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件给子组件传入的自定义结构，可以在子组件的<code>this.$slots</code>属性中拿到。</p><img src="..\images\前端面试-vue\slot.png" style="zoom:67%"><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>默认插槽形如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们给<code>slot</code>标签添加<code>name</code>属性，默认插槽就变成了具名插槽</p><p>当我们需要在子组件内部的多个位置使用插槽的时候，为了把各个插槽区别开，就需要给每个插槽取名。</p><p>同时父组件传入自定义结构的时候，也要指明是传递给哪个插槽的，形象的来说，就是子组件挖了多个坑，然后父组件来这些填坑，需要把具体的结构填到具体的哪个坑。</p><p>子组件<code>Child.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具名插槽⽤插槽名做参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:content</span>&gt;</span>内容...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>template</code>标签是用来分割，包裹自定义结构的。<code>v-slot</code>属性用来指定这部分结构用来替换哪个插槽，所以<code>v-slot</code>指令是放在template标签上的，要注意的是如果想要将某部分结构传递给指定的插槽，因该使用<code>v-slot:xxx</code>，而不是<code>v-slot=&#39;xxx&#39;</code></p><p><code>v-slot:default</code>可以简化为<code>#default</code>，<code>v-slot:content</code>可以简化成<code>#content</code></p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>子组件在<code>slot</code>标签上绑定属性，来将子组件的信息传给父组件使用，所有绑定的属性（除了name属性），都会被收集成一个对象，被父组件的<code>v-slot</code>属性接收。</p><p>子组件<code>Child.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">testProps</span>=<span class="string">&quot;子组件的值&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>没传footer插槽<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过解构获取<code>v-slot=&#123;user&#125;</code>，还可以重命名<code>v-slot=&quot;&#123;user: newName&#125;&quot;</code>和定义默认值<code>v-slot=&quot;&#123;user = &#39;默认值&#39;&#125;&quot;</code></p><p>所在<code>slot</code>中也存在’’双向数据传递’’，父组件给子组件传递<code>页面结构</code>，子组件给父组件传递子组件的数据。</p><h2 id="你有写过自定义指令吗？自定义指令的应用场景有哪些？"><a href="#你有写过自定义指令吗？自定义指令的应用场景有哪些？" class="headerlink" title="你有写过自定义指令吗？自定义指令的应用场景有哪些？"></a>你有写过自定义指令吗？自定义指令的应用场景有哪些？</h2><h3 id="什么是指令"><a href="#什么是指令" class="headerlink" title="什么是指令"></a>什么是指令</h3><p>在<code>vue</code>中提供了一套为<code>数据驱动视图</code>更为方便的操作，这些操作被称为<code>指令系统</code>。简单的来说，<code>指令系统</code>能够简化dom操作，帮助方便的实现<code>数据驱动视图更新</code>。</p><p>我们看到的<code>v-</code>开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能</p><p>除了核心功能默认<code>内置的指令</code> (<code>v-model</code> 和 <code>v-show</code>)，<code>Vue</code> 也允许注册<code>自定义指令</code></p><p><strong>指令使用的几种方式：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会实例化一个指令，但这个指令没有参数 </span></span><br><span class="line">v-xxx</span><br><span class="line"></span><br><span class="line"><span class="comment">//将值传到指令中</span></span><br><span class="line">v-xxx=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串传入到指令中，如v-html=&quot;&#x27;&lt;p&gt;内容&lt;/p&gt;&#x27;&quot;</span></span><br><span class="line">v-xxx=<span class="string">&quot;&#x27;string&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参数（arg），如v-bind:class=&quot;className&quot;</span></span><br><span class="line">v-<span class="attr">xxx</span>:arg=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用修饰符（modifier）</span></span><br><span class="line">v-<span class="attr">xxx</span>:arg.<span class="property">modifier</span>=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：指令中传入的都是<strong>表达式</strong>，无论是不是自定义指令，比如<code>v-bind:name = &#39;tom&#39;</code>，传入的是tom这个变量的值，而不是tom字符串，除非写成<code>&quot;&#39;tom&#39;&quot;</code>，传入的才是字符串。</p></blockquote><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>关于自定义指令，我们关心的就是三大方面，<strong>自定义指令的定义，自定义指令的注册，自定义指令的使用</strong>。</p><p><code>自定义指令</code>的使用方式和<code>内置指令</code>相同，我们不再研究，其中的难点就是<code>定义自定义指令</code>部分。</p><h4 id="注册自定义指令"><a href="#注册自定义指令" class="headerlink" title="注册自定义指令"></a>注册自定义指令</h4><p>注册一个自定义指令有<code>全局注册</code>与<code>局部注册</code>两种方式</p><p>全局注册主要是通过<code>Vue.directive</code>方法进行注册</p><p><code>Vue.directive</code>第一个参数是指令的名字（不需要写上<code>v-</code>前缀），第二个参数可以是对象数据，也可以是一个指令函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局注册一个自定义指令 `v-focus`</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()  <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部注册通过在组件配置对象中设置<code>directives</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>() <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure><p>在vue3中，局部注册的语法就不同了。如果混合使用<code>选项式api</code>，就可以像vue2一样借助<code>directives</code>属性解决，如果使用的是<code>setup语法糖</code>写法，就需要遵守如下语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用局部注册的自定义指令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-highlight</span>=<span class="string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>This text will be highlighted in yellow<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; directive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义一个高亮指令</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> highlight = <span class="title function_">directive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="property">style</span>.<span class="property">backgroundColor</span> = binding.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义一个聚焦指令</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> focus = <span class="title function_">directive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="title function_">focus</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入<code>directive</code>函数，传入自定义指令，完成组件的局部注册。</p><h4 id="定义自定义指令"><a href="#定义自定义指令" class="headerlink" title="定义自定义指令"></a>定义自定义指令</h4><p>自定义指令本质就是一个<strong>包含特定钩子函数的js对象</strong></p><p>在vue2中，这些常见的钩子函数包括：</p><ul><li><p><strong>bind()</strong></p><p><code>只调用一次</code>，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置，此时无法通过<code>el</code>拿到父级元素，也就是<code>el.parentNode</code>为空，但是也已经能拿到绑定的dom元素了。</p></li><li><p><strong>inserted()</strong></p><p>绑定指令的元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中，因为父元素可能还没插入文档中呢)，此时可以通过<code>el.parentNode</code>拿到父级元素</p></li><li><p><strong>mounted()</strong></p><p>指令绑定的元素被插入到<code>文档</code>中之后</p></li><li><p><strong>update()</strong></p><p>传入指令的值改变后触发</p></li><li><p><strong>unbind()</strong></p><p>只调用一次，指令与元素<code>解绑</code>时调用</p></li></ul><blockquote><p>注意：上述钩子函数在vue3中并不都有效，vue3中的自定义指令钩子函数和生命周期函数一致，具体见官方文档，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/reusability/custom-directives#directive-hooks">https://cn.vuejs.org/guide/reusability/custom-directives#directive-hooks</a></p></blockquote><p>所有的钩子函数的参数都有以下：</p><ul><li><p><strong>el</strong>：指令所绑定的元素，可以用来直接操作 <code>DOM</code>，省去了手动捕获dom的步骤</p></li><li><p><strong>binding</strong>：</p><p>一个对象，包含以下property</p><ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：传入指令的表达式的值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>，又比如<code>v-for=&quot;(value, key, index) in obj&quot;</code>，传入的表达式为<code>&quot;(value, key, index) in obj&quot;</code></li><li><code>arg</code>：<strong>传给指令的参数</strong>，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>，又比如<code>v-bind:class = &quot;[&#39;box&#39;]&quot;</code>的参数为<code>class</code></li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code></li></ul></li><li><p><code>vnode</code>：<code>Vue</code> 编译生成的虚拟节点</p></li><li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用</p></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>给某个元素添加节流</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.设置v-throttle自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;throttle&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">bind</span>: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> throttleTime = binding.<span class="property">value</span>; <span class="comment">// 节流时间</span></span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; <span class="comment">// 用户若不设置节流时间，则默认2s</span></span><br><span class="line">      throttleTime = <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="comment">//el是绑定指令的元素</span></span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!timer) &#123; <span class="comment">// 第一次执行</span></span><br><span class="line">      	<span class="comment">//开启定时器，占用临界资源</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//一定事件后，释放资源</span></span><br><span class="line">          timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">        <span class="comment">//同时绑定的另一个监听器也被调用，触发sayHello函数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果在前throttleTime的时间内已经点击过了，则阻止目标元素绑定的监听器被调用，也就是说，sayHello不会被调用 </span></span><br><span class="line">        <span class="comment">//它不仅会阻止事件继续沿 DOM 树传播，还会阻止在同一阶段内其他监听器的执行，包括目标阶段的监听器。</span></span><br><span class="line">        event &amp;&amp; event.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);<span class="comment">//捕获触发，触发的顺序在冒泡触发之前</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.为button标签设置v-throttle自定义指令</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">v-throttle</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Vue常用的修饰符有哪些有什么应用场景"><a href="#Vue常用的修饰符有哪些有什么应用场景" class="headerlink" title="Vue常用的修饰符有哪些有什么应用场景"></a>Vue常用的修饰符有哪些有什么应用场景</h2><h3 id="修饰符是什么"><a href="#修饰符是什么" class="headerlink" title="修饰符是什么"></a>修饰符是什么</h3><p>在<code>Vue</code>中，修饰符是用来修饰Vue中的指令的，它<strong>处理了许多<code>DOM</code>事件的细节</strong>，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。</p><p><code>vue</code>中修饰符分为以下五种：</p><ul><li>表单修饰符</li><li>事件修饰符</li><li>鼠标按键修饰符</li><li>键值修饰符</li><li>v-bind修饰符</li></ul><h3 id="修饰符的具体作用"><a href="#修饰符的具体作用" class="headerlink" title="修饰符的具体作用"></a>修饰符的具体作用</h3><h4 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h4><p>在我们填写表单的时候用得最多的是<code>input</code>标签，指令用得最多的是<code>v-model</code></p><p>关于表单的修饰符有如下：</p><ul><li>lazy</li><li>trim</li><li>number</li></ul><p><strong>lazy</strong></p><p>在我们填完信息，光标离开标签的时候，才会将值赋予给<code>value</code>，也就是在<code>change</code>事件之后再进行信息同步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>trim</strong></p><p>自动过滤用户输入的首尾空格字符，而中间的空格不会过滤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">trim</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>number</strong></p><p>自动将用户的输入值转为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.<span class="property">number</span>=<span class="string">&quot;age&quot;</span> type=<span class="string">&quot;number&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ul><li><p>stop：阻止事件冒泡，等在传入的回调函数中添加 <code>event.stopPropagation()</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.<span class="property">stop</span>=<span class="string">&quot;handleClick&quot;</span>&gt;点击不会冒泡&lt;/button&gt;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClickWithStop</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();  <span class="comment">// 手动阻止冒泡</span></span><br><span class="line">  <span class="comment">// 其他业务逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>prevent：阻止默认行为，等同于在传入的回调函数中添加 <code>event.preventDefault()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;handleSubmit&quot;</span>&gt;</span>提交表单不会刷新页面<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>capture：使用事件捕获模式（默认是冒泡模式）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">&quot;parentClick&quot;</span>&gt;</span>父级先触发<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>self：仅当事件从元素本身（而非子元素）触发时执行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.self</span>=<span class="string">&quot;onlySelfClick&quot;</span>&gt;</span>点击子元素不触发<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>once：事件只触发一次，之后自动移除对该事件的监听，避免因长期持有未使用的监听函数导致内存泄漏、</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;oneTimeAction&quot;</span>&gt;</span>仅首次点击有效<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实在原生dom事件中，实现这个效果也是非常简单的，只需要在第三个参数传入<code>&#123; once: true &#125;</code>，手动通过removeEventListener还是比较消耗精力的，不过灵活度更大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>passive：提升滚动性能，不与 <code>prevent</code> 同时使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>滚动更流畅<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当监听 <code>touchstart</code>、<code>touchmove</code> 或 <code>wheel</code>（滚动）等高频事件时，浏览器的默认行为是：等待事件处理函数执行完毕</p><p>再决定是否执行默认行为（如滚动页面），如果事件处理函数中存在耗时操作（如复杂计算），会导致 <strong>滚动卡顿</strong>，因为浏览器必须等待函数执行完毕，才能滚动页面（默认行为）。</p><p><code>passive</code> 修饰符的作用，是通过将事件监听器标记为 <strong>被动模式（Passive）</strong>，本质是向浏览器承诺：<br>​“此事件处理函数不会调用 <code>event.preventDefault()</code>”​，从而允许浏览器 ​<strong>立即触发默认行为</strong>，无需等待函数执行。</p><p>Vue 3 的 <code>.passive</code> 修饰符对应原生 <code>addEventListener</code> 的 <code>&#123; passive: true &#125;</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 编译后的等效代码</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p><code>.passive</code> 向浏览器承诺 <strong>不会阻止默认行为</strong>，而 <code>.prevent</code> 的作用是 <strong>主动阻止默认行为</strong>，二者语义冲突，所以不能同时使用。</p></li></ul><h2 id="Vue中组件和插件有什么区别"><a href="#Vue中组件和插件有什么区别" class="headerlink" title="Vue中组件和插件有什么区别"></a>Vue中组件和插件有什么区别</h2><h3 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h3><p>在vue中，组件就是能实现<code>部分功能</code>的html，css，js代码的集合。</p><p><strong>优势</strong></p><ul><li><p>降低整个系统的<code>耦合度</code></p><p>在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</p></li><li><p>提高代码的<code>可维护性</code>，和<code>可复用性</code></p><p>由于每个组件的职责单一，并且组件在系统中是被复用的。</p></li></ul><h3 id="插件是什么"><a href="#插件是什么" class="headerlink" title="插件是什么"></a>插件是什么</h3><p>插件通常用来为 <code>Vue</code> 添加全局功能，比如通过全局混入来添加一些组件选项。如<code>vue-router</code></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>两者的区别主要表现在以下几个方面：</p><ul><li>编写形式</li><li>注册形式</li></ul><h4 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h4><p><strong>组件</strong></p><p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件。</p><p><strong>插件</strong></p><p><code>vue</code>插件就是一个实现了 <code>install</code> 方法的对象。这个方法的第一个参数是 <code>Vue</code> 构造函数，第二个参数是一个可选的选项对象(options)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">myGlobalMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">bind</span> (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params">methodOptions</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册形式"><a href="#注册形式" class="headerlink" title="注册形式"></a>注册形式</h4><p><strong>组件注册</strong></p><p><code>vue</code>组件注册主要分为<code>全局注册</code>与<code>局部注册</code></p><p>局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure><p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component1 = &#123;...&#125;<span class="comment">// 定义一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="attr">components</span>:&#123;</span><br><span class="line">		component1<span class="comment">//局部注册</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在vue3中的组件注册</strong>：</p><p>全局注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>; <span class="comment">// 引入你的组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="title class_">MyComponent</span>); <span class="comment">// 全局注册组件</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>局部注册：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">MyComponent</span> <span class="comment">// 局部注册组件</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>; <span class="comment">// 引入你的组件</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用局部注册的组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>&lt;script setup&gt;</code> 中导入的组件会<strong>自动注册</strong>并在模板中可用，无需显式地在 <code>components</code> 选项中列出它们。</p><p><strong>插件注册</strong></p><p>插件的注册通过<code>Vue.use()</code>的方式进行注册，第一个参数为<code>插件的名字</code>，第二个参数是可选择的<code>配置项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名字[,options])</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">use</span> = <span class="keyword">function</span>(<span class="params">plugin,options</span>)&#123;</span><br><span class="line">    <span class="comment">//this指向Vue构造函数</span></span><br><span class="line">    <span class="comment">//在use方法内部，会调用插件的install方法</span></span><br><span class="line">    plugin.<span class="title function_">install</span>(<span class="variable language_">this</span>,options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用<code>之前</code>完成，<code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次。</p></blockquote><h2 id="Vue组件通信的方式有哪些"><a href="#Vue组件通信的方式有哪些" class="headerlink" title="Vue组件通信的方式有哪些"></a>Vue组件通信的方式有哪些</h2><p><code>vue</code>中，每个组件之间的都有<code>独自的作用域</code>，组件间的数据是无法共享的，但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的，要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。</p><h3 id="组件间通信的分类"><a href="#组件间通信的分类" class="headerlink" title="组件间通信的分类"></a>组件间通信的分类</h3><ul><li>父子组件之间的通信</li><li>兄弟组件之间的通信</li><li>祖孙与后代组件之间的通信</li><li>非关系组件间之间的通信</li></ul><h3 id="组件间通信的方案"><a href="#组件间通信的方案" class="headerlink" title="组件间通信的方案"></a>组件间通信的方案</h3><h4 id="props传递数据"><a href="#props传递数据" class="headerlink" title="props传递数据"></a>props传递数据</h4><p>适用场景：父组件传递数据给子组件，即父子组件之间的通信</p><p>父组件通过给子组件标签添加属性，来传递值，子组件设置<code>props</code>属性，接收父组件传递过来的参数，同时还能限制父组件传递过来的数据的类型，还能设置默认值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">name</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">age</span>=<span class="string">18</span> /&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Children.vue</span></span><br><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line"> <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line"> <span class="comment">// 对象形式  </span></span><br><span class="line"> <span class="attr">age</span>:&#123;    </span><br><span class="line">     <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">     <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">     <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>props中的数据是父组件的，子组件不能直接修改，遵循”谁的数据谁来维护”的原则。</li><li>子组件标签的所有属性中，未被子组件接收（props中未声明）的数据，也能在<code>this.$attr</code>，即<code>组件实例的属性</code>中拿到，因为未被接受的属性，就会被当作组件自身的普通属性。</li></ul><p>再问大家一个问题，为什么父组件中的数据更新，子组件中通过<code>props</code>接收的数据也会随之改变？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;span&gt;age:&#123;&#123;age&#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Child&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    age: Number</span><br><span class="line">  &#125;,</span><br><span class="line">  updated()&#123;</span><br><span class="line">    console.log(&#x27;更新了&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;      </span><br><span class="line">    &lt;!-- 向子组件传递一个基本数据类型 --&gt;</span><br><span class="line">    &lt;Child :age=&quot;age&quot;&gt;</span><br><span class="line">    &lt;/Child&gt;</span><br><span class="line">    &lt;button @click=&quot;add(&#x27;age&#x27;)&quot;&gt;age++&lt;/button&gt;  </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;@/components/Child.vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      age:1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">      this.age++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>父组件的模板，在模板编译的时候，会被解析成一个<code>render</code>函数，这一点我们在前面已经介绍过了，在上述例子中，父组件的模板解析成<code>render</code>函数大概是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>, <span class="comment">// 根元素 div</span></span><br><span class="line">    [ <span class="comment">// 子节点数组</span></span><br><span class="line">      <span class="title function_">createElement</span>(<span class="string">&#x27;Child&#x27;</span>, &#123; <span class="comment">// 子组件 Child，绑定 props.age</span></span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">          <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span> <span class="comment">// 传递父组件的 age 属性</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 按钮元素，绑定 click 事件</span></span><br><span class="line">      <span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">on</span>: &#123;</span><br><span class="line">          <span class="attr">click</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(<span class="string">&#x27;age&#x27;</span>) <span class="comment">// 触发 add(&#x27;age&#x27;) 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="string">&#x27;age++&#x27;</span>)<span class="comment">//&#x27;age++&#x27;是标签体内容</span></span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用父组件的模板<code>render</code>函数时，访问了父组件实例的<code>age</code>属性，赋值给子组件的<code>props.age</code>，这个过程中触发<code>age</code>属性的<code>getter</code>，于是收集父组件自身的<code>render</code>函数为依赖（渲染Watcher）</li><li>调用父组件的模板<code>render</code>函数，遇到子组件标签时，会调用 Vue 内部的 <code>createComponent</code> 方法，根据子组件的配置（如 <code>props</code>、<code>slots</code> 等），创建子组件的实例 ，然后子组件初始化的时候，会调用<code>initProps</code>方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的第二个参数，是子组件中的props属性的值（props配置对象）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initProps</span>(<span class="params">vm, propsOptions</span>) &#123;</span><br><span class="line">  <span class="comment">//拿到子组件声明并接收到的所有props数据（不包括普通标签属性）</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.<span class="property">$options</span>.<span class="property">propsData</span> || &#123;&#125;;</span><br><span class="line">  <span class="comment">//创建一个空对象，挂载到组件实例_props属性上</span></span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">_props</span> = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历props配置对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">// 使用propsOptions校验propsData</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm);</span><br><span class="line">    <span class="comment">// 组件接收的属性，会被添加到vm._props上，并添加响应式</span></span><br><span class="line">    <span class="title function_">defineReactive</span>(props, key, value);</span><br><span class="line">    <span class="comment">// 代理到实例（this），然后就能直接通过this访问</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">&#x27;_props&#x27;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父组件传递了，且子组件通过<code>props</code>接收的数据，会被存储在<code>vm.$options.propsData</code></li><li>子组件初始化的时候（调用<code>initProps</code>的时候），会将通过<code>props</code>接收的数据，添加响应式，并代理到<code>vm</code>上，缩短访问路径。</li></ul><p>上述例子中，父组件传递给子组件的值，只不过是<code>this.age</code>，是一个普通数据类型，压根不是响应式数据，这种传递会导致响应式丢失，触发<code>getter</code>的位置，也是在父组件渲染函数内，子组件压根就没被<code>age</code>属性收集为依赖，后续是子组件自己把<code>age</code>属性添加到<code>vm._props</code>并添加响应式的（后续又代理到vm），既然在父组件的<code>age</code>属性并没有收集子组件为依赖，为什么父组件更新age属性，子组件也能接收到最新的值呢？</p><ul><li>当父组件中的<code>age</code>属性改变，会触发对应的<code>setter</code>，然后通知依赖更新，其中的依赖就包括父组件<code>渲染Watcher</code></li><li>父组件<code>渲染Watcher</code>会调用<code>run</code>方法，这个方法会调用<code>render</code>函数，<strong>重新给子组件的<code>props</code>赋值</strong></li><li>后续子组件中<code>this._props</code>存储的就是最新的值。</li></ul><p>简单的来说，父组件修改传递给子组件的数据，子组件接收到的数据也会自动更新，<strong>是因为父组件内部重新调用了render方法</strong>。</p><p>参考文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/53218851">【Vue原理】Props - 白话版 - 知乎</a></p><h4 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h4><p>适用场景：子组件传递数据给父组件(父子组件通信)</p><p>子组件通过<code>$emit</code>触发自定义事件，<code>$emit</code>第一个参数为自定义的事件名，第二个参数为传递给父组件的数值</p><p>父组件在子组件上绑定事件监听，通过传入的<code>回调函数</code>拿到子组件的传过来的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Children.vue</span><br><span class="line">this.$emit(&#x27;add&#x27;, good)  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Father.vue</span><br><span class="line">&lt;Children @add=&quot;cartAdd(val)&quot; /&gt;  </span><br></pre></td></tr></table></figure><p>要注意的是，给组件添加的事件监听是自定义事件，因为组件标签不是原生标签，无法添加原生事件监听，也就没有原生事件对象，所以传递给回调函数的是子组件传递过来的值，而不是原生dom事件。</p><p>在vue2中，我们只要给父组件传递数据，并给对应的属性添加<code>sync</code>修饰符，就能省去在给组件标签添加事件监听，书写回调逻辑，同步父组件数据的代码，在vue3中，这一功能则是通过<code>v-mode</code>l实现的，更多介绍参考本博客内的《vue》一文。</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>在 Vue 2 中，<code>this.$refs</code> 是一个对象，它包含了所有通过 <code>ref</code> 属性注册的 <code>DOM 元素</code>或<code>组件实例</code>。你可以使用 <code>this.$refs</code> 来直接访问这些dom元素或组件实例，从而进行操作，如获取DOM节点、调用子组件实例的方法，获取数据等。</p><p><strong>注意：</strong><code>this.$refs</code> 只能在父组件中，用来引用通过 <code>ref</code> 属性标记的<code>子组件</code>或 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> ref=<span class="string">&quot;foo&quot;</span> /&gt;  </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">foo</span>  <span class="comment">// 获取子组件实例，通过子组件实例我们就能拿到对应的数据  </span></span><br></pre></td></tr></table></figure><p>同时，子组件也可通过<code>this.$parent</code>拿到父组件实例</p><h4 id="EventBus-事件总线"><a href="#EventBus-事件总线" class="headerlink" title="EventBus(事件总线)"></a><strong>EventBus(事件总线)</strong></h4><p>使用场景：兄弟组件传值</p><ul><li><p>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信</p><p>兄弟组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>,<span class="variable language_">this</span>.<span class="property">add</span>)   </span><br></pre></td></tr></table></figure><p>另一个兄弟组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$parent.emit(&#x27;add&#x27;)   </span><br></pre></td></tr></table></figure></li></ul><p>本质就是要找到一个<strong>两个兄弟组件都能访问到的vue实例</strong>，在这个实例上注册事件监听，同时也在这个实例上触发事件，本质和props，emit是一样的。这个vue实例的作用好像连接这两个组件的管道，通过这个Vue实例来通行。</p><h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><p>跨层级传递数据，传递方向是<strong>单向</strong>的，只能顶层向底层传递。</p><p>在<code>祖先组件</code>定义<code>provide</code>属性，<code>返回</code>传递的值，在后代组件通过<code>inject</code>接收祖先组件传递过来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类型是响应式的复杂类型则不是，这和vue2数据响应式的实现方式（递归添加响应式）有关</span></span><br><span class="line"><span class="comment">// 这里丢失响应式的原因，和解构响应式对象失去响应式的原因是一样的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="comment">// 普通类型（非响应式）</span></span><br><span class="line">      <span class="attr">userInfo</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125; <span class="comment">// 复杂类型（响应式）</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//使用data或者computed中的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">color</span>, <span class="comment">// 非响应式，因为this.color的值只是个普通类型</span></span><br><span class="line">      <span class="attr">userInfo</span>: <span class="variable language_">this</span>.<span class="property">userInfo</span>, <span class="comment">// 响应式，因为this.userInfo的值是个对象，而vue中对象是递归添加响应式的</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 如果多个祖先组件都提供了同名的属性，那么最接近的祖先组件提供的属性，会被优先使用（就近原则）。</span></span><br><span class="line">	<span class="attr">inject</span>: [<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;userInfo&#x27;</span>],<span class="comment">//书写格式太像props了</span></span><br><span class="line">	<span class="title function_">created</span> () &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>, <span class="variable language_">this</span>.<span class="property">userInfo</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>关于vuex的介绍，详见<a href="http://www.sanye.blog/posts/8b27fabc.html">vue | 三叶的博客</a></p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>还有一个问题，如果父组件数据更新，并且触发了父组件视图更新，子组件的视图一定会更新吗？</p><ul><li>如果父子组件并没有任何数据交互，那么子组件内部的数据和视图都不会更新：此时调用父组件的render方法，遇到子组件标签的时候，不会重新创建子组件实例，子组件内部不会发生任何变化</li><li>如果父组件通过<code>props</code>向子组件传值了，父组件视图更新，调用<code>render</code>方法的时候，会重新取值，赋值给子组件的<code>props</code>，然后子组件内的<code>this._props</code>就会发生改变，由于<code>this._props</code>在子组件内是响应式的，所以会触发对应的<code>setter</code>，但是如果子组件模板中并没有使用父组件传递过来的数据，子组件的<code>渲染watcher</code>由于不会被收集为依赖，所以子组件的视图不会更新。</li><li>对于父组件通过<code>Provide</code>提供，子组件通过<code>inject</code>接收的数据，由于在子组件内，不会对这些数据进行响应式处理，所以如果父组件通过<code>Provide</code>传递的是一个基本数据类型，在子组件内接收了，后续即便父组件修改这个基本数据类型，子组件也不会更新，但是如果父组件通过<code>Provide</code>传递的是一个对象，由于在vue中响应式是递归添加的，所以这个对象是个响应式对象，而且由于传递的是一个引用，其实父子组件是共用这个响应式对象的，如果子组件中在模板中使用了这个对象，则子组件的渲染Watcher会被它收集为依赖，这样即便在父组件内修改这个对象，在子组件的视图也会更新。</li><li>总的来说，父组件数据更新，子组件视图也更新了，本质是因为子组件<code>render</code>，被响应式数据收集为依赖，而且父组件数据更新，触发了这个响应式数据的setter。</li></ul><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><h3 id="什么是SPA，和MPA有什么区别？"><a href="#什么是SPA，和MPA有什么区别？" class="headerlink" title="什么是SPA，和MPA有什么区别？"></a>什么是SPA，和MPA有什么区别？</h3><ul><li><p>SPA指的是<strong>只有一个页面的web应用程序</strong>，所有必要的代码（<code>HTML</code>、<code>JavaScript</code>和<code>CSS</code>）都通过单个页面的加载而被加载（这样首屏加载速度就很慢），或者根据需要（通常是为响应用户操作），动态装载适当的资源，并添加到页面，页面在任何时间点都不会重新加载，也不会将控制转移到其他页面。</p></li><li><p>MPA（多页面应用程序）指的是有多个页面的web应用程序</p></li><li><p>SPA通过js操作dom，来局部更新页面内容；而MPA是通过页面切换，来实现整页的刷新，整页刷新就需加载整个页面所有<code>资源</code>，并重新渲染页面，速度慢；</p></li><li><p>SPA刷新速度更快，用户体验更好，同时把页面渲染工作交给客户端，减轻了服务端的压力。</p></li><li><p>缺点是不利于搜索引擎优化(SEO)，首屏加载速度较慢，当然这些问题都是可以解决的。</p></li></ul><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/spa.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFspa">面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢 | web前端面试 - 面试官系列</a></p><h3 id="如何实现SPA"><a href="#如何实现SPA" class="headerlink" title="如何实现SPA"></a>如何实现SPA</h3><p>SPA是通过hash路由或者history路由实现的，问如何实现SPA，其实就是在询问这两种路由是如何实现，关于这一点，可以参考后文。</p><h3 id="如何提高首屏加载速度？"><a href="#如何提高首屏加载速度？" class="headerlink" title="如何提高首屏加载速度？"></a>如何提高首屏加载速度？</h3><p>首屏加载时间，指的是浏览器从<strong>响应用户输入网址</strong>，到<strong>首屏内容</strong>渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容。</p><p><strong>首屏加载慢的原因</strong></p><ul><li>网络延时问题</li><li>资源文件体积是否过大</li><li>资源是否重复发送请求去加载了</li><li>加载脚本的时候，渲染内容堵塞了</li></ul><p><strong>提高首屏加载速度的方法</strong></p><ul><li><p>使用<strong>路由懒加载</strong></p><p><strong>路由懒加载本质就是异步加载js，css文件，或者说按需加载js，css文件。</strong></p><p>对于非首屏组件，使用路由懒加载，当需要访问这些组件的时候，再加载对应的资源。</p><p>开发单页面应用程序时，只有一个<code>html</code>页面，打包后也只有一个<code>index.html</code>页面，其他所谓的<code>页面</code>，都是通过 <code>JavaScript</code> 动态地修改<code>DOM</code>来实现的。开发过程中，一个页面对应一个或者多个<code>组件</code>，在打包后，每个组件都会转化成对应的<code>css</code>，<code>js</code>代码，其中的<code>js代码</code>不光包括业务逻辑，也负责修改dom，构建页面。</p><p>如果使用<code>路由懒加载</code>，我们可以观察到，打包后的js，css文件<code>数量</code>变多了，每个文件的体积也变小了，是因为使用<code>懒加载的组件</code>都被打包成<code>独立的</code>css，js文件了。这样，<code>index.html</code>引入的的<code>js</code>，<code>css</code>文件的体积也会变小，因为只包含<code>首屏组件</code>需要的<code>js，css</code>代码。</p></li><li><p><strong>从静态资源入手，减少加载时间</strong></p><ul><li><p><strong>缓存</strong>静态资源</p><p>对于已经请求过的资源，<strong>再次请求</strong>直接使用缓存。比如我们每天都要刷b站，可以观察到，B站的页面样式改变的频率是比较低的，如果我们每次登录b站，都要重新请求这些css样式文件，然后再解析渲染，就比较慢了，但是如果我们缓存这些css文件，下次就可以省去加载这些资源的时间，从而提高首屏加载速度。</p><p>再比如，对于首屏固定不变的图片，如果我们缓存了，下次也可以直接使用。</p></li><li><p><strong>压缩</strong>图片等静态资源的大小</p><p>这一点是显而易见的，压缩静态资源的大小，我们加载这些资源的时间就变少了，从而提高了首屏加载速度。我在部署自己的博客前，也会先把将要上传的图片，样式表，js文件，html文件等静态资源统一压缩，再上传，以求提高首屏加载速度。在实际开发过程中，这个功能通常是由webpack等模块化打包工具自动实现的。</p></li><li><p>内联首屏关键css</p><p>关于这一点，可以参考《前端面试—css》中的css性能优化部分。本质就是省去加载首屏关键css的时间。</p></li></ul></li><li><p>使用服务端渲染<strong>SSR</strong></p><p>将首页的html结构的拼接工作交给后端服务器，关于服务端渲染的介绍参考后文。</p><p>对于vue，推荐使用<code>nuxt.js</code></p></li></ul><h3 id="如何提高SPA的SEO"><a href="#如何提高SPA的SEO" class="headerlink" title="如何提高SPA的SEO"></a><strong>如何提高SPA的SEO</strong></h3><h4 id="服务端渲染SSR"><a href="#服务端渲染SSR" class="headerlink" title="服务端渲染SSR"></a>服务端渲染SSR</h4><p>指由<code>服务端</code>完成页面的 <code>HTML结构拼接</code>的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p><p>这意味着我们需要和服务器打交道</p><p>传统web开发，一般就是多页面应用程序，每个页面的html结构都在服务端拼接好。</p><p>单页面应用程序（SPA）通过<strong>浏览器执行js代码</strong>来实现页面的html结构的替换，拼接。</p><p><strong>有利于SPA的SEO</strong></p><p>使用服务端渲染，返回的页面就已经包含了一定的页面结构，能够被搜索引擎爬取。</p><p><strong>提高的首屏渲染速度</strong></p><p>使用服务端渲染，将<code>首屏结构</code>交给服务端来拼接，这样不必等待页面所有<code>js</code>加载完成，就可以看到首屏视图。</p><p>简单实现的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  &#123;&#123;&#123;metas&#125;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span></span></span><br><span class="line"><span class="tag">  &lt;!<span class="attr">--下面的注释</span>，<span class="attr">最终会被渲染好的模板内容替代</span>，<span class="attr">注意不能有空格--</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为是在服务端运行的代码，所以使用的是cjs语法</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vue</span> = <span class="built_in">require</span>(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> vueServerRenderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 以utf-8的格式，同步读取模板html文件，返回一个string</span></span><br><span class="line"><span class="keyword">const</span> template = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./index.html&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">// console.log(typeof template)</span></span><br><span class="line"><span class="comment">// 根据传入的html模板，创建一个renderer，渲染好的模板会本放入html模板的指定位置</span></span><br><span class="line"><span class="keyword">const</span> renderer = vueServerRenderer.<span class="title function_">createRenderer</span>(&#123;template&#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">      <span class="attr">url</span>:req.<span class="property">url</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&quot;&lt;div&gt;&#123;&#123;url&#125;&#125;&lt;/div&gt;&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//更多html模板配置参数</span></span><br><span class="line">  <span class="keyword">const</span> context = &#123;</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&#x27;Vue SSR&#x27;</span>,</span><br><span class="line">    <span class="attr">metas</span>:<span class="string">`&lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用renderer对象的renderToString方法</span></span><br><span class="line">  <span class="comment">//第一个参数传入vue实例，第二个参数传入模板html文件的更多配置参数，第三个参数传入一个渲染成功后触发的回调函数</span></span><br><span class="line">  <span class="comment">//回调函数的第一个参数是一个错误对象，第二个参数才是渲染好后的html字符串</span></span><br><span class="line">  renderer.<span class="title function_">renderToString</span>(vue, context ,<span class="function">(<span class="params">err,html</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="comment">//链式调用</span></span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">end</span>(<span class="string">&#x27;服务端错误&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.<span class="title function_">end</span>(html)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器开启成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="hash路由和history路由的实现原理，二者有什么区别？"><a href="#hash路由和history路由的实现原理，二者有什么区别？" class="headerlink" title="hash路由和history路由的实现原理，二者有什么区别？"></a>hash路由和history路由的实现原理，二者有什么区别？</h2><img src="..\images\前端面试-vue\前端路由.png" style="zoom:67%"><p><code>哈希路由</code>（Hash-based Routing）和 <code>History 路由</code>（History API-based Routing）是前端路由的两种常见实现方式，它们用于在单页面应用程序 (SPA) 中模拟多页面体验，而无需重新加载整个页面。</p><h3 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><ul><li><code>前端路由</code>被放到<code>url</code>的<code>hash</code>部分，即url中<code>#</code>后面的部分。</li><li><code>哈希值</code>改变也不会触发页面<code>重新加载</code>，但是会产生历史记录。</li><li>浏览器不会将<code>哈希值</code>发送到服务器，因此无论<code>哈希值</code>如何变化，刷新页面，服务器只会返回同一个初始 HTML 文件。</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul><li>不需要服务器配置支持，因为哈希值不会被发送给服务器。</li><li><code>兼容性好</code>，几乎所有浏览器都支持哈希变化事件。</li><li>URL 中包含显眼的 <code>#</code> 符号，可能影响美观。</li><li>前端路由部分十分明确，方便部署，可以部署在服务器的<code>任何位置</code>。</li></ul><h4 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a><strong>如何做</strong></h4><img src="..\images\前端面试-js\hash.png" style="zoom:67%"><p>可以直接设置 <code>window.location.hash</code> 属性来<code>改变</code> URL 中的哈希部分，改变 <code>window.location.hash</code> 不会触发<code>页面刷新</code>，但它会添加一个<code>新的历史记录条目</code>。</p><p>前端 JavaScript 监听 <code>hashchange</code> 事件来<code>检测</code>哈希的变化，并根据新的哈希值更新页面内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//存储当前的hash值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentHash</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">//存储路由</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;</span><br><span class="line">    <span class="comment">//页面初次加载的时候，获取当前路由，根据当前路由执行对应的回调函数</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//如果hash值为&quot;&quot; ，则修改hash值为 &#x27;/&#x27;，否则直接执行对应的回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentHash</span> = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">currentHash</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">currentHash</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//hash值改变了，及时更新this.currentHash</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentHash</span> = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//调用对应的回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">currentHash</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来根据当前hash路由，执行对应的回调函数</span></span><br><span class="line">  <span class="title function_">callback</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> callbackFunc = <span class="variable language_">this</span>.<span class="property">routes</span>[path]</span><br><span class="line">    <span class="keyword">if</span> (callbackFunc) &#123;</span><br><span class="line">      <span class="title function_">callbackFunc</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前hash路由没有注册对应的回调函数&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来注册路由，对应的回调函数--</span></span><br><span class="line">  <span class="title function_">route</span>(<span class="params">path, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修改当前页面的hash值，模拟路由跳转，这一操作会触发hashchange，然后就会执行对应的回调函数</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    location.<span class="property">hash</span> = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将创建的实例挂载到window上，成为全局变量</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">miniRouter</span> = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"><span class="comment">// 注册路由</span></span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;page1&#x27;</span>))</span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&#x27;/page2&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;page2&#x27;</span>))</span><br><span class="line"><span class="comment">// 模拟导航操作</span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>); <span class="comment">// 应该输出 &#x27;page1&#x27;</span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&#x27;/page2&#x27;</span>); <span class="comment">// 应该输出 &#x27;page2&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="history路由"><a href="#history路由" class="headerlink" title="history路由"></a>history路由</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><p>使用标准的路径形式，例如 <code>http://example.com/page1</code>，<code>前端路由</code>被放到<code>url</code>中的<code>资源路径</code>部分</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul><li><p>没有显眼的<code>#</code>号，更为美观</p></li><li><p>搜索引擎可以直接抓取完整 URL（如 <code>/about</code>），有利于 SEO 优化。</p></li><li><p>非常适合用来做服务端渲染，提高页面的SEO：History 路由的 URL 结构，与传统多页应用的URL结构一致，这意味着服务端可以为每个路由生成独立的html文件。</p></li><li><p>需要后端支持，否则会出现<code>404</code>问题，因为前端路由会被当作资源路径，发送到后端，而后端并未做对应配置。</p></li><li><p>对较老版本的浏览器兼容性较差，因为history路由是基于在H5才提出的History API</p></li><li><p>要求<code>index.html</code>文件引用资源的路径必须使用绝对路径</p><ul><li><p>因为基于History API，我们可以改变URL但是不实现页面跳转，展示的始终是同一个index.html文件。</p></li><li><p>但是当我们改变路由后（比如从<code>http://localhost:3000</code>变成<code>http://localhost:3000/it/about</code>），再手动刷新页面的时候，就会发送<code>get</code>请求<code>http://localhost:3000/it/about</code>到服务器(假设是开发服务器devServer)，</p></li><li><p>显然对于这个请求url，开发服务器找不到对应的资源，于是返回根目录(通常是public文件)下的<code>index.html</code>文件（歪打正着）</p></li><li><p>但是其他资源就没有这么好运了，浏览器拿到这个页面进行解析渲染，然后加载页面中的资源，比如css文件，如果我们使用的是相对路径，最终请求这些资源的请求路径，还会与当前页面url拼接，所以当前页面的url是不确定的，而我们资源的位置肯定是固定的，所以很容易找不到对应的资源，所以开发服务器返回<code>index.html</code>文件，你没看错，我们请求css文件结果服务端返回了html文件，然后浏览器就报错了。</p></li></ul></li><li><p>history路由的项目一般部署在<code>服务器根目录</code>，域名后面的路径就是<code>前端路径</code>，否则需要在<code>前端路由库</code>(比如VueRouter)中做额外配置，确保浏览器能从url中提取出前端路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;/app/&#x27;</span>, <span class="comment">// 设置基础路径</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 你的路由配置</span></span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如，如果用户的 URL 是 <code>http://example.com/app/user/profile</code>，那么前端路由库会将 <code>/user/profile</code> 视为<code>实际的路由路径</code>，而 <code>/app/</code> 则被视为基础路径。</p></li></ul><h4 id="如何做-1"><a href="#如何做-1" class="headerlink" title="如何做"></a><strong>如何做</strong></h4><img src="..\images\前端面试-js\history.png" style="zoom:67%"><p>使用 <code>HTML5</code> 的 History API (<code>history.pushState()</code> 和 <code>history.replaceState()</code>) 来<code>修改</code> URL，而不会触发页面刷新。</p><p>要注意的是，调用这2个api都不会触发<code>popstate</code>事件，只有在用户导航历史栈（通过浏览器的后退或前进按钮）时，才会触发 <code>popstate</code> 事件；而<code>hashchange</code>事件，无论是通过js修改hash，还是点击<code>前进后退</code>按钮修改hash，都会触发<code>hashchange</code>事件</p><p><strong>history.pushState(stateObj, title, url)</strong></p><ul><li><p><strong>功能</strong>：</p><ul><li><p>向浏览器的<code>历史栈</code>中添加一个新的记录，历史栈长度+1，</p></li><li><p>并更新<code>当前 URL</code>，但不重新加载页面。</p></li></ul></li><li><p><strong>参数</strong></p><ul><li><p><code>stateObj</code>: 一个对象，用于存储与该状态相关联的数据，可以通过 <code>popstate</code> 事件的事件对象event访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//console.log(e)</span></span><br><span class="line">      <span class="keyword">const</span> path = e.<span class="property">state</span> &amp;&amp; e.<span class="property">state</span>.<span class="property">path</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以通过<code>history.state</code>属性访问。</p></li><li><p><code>title</code>：通常被忽略或设为空字符串（大多数浏览器不支持）。</p></li><li><p><code>url</code>：新的 URL，可以是相对路径或绝对路径，<strong>但不能改变域名，否则会报错</strong>。</p></li></ul><img src="..\images\前端面试-js\a.png" style="zoom:90%"></li></ul><p><strong>history.replaceState(stateObj, title, url)</strong></p><ul><li><strong>功能</strong>：<ul><li>替换当前的历史记录条目，而不是添加新的条目。</li><li>它同样更新<code>当前 URL</code> 但不刷新页面。</li></ul></li><li><strong>参数</strong>：与 <code>pushState</code> 相同。</li></ul><p>监听 <code>popstate</code> 事件来响应浏览器的前进&#x2F;后退按钮操作。</p><p>最终代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//存储路由</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;;</span><br><span class="line">    <span class="comment">//页面初次加载的时候，修改路径为 &#x27;/&#x27;，并触发对应的事件回调</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      history.<span class="title function_">replaceState</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;, <span class="literal">null</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routes</span>[<span class="string">&#x27;/&#x27;</span>] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[<span class="string">&#x27;/&#x27;</span>]();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 监听popstate事件，也就是监听浏览器返回/前进按钮点击，然后触发对应的回调函数</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//这里是通过popstate的事件对象获取到了当前页面的状态（栈顶页面，或者说前进，回退操作后的页面）</span></span><br><span class="line">      <span class="comment">//其实还是可以通过location获得的吧，就是location.pathname</span></span><br><span class="line">      <span class="keyword">const</span> path = e.<span class="property">state</span>.<span class="property">path</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来注册路由</span></span><br><span class="line">  <span class="title function_">route</span>(<span class="params">path, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来修改路由</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    history.<span class="title function_">pushState</span>(&#123; path &#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="comment">//修改之后立马调用对应的回调函数，而不是等待触发popstate事件，因为不会触发</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Router  </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">miniRouter</span> = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"><span class="comment">//注册路由</span></span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;首页&#x27;</span>));</span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&#x27;/page2&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;page2&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转  </span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&#x27;/page2&#x27;</span>);  <span class="comment">// 输出 &#x27;page2&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="vue如何做前端性能优化"><a href="#vue如何做前端性能优化" class="headerlink" title="vue如何做前端性能优化"></a>vue如何做前端性能优化</h2><p>前端性能优化就包括了“如何提高首屏的加载速度”。</p><h3 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h3><ul><li>使用事件代理：使用事件委托能减少内存占用，减少不必要的重复代码。关于事件委托的介绍，可以参考<a href="https://www.sanye.blog/posts/aef189c3.html">前端面试—js部分 | 三叶的博客</a></li><li>使用keep-alive缓存组件：会缓存不活动的<strong>组件实例</strong>，而不是销毁它们，<strong>防止重复渲染DOM</strong>。</li><li>使用路由懒加载，本质是按需加载css，js文件</li><li>保证key值唯一，有利于diff算法复用dom，虽然key值不唯一也会提示，也不需要我们操心。</li></ul><h3 id="减少资源体积"><a href="#减少资源体积" class="headerlink" title="减少资源体积"></a>减少资源体积</h3><p>这部分的内容，其实主要是<code>模块化打包工具</code>帮助我们实现的，不需要我们操心。</p><ul><li>压缩css，js文件：使用打包工具比如webpack，vite压缩css，js文件（删除注释，空格，合并多个文件）</li><li>tree-shaking：使用tree-shaking移除未使用的代码，减少最终打包后的文件体积，虽然现在的打包工具都默认支持tree-shaking。</li><li>压缩图片体积：使用webp格式替代jpg或者png格式的图片，压缩图片体积。</li></ul><h3 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h3><ul><li>使用图片懒加载，我们可以手动实现图片懒加载指令</li><li>缓存图片，css，js文件等静态资源。在构建过程中，为静态资源文件名添加内容哈希值（例如 <code>app.a1b2c3d4.js</code>），这样每次更新文件时都会生成一个新的URL，浏览器会认为这是一个全新的资源而重新下载它，而不是使用缓存，这是也是打包工具会帮忙做的事情。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分析到现在，貌似需要我们控制的性能优化分案，貌似只有事件委托，使用keep-alive，使用路由懒加载 ，使用图片懒加载。</p><h2 id="如何解决给对象添加属性视图不刷新的问题"><a href="#如何解决给对象添加属性视图不刷新的问题" class="headerlink" title="如何解决给对象添加属性视图不刷新的问题"></a>如何解决给对象添加属性视图不刷新的问题</h2><p>我们从一个例子开始</p><p>定义一个<code>p</code>标签，通过<code>v-for</code>指令进行遍历</p><p>然后给<code>botton</code>标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in item&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addProperty&quot;</span>&gt;</span>动态添加新属性<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例化一个<code>vue</code>实例，定义<code>data</code>属性和<code>methods</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">   	<span class="attr">data</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       	<span class="attr">item</span>:&#123;</span><br><span class="line">            <span class="attr">oldProperty</span>:<span class="string">&quot;旧属性&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">addProperty</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">newProperty</span> = <span class="string">&quot;新属性&quot;</span>  <span class="comment">// 为items添加新属性</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">items</span>)  <span class="comment">// 输出带有newProperty的items</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击按钮，发现结果不及预期，数据虽然更新了（<code>console</code>打印出了新属性），但页面并没有更新</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>为什么产生上面的情况呢？下面来分析一下</p><p><code>vue2</code>是用过<code>Object.defineProperty</code>实现数据响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">let</span> val = obj.<span class="property">val</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;val&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get val:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set val:<span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">val</span> <span class="comment">//get val:0</span></span><br><span class="line">obj.<span class="property">val</span> = <span class="number">1</span> <span class="comment">//set val:1</span></span><br></pre></td></tr></table></figure><p>当我们访问<code>val</code>属性或者设置<code>foo</code>值的时候，都能够触发<code>setter</code>与<code>getter</code></p><p>但是我们为<code>obj</code>添加新属性的时候，却无法触发事件属性的拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">bar</span>  = <span class="string">&#x27;新属性&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>这是<code>Object.defineProperty</code>在设计上存在的问题，无法监听到对象属性的添加，删除，只能监听已有属性的getter和setter</strong></p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>可以通过**Vue.set()或者this.$set()**来给新增属性添加响应式。</p><p><code>Vue.set( target, key, value )</code></p><ul><li><code>target</code>：可以是一个对象，也可以是一个数组</li><li><code>key</code>：可以是一个字符串类型的属性，也可以是一个下标（数字）</li><li><code>value</code>：值可以是任意类型</li></ul><p>这个方法的本质就是<strong>使用Object.defineProperty()来添加一个新的响应式属性</strong>，因为直接给对象添加的属性，是不具备响应式的。</p><p>但是，我们只能监听已有属性的getter和setter，即便添加了一个响应式属性，也是无法监听到的，<strong>所以还需要通知所有依赖这个对象的Watcher(告诉它们，我新增一个属性啦)，触发视图更新。</strong></p><p>同样的，通过<code>Vue.delete()</code>和<code>this.$delete</code>来解决删除对象属性，视图不更新的问题。</p><h2 id="v-if和v-for的优先级是什么"><a href="#v-if和v-for的优先级是什么" class="headerlink" title="v-if和v-for的优先级是什么"></a>v-if和v-for的优先级是什么</h2><p>在vue2中，v-for的优先级高于v-if，也就是说会遍历所有元素，然后再通过<code>v-if</code>判断是否是要渲染，即使某些项最终不满足 <code>v-if</code> 条件，<code>v-for</code> 仍会遍历这些项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;item.isVisible&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">//这个例子中，Vue 2 首先遍历 `items` 数组（通过 `v-for`），然后对每个项应用 `v-if` 来决定是否渲染该项。</span><br></pre></td></tr></table></figure><p>而在vue3中，<code>v-if</code>的优先级高于<code>v-for</code>，所以在vue3中，上述代码会报错，会提示item未被定义；</p><p>这也意味着在vue3中，无法根据某个对象的属性，使用v-if来控制渲染。</p><p>其实最推荐的做法是只迭代并渲染需要渲染的数据，不在同一个元素上使用<code>v-if</code>和<code>v-for</code>，这就需要我们提前过滤元素。</p><h2 id="v-if和v-show如何理解"><a href="#v-if和v-show如何理解" class="headerlink" title="v-if和v-show如何理解"></a>v-if和v-show如何理解</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>二者都是用来控制页面中元素的显示与隐藏，当表达式值为<code>false</code>的时候，都不会占据页面的位置。</p><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p><code>v-show</code>本质是通过<code>切换css样式</code>来实现元素的显示与隐藏，令<code>display:none</code>让元素隐藏，dom元素还存在。</p><p><code>v-if</code>本质则是通过<code>控制dom元素的创建与删除</code>来实现元素的显示与隐藏，因为<code>v-if</code>直接操作<code>dom</code>，所以<code>v-if</code>有更高的性能消耗。</p><p><code>v-if</code>才是真正的<code>条件渲染</code>，<code>v-show</code>的值为<code>false</code>的元素，也会被渲染，因为它还是会出现在文档中，只是变得不可见且不占据位置。</p><h2 id="说说你对nextTick的理解"><a href="#说说你对nextTick的理解" class="headerlink" title="说说你对nextTick的理解"></a>说说你对nextTick的理解</h2><p>在vue中，虽然是数据驱动视图更新，但是数据改变（同步改变），vue异步操作dom来更新视图，而传入<code>nextTick</code>的回调函数，能确保在DOM更新之后再被执行，所以nextTick回调函数中能访问到最新的DOM。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><code>Vue.nextTick(()=&gt;&#123;&#125;)</code>或者<code>this.$nextTick(()=&gt;&#123;&#125;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;原始值&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用回调函数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;修改后的值&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;原始的值&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;修改后的值&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果调用nextTick的时候，没有传入回调函数，则会返回一个Promise对象，当这个Promise对象的值改变后，就能访问到最新的DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用async/await</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;修改后的值&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;原始的值&#x27;</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.$nextTick()<span class="comment">//此时没有传入回调函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;修改后的值&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []  <span class="comment">// 存放传入nextTick的回调函数</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>  <span class="comment">// 控制timerFunc的调用频率</span></span><br><span class="line"><span class="keyword">let</span> timerFunc  <span class="comment">//后续会被定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  <span class="comment">//将传入的回调函数，放入callbacks中</span></span><br><span class="line">  <span class="comment">//这个过程是同步发生的，但是callbacks中的函数被执行却是发生在微任务阶段</span></span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    <span class="comment">//如果是首次调用nextTick，再调用一次timerFunc</span></span><br><span class="line">    <span class="comment">//pending = true的意义是如果再调用nextTick，不再调用timerFunc</span></span><br><span class="line">    <span class="comment">//这意味着即便多次同步调用nextTick，只会在第一次调用的时候，将清空callback的任务，放入者微任务（或者宏任务）队列</span></span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()<span class="comment">//效果是将flushCallbacks放入微任务（或者宏任务）队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="comment">// 如果没传入回调函数，返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callbacks</code>新增回调函数后，又执行了<code>timerFunc</code>函数，那么这个<code>timerFunc</code>函数是做什么用的呢，我们继续来看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="comment">//判断1：是否原生支持Promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">//判断2：是否原生支持MutationObserver</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">//判断3：是否原生支持setImmediate</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//判断4：上面都不行，直接用setTimeout</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码描述了<code>timerFunc</code>的<strong>定义过程</strong>，做了四个判断，对当前环境进行不断的降级处理，尝试使用原生的<code>Promise.then</code>、<code>MutationObserver</code>和<code>setImmediate</code>，上述三个都不支持最后使用<code>setTimeout</code>。</p><p>通过四个判断可以确保，无论在何种浏览器条件下，都能定义出最合适<code>timerFunc</code>。而且四种情况下定义的<code>timerFunc</code>，<strong>效果都是，将<code>flushCallbacks</code>放入<code>微任务</code>（或者<code>宏任务</code>）队列</strong>。</p><p><code>timerFunc</code>不顾一切的要把<code>flushCallbacks</code>放入<code>微任务</code>或者<code>宏任务中</code>去执行，它究竟是何方神圣呢？让我们来一睹它的真容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//释放pending，确保下次事件循环同步调用nextTick的时候，能触发timerFunc</span></span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来以为有多复杂的<code>flushCallbacks</code>，居然不过短短的几行。它所做的事情也非常的简单，把callbacks数组复制一份，然后把callbacks置为空，最后把复制出来的数组中的每个函数依次执行一遍；<strong>所以它的作用仅仅是用来执行callbacks中的所有回调函数，</strong>也就是说，<strong>callbacks中的任务，会在微任务阶段（或者宏任务）被执行。</strong></p><h3 id="如何确保此时DOM是最新的？"><a href="#如何确保此时DOM是最新的？" class="headerlink" title="如何确保此时DOM是最新的？"></a>如何确保此时DOM是最新的？</h3><p>经过上面的介绍我们知道，传入nextTick的回调函数，通常会在<strong>微任务阶段</strong>被依次执行，那又是如何确保nextTick中的回调函数访问到的DOM是最新的DOM呢？</p><p>就如同<code>nextTick</code>中存在<code>callbacks</code>队列一样，在vue中修改数据，会触发对应的setter，然后将对应的更新操作，push到一个异步更新队列中（不同于callbacks），然后<code>负责清空这个异步更新队列的任务</code>，也会被放入微任务队列中，就如同清空<code>callbacks</code>的任务：<code>flushCallbacks</code>，会被<code>timeFunc</code>放入微任务队列中，不过由于清空这个异步更新队列的任务，先于<code>flushCallbacks</code>被执行，所以nextTick中的回调函数访问到的DOM是最新的DOM。下面用例子说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;我是测试文字&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">childName</span> = <span class="string">&#x27;我是子组件名字&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>同步调用，<code>this.msg = &#39;我是测试文字&#39;</code>，触发msg属性的setter，然后会开启一个异步更新队列，将依赖msg的所有<code>Watcher</code>放入异步更新队列，并将<code>清空异步更新队列的任务</code>，放入微任务队列中</p></li><li><p>同步调用，<code>this.$nextTick( ()=&gt;&#123; console.log(1) &#125; )</code>，将<code>()=&gt;&#123; console.log(1) &#125;</code>放入callbacks中，并且将flushCallbacks放入微任务中</p></li><li><p>同步调用，<code>this.childName = &#39;我是子组件名字&#39;</code>，触发childName属性的setter，将依赖childName的所有<code>Watcher</code>放入异步更新队列</p></li><li><p>同步调用<code>this.$nextTick(()=&gt;&#123; console.log(2) &#125;)</code>，将<code>()=&gt;&#123; console.log(2) &#125;</code>放入callbacks中。</p></li><li><p>同步任务执行完毕，开始执行微任务，执行清空异步更新队列的任务，更新DOM</p></li><li><p>从微任务中取出flushCallbacks执行，清空callbacks队列</p></li><li><p>为了确保<code>清空异步更新队列的任务</code>，先于<code>flushCallbacks</code>被放入微任务队列，需要先同步执行修改数据的操作</p></li></ul><h2 id="什么是虚拟DOM？有什么作用？如何实现？"><a href="#什么是虚拟DOM？有什么作用？如何实现？" class="headerlink" title="什么是虚拟DOM？有什么作用？如何实现？"></a><strong>什么是虚拟DOM？有什么作用？</strong>如何实现？</h2><h3 id="在js中的情况"><a href="#在js中的情况" class="headerlink" title="在js中的情况"></a>在js中的情况</h3><blockquote><p>这部分内容主要参考js中的事件循环，可参考本博客内的《javascript》一文</p></blockquote><p>在原生 JavaScript 的事件循环中，多次 DOM 操作会 <strong>立即修改内存中的 DOM 树</strong>，但浏览器通过 <strong>批量更新，合并机制，</strong> 延迟视图渲染至事件循环末尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一事件循环中多次修改同一元素的样式</span></span><br><span class="line">element.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;100px&quot;</span>;</span><br><span class="line">element.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;200px&quot;</span>;</span><br><span class="line">element.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>;</span><br></pre></td></tr></table></figure><p>浏览器会将这三次样式修改，合并为一次渲染流程，而非逐次触发三次重排，所以不会看到样式闪烁，因为只渲染了一次。</p><p>虽然减少了渲染次数，但每次 DOM 操作仍会 <strong>立即修改内存中的 DOM 树</strong>，频繁操作可能导致主线程阻塞（如复杂布局计算），因为操作DOM是费时的（比如一个DOM对象身上有很多属性，创建一个DOM是费时间的），所以在Vue等框架中，使用虚拟DOM和diff算法，来<strong>减少操作真实DOM的次数</strong>。</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>虚拟DOM（虚拟DOM树）本质就是一个用来<strong>描述真实DOM（真实DOM树）的js对象</strong>，是对真实DOM（真实DOM树）的<strong>高度抽象</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>hello world!!!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将上面的HTML模版抽象成虚拟DOM树：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">chidren</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">className</span>: <span class="string">&#x27;text&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">chidren</span>: [</span><br><span class="line">        <span class="string">&#x27;hello world!!!&#x27;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作虚拟 DOM 的速度，比直接操作真实 DOM <strong>快 10-100 倍</strong>。</p><h4 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a><strong>VNode</strong></h4><p>虚拟DOM树本身是一个js对象，是对真实DOM树的高度抽象，而VNode是虚拟DOM树上的结点，是对<code>真实DOM结点</code>的抽象，它描述了应该怎样去创建真实的DOM结点。</p><h4 id="创建虚拟DOM"><a href="#创建虚拟DOM" class="headerlink" title="创建虚拟DOM"></a><strong>创建虚拟DOM</strong></h4><p>在Vue 通过 <code>createElement</code> 函数（简写为 <code>h</code>，即 “hyperscript”）生成 <code>VNode</code> 树，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构。</p><p>一个典型的 <code>vnode</code> 对象可能包含以下字段：</p><ul><li><code>tag</code>: 元素类型（例如 <code>&#39;div&#39;</code>、<code>&#39;span&#39;</code> 等）</li><li><code>data</code>: 包含元素的属性、样式、事件处理器等元数据</li><li><code>children</code>: 子节点数组，可以是其他 <code>vnode</code> 或文本字符串</li><li><code>text</code>: 如果是文本节点，则包含文本内容</li><li><code>el</code>: 引用对应的真实DOM节点（仅在某些实现中存在）</li></ul><p>举例说明：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span></span><br><span class="line">  Hello Vue!</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>子节点<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Vue 的 render 函数和 createElement</span></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>, <span class="comment">// tag</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;container&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Div clicked&quot;</span>), <span class="comment">// 事件处理器</span></span><br><span class="line">  &#125;, <span class="comment">// data</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;Hello Vue! &quot;</span>, <span class="comment">// 文本节点</span></span><br><span class="line">    <span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;子节点&quot;</span>), <span class="comment">// 子 VNode</span></span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价的简化写法（Vue 2.5+ 使用 h 函数）：</span></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">h</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;container&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Div clicked&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="string">&quot;Hello Vue! &quot;</span>, <span class="title function_">h</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;子节点&quot;</span>)]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>生成的 <code>VNode</code> 结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;container&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Div clicked&quot;</span>) &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    <span class="string">&quot;Hello Vue! &quot;</span>, <span class="comment">// 文本节点（类型为字符串）</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">&quot;span&quot;</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">children</span>: [<span class="string">&quot;子节点&quot;</span>],</span><br><span class="line">      <span class="attr">text</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="attr">el</span>: <span class="literal">undefined</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">text</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="在Vue中的情况"><a href="#在Vue中的情况" class="headerlink" title="在Vue中的情况"></a>在Vue中的情况</h3><ul><li>在vue中，虽然是数据驱动视图更新的，当数据被修改时，会触发对应的 <code>setter</code>，但不会立即修改dom，而是通知依赖更新，调用所有依赖（Watcher）的update方法：将Watcher自身放入<strong>异步更新队列中</strong>。</li><li>然后在微任务阶段，清空异步更新队列：<ul><li>调用每个Watcher的<code>run</code>方法，要注意的是，虽然每个Key都可以有多个Watcher，但并不是所有Watcher都是<strong>渲染Watcher</strong>（负责组件的视图更新，每个组件对应一个渲染 Watcher），只有渲染 Watcher 的 <code>run</code> 方法触发 <code>render</code>，生成新虚拟 DOM → Diff → DOM 更新。</li><li>如果完全按照新的虚拟dom树，来创建新的dom树，就会有许多不必要的dom操作，所以我们会使用<strong>diff算法</strong>，进行新旧虚拟DOM树的比较，得出最小的变更，应用到对真实dom树的修改。</li></ul></li><li>综上所述，在vue中对真实DOM的修改，是在微任务阶段发生的，然后就到了事件循环的末尾，因为对DOM进行了修改，所以会进行一次渲染。</li></ul><h2 id="说说diff算法"><a href="#说说diff算法" class="headerlink" title="说说diff算法"></a>说说diff算法</h2><img src="..\images\前端面试-vue\dom操作优化.png" style="zoom:80%"><h3 id="具体复用方式"><a href="#具体复用方式" class="headerlink" title="具体复用方式"></a>具体复用方式</h3><ul><li><p>在大多数情况下，一个 HTML 标签对应一个 DOM（Document Object Model）元素。DOM元素本身也是一个js对象，不过身上的属性要多得多。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>&lt;div&gt;</code> 标签会被解析为一个 <code>HTMLElement</code> 对象，并且可以通过 JavaScript 访问它，例如使用 <code>document.getElementById(&#39;example&#39;)</code>。</p></li><li><p>如果父元素的虚拟 DOM 发生了变化，但其子元素的虚拟 DOM 没有变化，在大多数情况下，框架会尝试复用子元素的真实 DOM</p></li><li><p>当父元素保持不变，而其子元素发生了变化时，框架会对子树执行 diff 操作来确定哪些部分需要更新。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Initial Message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们修改子元素的内部文本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Updated Message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父元素 <code>&lt;div class=&quot;parent&quot;&gt;</code> 及其属性没有变化，子元素<code>&lt;div class=&quot;child&quot;&gt;</code> 的文本内容从 <code>&#39;Initial Message&#39;</code> 变为 <code>&#39;Updated Message&#39;</code>。由于父组件的虚拟 DOM 没有变化，父元素 <code>&lt;div class=&quot;parent&quot;&gt;</code> 不会被重新创建或替换，而是继续使用现有的真实 DOM 元素。</p></li><li><p>简单的来说，新旧虚拟dom的比较是结点级别的，只要某个结点的新旧虚拟dom未改变，就会复用这个dom结点</p></li></ul><h2 id="说说你对vue中key的理解"><a href="#说说你对vue中key的理解" class="headerlink" title="说说你对vue中key的理解"></a>说说你对vue中key的理解</h2><p>key是给每一个虚拟dom（或者说vnode）的唯一id。在diff过程中，根据key值，可以更<strong>准确</strong>， 更快的找到待比较的虚拟dom，从而优化diff算法，提高dom的复用率。</p><p>如果不设置key，那key值默认就都是undefined，将会按顺序进行<strong>新旧虚拟dom</strong>的比较。</p><p>详细可参考禹神的vue视频：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=00483a04a5a69136669373a8ea522a9b&p=30">030_尚硅谷Vue技术_key作用与原理_哔哩哔哩_bilibili</a></p><h2 id="说说你对keep-alive的理解"><a href="#说说你对keep-alive的理解" class="headerlink" title="说说你对keep-alive的理解"></a>说说你对keep-alive的理解</h2><p>keep-alive是<strong>vue中的内置组件</strong>，包裹动态组件（router-view）时，会缓存不活动的<strong>组件实例</strong>，而不是销毁它们，<strong>防止重复渲染DOM</strong>。</p><p>被缓存的组件会额外多出两个生命周期<code>activated</code>和<code>deactivated</code></p><p>keep-alive可以使用一些<code>属性</code>，来更精细的控制组件缓存。</p><ul><li><code>include</code> - 字符串或正则表达式或者一个数组。只有名称匹配的组件<strong>会</strong>被缓存</li><li><code>exclude</code> - 字符串或正则表达式或者一个数组。任何名称匹配的组件都<strong>不会</strong>被缓存</li><li><code>max</code> - 数字：最多可以缓存多少个组件实例，超出这个数字之后，则<strong>删除第一个</strong>被缓存的组件，由此可以推测存在一个缓存队列，先入先出。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 `v-bind`,动态绑定，表示传入的是正则表达式，而不是字符串) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 (使用 `v-bind，动态绑定，表示传入的是表达式`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>组件名称匹配，组件名称指的到底是什么呢？</strong></p><p>匹配首先检查<strong>组件自身的</strong> <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的<strong>局部注册名称</strong> (父组件 <code>components</code> 选项的<strong>键值</strong>)，匿名组件不能被匹配。</p><p><strong>组件被缓存了，如何获取数据呢？</strong></p><p>借助<code>beforeRouteEnter</code>这个<code>组件内的导航守卫</code>，或者<code>activated</code>生命周期函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">vm</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(vm)</span><br><span class="line">        <span class="comment">// 每次进入路由执行</span></span><br><span class="line">        vm.<span class="title function_">getData</span>()  <span class="comment">// 获取数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">activated</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getData</span>() <span class="comment">// 获取数据</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/keepalive.html#%E4%B8%80%E3%80%81keep-alive-%E6%98%AF%E4%BB%80%E4%B9%88">面试官：说说你对keep-alive的理解是什么？ | web前端面试 - 面试官系列</a>这篇文章中还讲解了keep-alive的实现原理，看起来还是挺复杂的</p></blockquote><p><strong>vue3中的keep-alive的语法不同于vue2</strong></p><p>基础用法，默认缓存所有页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span>//Component可以理解为用来替代router-view的组件,或者说当前活跃的组件</span><br><span class="line">  //keep-alive包裹的不再是router-view而是具体的组件</span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span>//会缓存传入的组件</span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>精确控制具体哪些组件缓存，因为再vue3中使用组件已经不再需要注册，也不需要给组件命名，所以我们控制组件（页面）缓存的依据变成了<strong>页面的路由对象</strong>，而不是组件的名称。同时，我们不再通过给keep-alive标签添加属性来控制哪些组件该被缓存，缓存多少组件，转变为借助<code>v-if</code>，如果某个组件因该被缓存，那么他就会被<code>keep-alive</code>标签包裹。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span>//Component是当前活跃的组件，或者说当前展示的组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span>  <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>/&gt;</span>//获取当前组件对应的路由信息</span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在路由对象中添加meta属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&quot;/keepAliveTest&quot;</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;keepAliveTest&quot;</span>,</span><br><span class="line">   <span class="attr">meta</span>: &#123;</span><br><span class="line">       <span class="attr">keepAlive</span>: <span class="literal">true</span> <span class="comment">//设置页面是否需要使用缓存</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/keepAliveTest/index.vue&quot;</span>)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是就到此位置的话，切换页面的时候会报错：<code>vue3 TypeError: parentComponent.ctx.deactivate is not a function 报错</code></p><p>网上提供的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/zhouning7879/article/details/130639409">解决方案</a>就是给每个component提供一个key。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;route.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;route.meta.isKeepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;route.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.isKeepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>详细可参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6978772143748153381">vue3中使用keep-alive目的：掘金</a></p><h2 id="说说vue中的Mixin"><a href="#说说vue中的Mixin" class="headerlink" title="说说vue中的Mixin"></a>说说vue中的Mixin</h2><p>mixin本质就是一个<strong>js对象</strong>，包含了vue组件<strong>任意功能选项</strong>，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等</p><p>，被用来<strong>分发</strong> <code>Vue</code> 组件中的<strong>可复用功能</strong>。</p><p>可分<strong>为全局混入和局部混入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全局混入&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)<span class="comment">//全局混入</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">mixins</span>:[&#123;<span class="attr">created</span>:<span class="function">()=&gt;</span>&#123;&#125;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果混入组件的时候出现了<strong>功能选项冲突</strong>，一般以组件功能选项为准。</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/mixin.html#%E4%B8%80%E3%80%81mixin%E6%98%AF%E4%BB%80%E4%B9%88">面试官：说说你对vue的mixin的理解，有什么应用场景？ | web前端面试 - 面试官系列</a></p><p>在<strong>vue3</strong>的组合式api中，混入（mixin）显然就没有用武之地了，转而被<code>composable</code>替代，下面就是一个例子，介绍了在vue3中是如何复用代码的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//useCountDown.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&#x27;dayjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">countDown</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Time</span> = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> formatTime = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> dayjs.<span class="title function_">unix</span>(<span class="title class_">Time</span>.<span class="property">value</span>).<span class="title function_">format</span>(<span class="string">&#x27;mm分ss秒&#x27;</span>))</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params">time</span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">Time</span>.<span class="property">value</span> = time</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Time</span>.<span class="property">value</span>--</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Time</span>.<span class="property">value</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(n)</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;订单超时&#x27;</span>)</span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">&#x27;/cartList&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; formatTime, start &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好理解啊，就像大多数编程语言一样，把能实现部分功能的代码<strong>封装成一个函数</strong>，需要的时候再导入这个函数，调用这个函数，和把这些代码直接写在组件中相比，区别只于私有化了变量，需要通过return导出。</p><h2 id="跨域是什么？Vue项目中你是如何解决跨域的呢？"><a href="#跨域是什么？Vue项目中你是如何解决跨域的呢？" class="headerlink" title="跨域是什么？Vue项目中你是如何解决跨域的呢？"></a>跨域是什么？Vue项目中你是如何解决跨域的呢？</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p><strong>跨域</strong>本质是<code>浏览器</code>基于<strong>同源策略</strong>的一种<code>安全手段</code>，它是<strong>浏览器</strong>最核心也最基本的安全功能，服务器间通信不会有跨域的问题。</p><p>所谓同源（即指在同一个域）具有以下三个相同点</p><ul><li>协议相同（protocol）</li><li>主机相同（host）</li><li>端口相同（port）</li></ul><p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域(非同源产生跨域)</p><p>举个例子，我们直接打开 HTML 文件使用的是<code>file:///</code>协议加载，如果文档内部请求了其他<code>网络资源</code>，因为HTTP 请求使用的是 <code>http://</code> 或 <code>https://</code> 协议，协议不同，就发生了跨域。</p><p>和<strong>跨站</strong>有什么区别呢？跨站不涉及协议和端口号，<strong>一般情况下，跨站指的就是主域名不同</strong>，比如<code>www.bilibili.com</code>和<code>game.bilibili.com</code>属于同站。</p><h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li>JSONP</li><li>CORS</li><li>Proxy</li></ul><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><strong>JSONP</strong></h4><ul><li><p>利用了<code>script</code>标签可以<strong>跨域加载脚本</strong></p></li><li><p>动态创建一个script标签，并自定它的src属性为目标服务器的url</p></li><li><p>这个url通常包含一个查询参数，用于指定<strong>客户端上的回调函数名</strong></p></li><li><p>服务端接收到请求后，返回<strong>包含函数调用的js代码</strong>，其中传入函数的参数，就是服务器传递的参数。</p></li><li><p>但jsonp请求有个明显的缺点：只能发送<code>get</code>请求</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">      script.<span class="property">src</span> = <span class="string">&quot;http://127.0.0.1:8081/api/callback?callback=hello&quot;</span></span><br><span class="line">      <span class="comment">//给script标签对象添加监听事件</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">      <span class="comment">//比addEventListener写法简单</span></span><br><span class="line">      <span class="comment">//原始事件监听模型</span></span><br><span class="line">      script.<span class="property">onload</span> = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        script.<span class="title function_">remove</span>()<span class="comment">//调用remove方法删除这个标签</span></span><br><span class="line">      &#125;<span class="comment">//脚本加载后立马删除，监听*onload*事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;onClick()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实还有其他标签可以跨域加载资源，貌似大部分标签都可以跨域加载资源…</p><p><strong>媒体资源</strong></p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>img标签</td><td>可以跨域加载图像资源，但是如果给img标签加上crossorigin属性，那么就会以跨域的方式请求图片资源</td></tr><tr><td>audio和video标签</td><td>可以跨域加载视频，音频</td></tr></tbody></table><p><strong>前端基础三大文件</strong></p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>link标签</td><td>可以跨域加载CSS文件</td></tr><tr><td>iframe标签</td><td>可以跨域加载HTML页面。</td></tr><tr><td>script标签</td><td>可以跨域加载脚本</td></tr></tbody></table><p><strong>crossorigin属性</strong></p><p>虽然上述三大标签默认可以跨域加载资源，但是如果添加了<code>crossorigin</code>属性，情况就不同了，此时加载资源同样受同源策略限制，请求这这些资源的时候，会携带<code>Origin</code>头，并且要求响应头中包含<code>Access-Control-Allow-Origin</code>字段。</p><p>尽管 <code>&lt;script&gt;</code> 默认允许跨域加载，但 <code>crossorigin</code> 属性的<strong>核心意义</strong>在于：</p><ol><li><p><strong>调试需求</strong>：前端可以获取跨域脚本的详细错误日志（开发阶段尤其关键）</p></li><li><p><strong>安全增强</strong>：强制验证服务器是否明确允许当前来源（避免滥用第三方资源）。</p></li><li><p>特殊资源要求，例如：</p><ul><li><p><strong>字体文件</strong>：通过 <code>&lt;link&gt;</code> 加载的跨域字体必须使用 <code>crossorigin</code>。</p></li><li><p><strong>ES6 模块</strong>：<code>&lt;script type=&quot;module&quot;&gt;</code> 加载的模块必须启用 CORS，所以说vue3项目打包后，引入js文件的方式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;/assets/index-RPTkaswq.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认添加了<code>crossorigin</code>头。</p></li></ul></li></ol><table><thead><tr><th align="center"><strong>行为</strong></th><th align="center">不加 <code>crossorigin</code></th><th align="center">加 <code>crossorigin</code></th></tr></thead><tbody><tr><td align="center">是否允许跨域加载</td><td align="center">✅ 允许</td><td align="center">✅ 允许（需服务器支持 CORS）</td></tr><tr><td align="center">是否验证 CORS 头</td><td align="center">❌ 不验证</td><td align="center">✅ 必须验证</td></tr><tr><td align="center">错误信息详情</td><td align="center">❌ 仅 <code>Script error.</code>跨域脚本可能包含敏感逻辑或数据，因此浏览器不会将详细的错误信息暴露给非同源页面</td><td align="center">✅ 完整错误信息（需 CORS 允许）</td></tr><tr><td align="center">适用场景</td><td align="center">不关心错误细节的公共库</td><td align="center">需调试或加载字体&#x2F;模块等特殊资源</td></tr></tbody></table><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><strong>Proxy</strong></h4><p>代理（Proxy）也称<code>网络代理</code>，是一种特殊的<code>网络服务</code>，允许一个（一般为客户端）通过<code>代理</code>与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p><p>代理的方式也可以有多种：</p><ul><li><p><strong>在脚手架中配置</strong></p><p>在开发过程中，我们可以在<code>脚手架</code>中配置代理。我们可以通过<code>webpack（或者vite）</code>为我们开起一个<code>本地服务器</code>(devServer，域名一般是<code>localhost:8080</code>)，作为请求的<code>代理服务器</code>，所以说，这个本地服务器不仅能<code>部署</code>我们<code>开发打包</code>的资源，还能起到<code>代理</code>作用。</p><p>通过该服务器<code>转发</code>请求至目标服务器，本地代理服务器得到结果再转发给前端，因为服务器之间通信不存在跨域问题，所以能解决跨域问题。</p><p>打包之后的项目文件，因为脱离了代理服务器，所以说这种方式只能在<code>开发环境</code>使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue.config.js 即vue-cli脚手架（基于webpack）开发的vue项目</span></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">   <span class="comment">//感觉这些信息都是在告诉代理服务器该怎么做</span></span><br><span class="line">   <span class="attr">proxy</span>: &#123;</span><br><span class="line">     <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以/api开头的请求路径</span></span><br><span class="line">       <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 告诉代理服务器要请求的目标服务器地址</span></span><br><span class="line">       <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//改变代理服务器请求目标服务器时的host，代理服务器修改host为目标服务器的域名+端口</span></span><br><span class="line">       <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 告诉代理服务器，重写路径，移除前缀</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vite.config.js 即vue-create脚手架（基于vite）开发的vue项目</span></span><br><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以/api开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 目标服务器地址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//改变代理服务器请求目标服务器时的host，代理服务器修改host为目标服务器的域名</span></span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>), <span class="comment">// 重写路径，移除前缀</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\跨域.png" style="zoom:85%"><p>可以看到，我们要使用代理，在编写接口时，就不能书写完整的路径，比如就不能直接把请求url写成<code>https://www.sanye.blog/books</code>，这样必然跨域，我们应该把请求写为<code>/books</code>，部署到本地服务器后加载网页，发起这个请求前，会先自动与<code>域名</code>拼接，实际的请求就变为<code>http://localhost:8080/books</code>，这样就没跨域，不过确实，这么操作的话，就是在请求本地服务器中的<code>books</code>资源，而不是目标服务器中的，如果我们本地服务器中有这个资源（vue-cli中是public目录下有books文件，无后缀），那么本地服务器就会把这个资源返回给浏览器，<strong>无论我们是否开启了代理</strong>，所以我们实际还要添加<code>/api</code>类似的多余的前缀，确保我们访问的<code>不是</code>本地服务器中的资源，然后本地服务器会帮我们按照配置的规则进行<code>路径重写</code>，得到正确的请求URL，再向目标服务器请求资源。</p></li><li><p><strong>在服务端开启代理</strong></p><p>其实也不是打包后就不能通过代理来解决跨域问题，如果我们把<code>打包后的前端资源</code>部署到<code>本地的服务器</code>，比如使用基于<code>node.js</code>的<code>express</code>框架搭建的<code>本地服务器</code>，我们也可以通过配置代理来解决跨域问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>( <span class="string">&#x27;express &#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//其实webpack-dev-server开启代理功能的核心也是这个中间件</span></span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>( <span class="string">&#x27;http-proxy-middleware &#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>( . /public)）<span class="comment">//引入静态资源</span></span><br><span class="line">app.<span class="title function_">use</span>( <span class="string">&#x27;/api&#x27;</span> ,<span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line">	<span class="attr">target</span>: <span class="string">&#x27; https:// www.toutiao.com&#x27;</span>,</span><br><span class="line">	<span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">	<span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">		<span class="string">&#x27;^/api &#x27;</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>总之想要配置代理，就离不开一台允许你配置代理的<code>服务器</code>，把打包后的前端资源托管到<code>其他平台</code>，我们也无法来配置代理，也就无法解决跨域问题。</p></li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>CORS （Cross-Origin Resource Sharing），即跨域资源共享，意思就是虽然你在跨域请求我的资源，但是我还是<code>选择性的</code>共享资源给你，浏览器根据<code>响应头</code>中的<code>特定字段</code>，来决定是否拦截<code>跨域请求</code>返回的数据。</p><p>因为需要在<code>响应头</code>上做文章，所以这个工作主要是前后端协调后，由后端负责，至于前后端如何协调，参考<code>简单请求</code>和<code>复杂请求</code>部分。</p><h2 id="如何理解简单请求和复杂请求"><a href="#如何理解简单请求和复杂请求" class="headerlink" title="如何理解简单请求和复杂请求"></a>如何理解简单请求和复杂请求</h2><p>区别二者的关键，就在于<code>请求方法</code>和<code>请求头</code>，简单请求是在请求方法和请求头上，都有严格要求的请求，违背任何一条要求，都将变为复杂请求。</p><table><thead><tr><th></th><th>简单请求</th><th>复杂请求</th></tr></thead><tbody><tr><td>请求方法(携带在请求行中)</td><td>get，post，head</td><td>除get，post，head外的请求方法</td></tr><tr><td>请求头</td><td>满足cors安全规范（一般不修改请求头就是安全的）<code>Content-Type</code> 的值仅限于以下三种之一： <code>application/x-www-form-urlencoded</code> <code>multipart/form-data</code> <code>text/plain</code>，且未自定义其他请求头</td><td>设置了自定义的请求头，或者 <code>Content-Type</code> 的值不是上述三种之一</td></tr></tbody></table><p>在非跨域情况下，区分二者并没有什么意义，但是在跨域情况下，发送复杂请求前，会先发送一次<code>预检请求</code>，请求方法为<code>options</code>，</p><p>在请求头中携带<code>Origin</code>，<code>Access-Control-Request-Method</code>，<code>Access-Control-Request-Headers</code>字段，询问服务器是否接受来自xxx源，请求方法为xxx，请求头为xxx的<code>跨域复杂请求</code>，如果接受，才发送这样的<code>复杂请求</code>。</p><img src="..\images\前端面试-vue\options.jpg" style="zoom:80%"><p>服务端处理代码（以express框架为例）S</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">options</span>( <span class="string">&#x27;/students &#x27;</span>,<span class="function">(<span class="params"> req,res</span>)=&gt;</span>&#123;</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> , <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>)</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods &#x27;</span> , <span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers &#x27;</span> ,<span class="string">&#x27;school&#x27;</span>）</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Max-Age &#x27;</span> , <span class="number">7200</span>)<span class="comment">//告诉浏览器在7200s内不要再发送预检请求询问</span></span><br><span class="line">	res.<span class="title function_">send</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样处理起来明显比较繁琐，实际上我们借助<code>CORS中间件</code>就能统一处理<code>简单请求和复杂请求（包括预检请求）</code>的跨域问题。</p><p><strong>head请求</strong></p><p>HTTP请求方法 <code>HEAD</code> ，是一种用于请求资源元信息的请求方法，它与 <code>GET</code> 请求类似，但有一个关键的区别：服务器在响应中不会返回消息体（即实际的内容），只返回头部信息（Headers）。这意味着当你发送一个 <code>HEAD</code> 请求时，你只会收到关于该资源的元数据，例如内容类型、大小、最后修改时间等，而不会收到文档的实际内容。</p><p>使用场景</p><ul><li><strong>检查资源的状态</strong>：可以用来检查资源是否存在、获取资源的最新修改时间或其他头部信息，而不必下载整个资源。</li><li><strong>测试链接的有效性</strong>：在不加载整个页面或资源的情况下，验证URL的有效性和可访问性。</li><li><strong>性能优化</strong>：在需要了解文件大小以准备接收之前，可以通过 <code>HEAD</code> 请求先获取文件的大小信息。这在处理大文件下载前特别有用，因为它允许客户端决定是否继续下载。</li><li><strong>缓存验证</strong>：可以用来检查本地缓存的副本是否仍然有效，通过比较缓存中的头部信息和服务器返回的头部信息。</li></ul><h2 id="vue项目如何部署？有遇到布署服务器后刷新404问题吗"><a href="#vue项目如何部署？有遇到布署服务器后刷新404问题吗" class="headerlink" title="vue项目如何部署？有遇到布署服务器后刷新404问题吗"></a>vue项目如何部署？有遇到布署服务器后刷新404问题吗</h2><h3 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h3><p>前后端分离开发模式下，前后端是<code>独立布署</code>的，前端只需要将最后的构建物上传至目标服务器的<code>web</code>容器指定的<code>静态目录</code>下即可，我们知道<code>vue</code>项目在构建打包后，是生成一系列的静态文件。</p><h3 id="404问题"><a href="#404问题" class="headerlink" title="404问题"></a>404问题</h3><p>HTTP 404 错误意味着链接指向的资源不存在，问题在于为什么不存在？且为什么只有<code>history</code>模式下会出现这个问题，而hash模式下不会有?</p><p>history模式，刷新页面，<code>前端路由部分</code>会被当作<code>请求URL</code>的一部分发送给服务器，然而服务器<code>并没有相关配置</code>，所以<code>响应404</code>。</p><p>而hash模式，前端路由在URL的<code>#</code>后面，不会被当作请求URL的一部分。</p><p>要解决使用history路由的项目，刷新页面出现的404问题，必须和<code>后端</code>沟通，当请求的页面不存在时，返回<code>index.html</code>，把页面控制权全交给<code>前端路由</code>。</p><p>但是这样有个问题，就是后端服务器不会再响应<code>404</code>错误了，当找不到请求的资源总是会返回index.html，即便请求的资源在前后端中都不存在（即把页面控制权交给前端路由，也没有对应的页面），所以为了避免这种情况，应该在 Vue应用里面<code>覆盖所有的路由情况</code>，最后给出一个 <code>404 页面</code>(虽然说是404页面，但是响应状态码是200，因为返回了<code>index.html</code>)</p><h3 id="直接打开页面空白问题"><a href="#直接打开页面空白问题" class="headerlink" title="直接打开页面空白问题"></a>直接打开页面空白问题</h3><p>直接打开页面，页面空白本质就是因为<strong>js文件加载失败</strong></p><p>因为我们开发的是单页面应用程序，需要借助js操作dom来更新页面，而本身的html文件中并没有任何结构，所以如果js文件加载失败，页面就不会有任何结构，所以显示空白。</p><p>那为什么js文件会加载失败呢，原因分为两种，<strong>一种是加载js文件的路径错误</strong>，这通常出现在使用绝对资源路径的情况（使用history路由），为了得到最终的路径还会和盘符（C:或者D:）拼接，所以找不到资源。</p><p>还有一种是请求资源的时候<strong>跨域</strong>了，为什么会跨域了，我们加载的不是本地的js文件文件吗？确实，加载本地资源出现跨域，导致资源加载失败的问题，只会出现在vue3项目中，而vue2项目中不会有这个问题，为什么呢？vue3默认使用<code>vite</code>构建工具，打包后会生成基于<code>esm</code>的代码，<strong>浏览器在<code>file://</code>协议下加载<code>esm</code>时，会触更严格的跨域安全策略</strong>，导致本地的css，js文件也被视为<code>跨域资源</code>，所以资源加载失败</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以观察到这个模块的type=&#x27;module&#x27;，这意味着这个js文件内使用了esm语法（比如import），这个js文件成为了esm--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;/assets/index-RPTkaswq.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而vue2项目通常使用<code>webpack</code>打包，生成的代码通常以<code>传统脚本</code>的形式加载，此时浏览器对<code>file://</code>协议的跨域闲置比较宽松。</p><h2 id="说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢-？"><a href="#说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢-？" class="headerlink" title="说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢 ？"></a>说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢 ？</h2><p>在划分项目结构的时候，需要遵循一些基本的原则：</p><ul><li>文件夹和文件夹内部文件的语义一致性</li><li>单一入口&#x2F;出口</li><li>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</li><li>公共的文件应该以绝对路径的方式从根目录引用</li><li><code>/src</code> 外的文件不应该被引入</li></ul><p><strong>文件夹和文件夹内部文件的语义一致性</strong></p><p>我们的目录结构都会有一个文件夹是按照<code>路由模块</code>来划分的，如<code>pages</code>文件夹，这个文件夹里面应该包含我们项目所有的路由模块，并且<code>仅</code>应该包含路由模块，而不应该有别的其他的非路由模块的文件夹</p><p>这样做的好处在于一眼就从 <code>pages</code>文件夹看出这个项目的路由有哪些</p><p><strong>单一入口&#x2F;出口</strong></p><p>举个例子，在<code>pages</code>文件夹里面存在一个<code>seller</code>文件夹，这时候<code>seller</code> 文件夹应该作为一个独立的模块由外部引入，并且 <code>seller/index.js</code> 应该作为外部引入 seller 模块的唯一入口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误用法</span><br><span class="line">import sellerReducer from &#x27;src/pages/seller/reducer&#x27;//可以是reducer，就可以是其他，这样出口就不唯一。</span><br><span class="line"></span><br><span class="line">// 正确用法</span><br><span class="line">import &#123; reducer as sellerReducer &#125; from &#x27;src/pages/seller&#x27;//默认引入seller目录下的index.js文件</span><br></pre></td></tr></table></figure><p><strong>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</strong></p><p>使用<code>相对路径</code>可以保证模块内部的独立性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 正确用法</span><br><span class="line">import styles from &#x27;./index.module.scss&#x27;</span><br><span class="line">// 错误用法</span><br><span class="line">import styles from &#x27;src/pages/seller/index.module.scss&#x27;</span><br></pre></td></tr></table></figure><p>举个例子</p><p>假设我们现在的 seller 目录是在 <code>src/pages/seller</code>，如果我们后续发生了路由变更，需要加一个层级，变成 <code>src/pages/user/seller</code>。</p><p>如果我们采用第一种相对路径的方式，那就可以直接将整个文件夹拖过去就好，<code>seller</code> 文件夹内部不需要做任何变更。</p><p>但是如果我们采用第二种绝对路径的方式，移动文件夹的同时，还需要对每个 <code>import</code> 的路径做修改</p><p>总之就是要体会到相对路径的好处，移动文件也不需要修改路径，只要相对位置没变就好。</p><p><strong>&#x2F;src 外的文件不应该被引入</strong></p><p><code>vue-cli</code>脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个<code>src</code>文件夹，里面放着所有的项目需要的资源，<code>js</code>, <code>css</code>, <code>png</code>, <code>svg</code> 等等。<code>src</code> 外会放一些项目配置，依赖，环境等文件</p><p>这样的好处是方便划分项目代码文件和配置文件</p><h2 id="Vue如何做权限管理"><a href="#Vue如何做权限管理" class="headerlink" title="Vue如何做权限管理"></a>Vue如何做权限管理</h2><p>权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源</p><p>而前端权限归根结底是<code>请求的发起权</code>，请求的发起可能有下面两种形式触发</p><ul><li>页面加载触发</li><li>页面上的按钮点击触发</li></ul><h3 id="如何做-2"><a href="#如何做-2" class="headerlink" title="如何做"></a>如何做</h3><p>前端权限控制可以分为四个方面：</p><ul><li>接口权限</li><li>按钮权限</li><li>菜单权限</li><li>路由权限</li></ul><p><strong>接口权限</strong></p><p>接口权限目前一般采用<code>jwt</code>的形式来验证，没有通过的话一般返回<code>401</code>（用户不存在），跳转到登录页面重新进行登录</p><p>登录完拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，每次请求的时候头部携带<code>token</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">    config.headers[&#x27;token&#x27;] = cookie.get(&#x27;token&#x27;)</span><br><span class="line">    return config</span><br><span class="line">&#125;)</span><br><span class="line">axios.interceptors.response.use(res=&gt;&#123;&#125;,&#123;response&#125;=&gt;&#123;</span><br><span class="line">    if (response.data.code === 40099 || response.data.code === 40098) &#123; //token过期或者错误</span><br><span class="line">        router.push(&#x27;/login&#x27;)//路由跳转</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="Vue2与Vue3有什么不同"><a href="#Vue2与Vue3有什么不同" class="headerlink" title="Vue2与Vue3有什么不同"></a>Vue2与Vue3有什么不同</h2><ul><li><p><strong>响应式实现方法不同</strong>：vue2的响应式是基于<code>Object.defineProperty</code>实现的，而在vue3中，响应式是基于Proxy实现的</p></li><li><p><strong>api风格不同</strong>：在vue2使用的是选项式api，在vue3中既可以使用组合式api，又可以使用选项式api。</p></li><li><p><strong>组件注册方式不同</strong>：Vue3导入组件后，也不需要在components里注册</p></li><li><p><strong>模板语法不同</strong>：Vue2中模板里只能有一个根标签，而在Vue3里可以有多个，因为这些根标签都会被<code>fragment</code>标签包裹</p></li></ul><h2 id="Vue3做了哪些优化？"><a href="#Vue3做了哪些优化？" class="headerlink" title="Vue3做了哪些优化？"></a>Vue3做了哪些优化？</h2><p>这是一个很大的话题，这里只做<code>简要介绍</code>，后续对每个部分都有<code>详细解释</code>。</p><ul><li><p>更小</p><p>Vue2本身不支持tree-shaking，Vue 2 的核心库和其插件或附加功能（如路由管理、状态管理等）通常是作为一个整体提供的，而不是作为独立可选模块。这意味着即使你的应用只使用了 Vue 的一小部分功能，整个 Vue 库也会被打包进去。</p><p>Vue3移除了一些不常用的 API，引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使<strong>打包的整体体积变小了</strong>。</p></li><li><p>更快</p><p>主要体现在编译方面：diff算法优化，静态提升，事件监听缓存，SSR优化</p></li><li><p>更友好</p><p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时，还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力。</p></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码可以从两个层面展开：</p><ul><li><p>源码管理</p><p><code>vue3</code>整个源码是通过 <code>monorepo</code>的方式维护的，根据功能将不同的模块拆分到<code>packages</code>目录下面不同的子目录中</p><p>这样使得<code>模块拆分</code>更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。</p></li><li><p>TypeScript</p><p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推断 。</p></li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul><li><p>体积优化（支持tree-shaking），编译优化</p></li><li><p>数据劫持优化：在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty</code>，这个 API 有一些缺陷，<strong>并不能检测对象属性的添加和删除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>尽管<code>Vue</code>为了解决这个问题提供了 <code>set</code>和<code>delete</code>实例方法，但是对于用户来，还是增加了一定的心智负担。</p><p>相比之下，<code>vue3</code>是通过<code>proxy</code><strong>监听整个对象</strong>，而不是监听属性，那么无论是删除对象属性，还是给对象添加属性，当然也能监听到。同时<code>Proxy</code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归添加响应式。</p></li></ul><h3 id="语法API"><a href="#语法API" class="headerlink" title="语法API"></a>语法API</h3><p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p><ul><li>优化逻辑组织</li><li>优化逻辑复用</li></ul><p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能复用，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：<code>命名冲突</code>和<code>数据来源不清晰</code>，</p><p>比如有2个提供了若干组件功能的js文件，它们在同一个组件内被混入，但是它们都提供了一个名为useMouse的方法，这个时候就产生了<strong>冲突</strong>，不知道以哪个函数为主；当在一个组件内混入了多个文件的时候，我们只能知道这个组件内混入了哪些文件，不知道具体某个功能是哪个js文件提供的。</p><p>而在组合式api中，我们可以将一些可复用的代码，抽离出来作为<code>一个函数</code>并导出，在需要使用的地方导入后直接调用即可。这个种模块化的方式既解决了<code>命名冲突</code>的问题，也解决了<code>数据来源不清晰</code>的问题。为什么呢？因为每个函数的命名一般都是从它的<code>功能</code>出发的。我们导入不同功能的函数，通常不会有命名冲突的问题；而且每个函数的功能明确，需要通过调用函数的方式拿到函数内部返回的数据，这样数据的依赖就很明确了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mouse/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive, onUnmounted, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()<span class="comment">//直接调用</span></span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h2><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改对象的现有属性，并返回此对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个对象，将这个对象转变成响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用Object.keys可比使用for in 然后再使用hasOwnProperty判断方便多了</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="comment">//如果存在嵌套对象的情况，则递归添加响应式。</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> val == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">observe</span>(val) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                <span class="comment">//当给key赋值为对象的时候，还需要在set方法中给这个对象也添加响应式。</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                    <span class="title function_">observe</span>(newVal)</span><br><span class="line">                &#125;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="comment">//调用update方法，做一些更新视图的工作，依赖这个属性的视图，计算属性，watch都会更新或执行一些逻辑</span></span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="title function_">observe</span>(arrData)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">//无响应</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">//无响应</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">//ok，有响应</span></span><br></pre></td></tr></table></figure><p><strong>缺点小结</strong></p><ul><li><code>Object.defineProperty</code>无法监听到数组方法对数组元素的修改</li><li>需要遍历对象每个属性<code>逐个添加监听</code>，而且无法监听到<code>对象属性</code>的<code>添加</code>与<code>删除</code>，如果属性值是嵌套对象，还深层监听，造成性能问题。</li></ul><h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a>Proxy</h3><p><code>Proxy</code>的监听是<code>整个对象</code>，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p><p>定义一个响应式方法<code>reactive</code>，这个<code>reactive</code>方法，就是vue3中的<code>reactive</code>方法的<strong>简化版</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下简单数据的操作，发现都能劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">//输出：&quot;获取foo:foo&quot;</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">//输出：&quot;设置foo:fooooooo&quot;</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// 输出：&quot;设置dong:dong&quot;</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// 输出：&quot;删除dong:true&quot;</span></span><br></pre></td></tr></table></figure><p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终结果- 输出：&quot;获取bar:[object Object]&quot;</span></span><br><span class="line"><span class="comment">//因为 state.bar 就是在访问bar属性，触发getter，所以输出：&quot;获取bar:[object Object]&quot;，并且返回&#123;a:1&#125;</span></span><br><span class="line"><span class="comment">//然后访问&#123;a:1&#125;的a属性，由于&#123;a:1&#125;是个普通对象，所以不会触发对应的getter</span></span><br><span class="line"><span class="comment">//简单的来说，这个操作进行了两次属性访问，但是只触发了一次getter</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> </span><br></pre></td></tr></table></figure><p>如果要解决，需要在<code>get</code>之上再进行一层代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="comment">//如果返回的对象是一个object，则给这个对象添加响应式</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> res===<span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改后输出的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取<span class="attr">bar</span>:[object <span class="title class_">Object</span>]</span><br><span class="line">设置<span class="attr">a</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure><p>由此可以看出，Proxy是<strong>按需添加响应式</strong>的，只有当我们取出的值是一个对象的时候，Proxy才会递归给这个对象添加响应式。而在<code>Object.defineProperty</code>中是直接递归添加响应式的。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>Object.defineProperty</code>这个方法存在许多缺点，比如必须<code>遍历对象</code>的所有属性<code>逐个添加监听</code>，而且无法监听对象属性的增加与删除，如果属性的值是<code>引用类型</code>还需要<code>深度监听</code>，造成<code>性能问题</code>。</p><p>对于数组，<code>Object.defineProperty</code>方法无法监听到数组方法，对数组元素的修改，需要重写数组方法。</p><p>而Proxy能监听整个对象的变化，也能监听到数组方法对数组元素的修改。</p><h2 id="说说Vue-3-0中Treeshaking特性？"><a href="#说说Vue-3-0中Treeshaking特性？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？"></a>说说Vue 3.0中Treeshaking特性？</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p><code>Tree shaking</code> 是一种通过<strong>清除多余js代码</strong>方式，来<code>优化项目打包体积</code>的技术。</p><h3 id="如何做-3"><a href="#如何做-3" class="headerlink" title="如何做"></a>如何做</h3><p><code>Tree shaking</code>是基于<code>ES6</code>模块语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的<code>静态编译</code>思想，在<code>编译时</code>就能确定模块的依赖关系，以及输入和输出的变量。</p><p><code>Tree shaking</code>无非就是做了两件事：</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些函数和变量未被使用或者引用，进而删除对应代码</li></ul><p>那么为什么使用 CommonJs、AMD 等模块化方案无法支持 Tree Shaking 呢？</p><p>因为在 CommonJs、AMD、CMD 等旧版本的 js 模块化方案中，导入导出行为是<strong>高度动态</strong>，难以预测的，只能在<code>代码运行的时候</code>确定所有模块的依赖关系，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句，只能出现在<strong>模块顶层</strong>，可以理解为全局作用域；且导入导出的模块名必须为字符串常量，这意味着下述代码在 ESM 方案下是非法的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，ESM 模块之间的依赖关系是<code>高度确定</code>的，与运行状态无关，编译工具只需要对 ESM 模块做<code>静态语法分析</code>，就可以从代码字面量中，推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。</p><p>关于<code>tree-shaking</code>更多内容参考：<a href="https://www.sanye.blog/posts/762e27cc.html">前端面试—webpack | 三叶的博客</a></p><p>关于<code>cjs和esm</code>的更多内容参考：<a href="http://www.sanye.blog/posts/3418e521.html">nodejs | 三叶的博客</a></p><h2 id="Composition-Api-与-Options-Api-有什么不同？"><a href="#Composition-Api-与-Options-Api-有什么不同？" class="headerlink" title="Composition Api 与  Options Api 有什么不同？"></a>Composition Api 与 Options Api 有什么不同？</h2><ul><li><p>代码组织方式：选项式api按照<code>代码的类型</code>来组织代码；而组合式api按照<code>代码的逻辑</code>来组织代码，逻辑紧密关联的代码会被放到一起。</p></li><li><p>代码复用方式：在选项式api这，我们使用<code>mixin</code>来实现代码复用，使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候，就存在两个非常明显的问题：<code>命名冲突</code>和<code>数据来源不清晰</code></p><p>而在组合式api中，我们可以将一些可复用的代码抽离出来作为<code>一个函数</code>并导出，在需要在使用的地方导入后直接调用即可。这个种<code>模块化</code>的方式，既解决了<code>命名冲突</code>的问题，也解决了<code>数据来源不清晰</code>的问题。更多内容参考前文《Vue3做了哪些优化？》</p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog">三叶sanye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog/posts/f33bd2b9.html">https://www.sanye.blog/posts/f33bd2b9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.sanye.blog" target="_blank">三叶的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/%E5%B0%8F%E9%95%87.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/aef189c3.html" title="js"><img class="cover" src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">js</div></div><div class="info-2"><div class="info-item-1">js学习笔记</div></div></div></a><a class="pagination-related" href="/posts/c0add594.html" title="前端面试---网络"><img class="cover" src="/images/cover/%E4%BA%91%E6%B9%96%E5%B0%91%E5%A5%B3.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">前端面试---网络</div></div><div class="info-2"><div class="info-item-1">前端网络学习笔记</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8b27fabc.html" title="vue"><img class="cover" src="/images/cover/yourname.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="info-item-2">vue</div></div><div class="info-2"><div class="info-item-1">vue2，vue3学习笔记</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/%E4%B8%89%E5%8F%B6.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">三叶sanye</div><div class="author-info-description">记录学习，分享知识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a><a href="/gallery/"><div class="headline">图库</div><div class="length-num">∞</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="Bilibli"><i class="fa-brands fa-bilibili" style="color:#74c0fc"></i></a><a class="social-icon" href="https://github.com/syhy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:3519450570@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2"><span class="toc-number">1.</span> <span class="toc-text">Vue2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">说说你对vue的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">前端发展背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">Vue是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">Vue核心特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="toc-number">1.2.</span> <span class="toc-text">Vue的学习路线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">原生开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-number">1.2.2.</span> <span class="toc-text">原生开发之组件化开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">非单文件组件使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">单文件组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9el%E5%92%8Ctemplate%E5%B1%9E%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">谈谈对el和template属性的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.</span> <span class="toc-text">说说Vue的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">说说你对vue双向绑定的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.5.2.</span> <span class="toc-text">双向绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.</span> <span class="toc-text">说说Vue实例挂载过程中发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-number">1.6.1.</span> <span class="toc-text">vue构造函数源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init"><span class="toc-number">1.6.2.</span> <span class="toc-text">_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initState"><span class="toc-number">1.6.3.</span> <span class="toc-text">initState</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#initData"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">initData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initProps"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">initProps</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vm-mount"><span class="toc-number">1.6.4.</span> <span class="toc-text">vm.$mount</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mountComponent"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">mountComponent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vue"><span class="toc-number">1.7.</span> <span class="toc-text">手写一个简单的Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90"><span class="toc-number">1.7.1.</span> <span class="toc-text">模板解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">添加事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%90%86"><span class="toc-number">1.7.4.</span> <span class="toc-text">添加代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">1.7.5.</span> <span class="toc-text">添加响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A-1"><span class="toc-number">1.7.6.</span> <span class="toc-text">双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.7.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-observable%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%9C%8B"><span class="toc-number">1.8.</span> <span class="toc-text">Vue.observable你有了解过吗？说说看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9slot%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9Fslot%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">说说你对slot的理解？slot使用场景有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD"><span class="toc-number">1.9.1.</span> <span class="toc-text">默认插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="toc-number">1.9.2.</span> <span class="toc-text">具名插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="toc-number">1.9.3.</span> <span class="toc-text">作用域插槽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%9C%89%E5%86%99%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%90%97%EF%BC%9F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">你有写过自定义指令吗？自定义指令的应用场景有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.1.</span> <span class="toc-text">什么是指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">注册自定义指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">定义自定义指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.11.</span> <span class="toc-text">Vue常用的修饰符有哪些有什么应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.11.1.</span> <span class="toc-text">修饰符是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8"><span class="toc-number">1.11.2.</span> <span class="toc-text">修饰符的具体作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">表单修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">事件修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.</span> <span class="toc-text">Vue中组件和插件有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.12.1.</span> <span class="toc-text">组件是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.12.2.</span> <span class="toc-text">插件是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.3.</span> <span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">编写形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">注册形式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.13.</span> <span class="toc-text">Vue组件通信的方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.13.1.</span> <span class="toc-text">组件间通信的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.13.2.</span> <span class="toc-text">组件间通信的方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#props%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">props传递数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emit-%E8%A7%A6%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">$emit 触发自定义事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref"><span class="toc-number">1.13.2.3.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">1.13.2.4.</span> <span class="toc-text">EventBus(事件总线)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#provide-%E4%B8%8E-inject"><span class="toc-number">1.13.2.5.</span> <span class="toc-text">provide 与 inject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vuex"><span class="toc-number">1.13.2.6.</span> <span class="toc-text">Vuex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">1.13.2.7.</span> <span class="toc-text">拓展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA"><span class="toc-number">1.14.</span> <span class="toc-text">SPA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSPA%EF%BC%8C%E5%92%8CMPA%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.1.</span> <span class="toc-text">什么是SPA，和MPA有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0SPA"><span class="toc-number">1.14.2.</span> <span class="toc-text">如何实现SPA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-number">1.14.3.</span> <span class="toc-text">如何提高首屏加载速度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98SPA%E7%9A%84SEO"><span class="toc-number">1.14.4.</span> <span class="toc-text">如何提高SPA的SEO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR"><span class="toc-number">1.14.4.1.</span> <span class="toc-text">服务端渲染SSR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E8%B7%AF%E7%94%B1%E5%92%8Chistory%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">hash路由和history路由的实现原理，二者有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E8%B7%AF%E7%94%B1"><span class="toc-number">1.15.1.</span> <span class="toc-text">hash路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.15.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.15.1.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A"><span class="toc-number">1.15.1.3.</span> <span class="toc-text">如何做</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history%E8%B7%AF%E7%94%B1"><span class="toc-number">1.15.2.</span> <span class="toc-text">history路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-1"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">如何做</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%A6%82%E4%BD%95%E5%81%9A%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.16.</span> <span class="toc-text">vue如何做前端性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.16.1.</span> <span class="toc-text">编码优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E8%B5%84%E6%BA%90%E4%BD%93%E7%A7%AF"><span class="toc-number">1.16.2.</span> <span class="toc-text">减少资源体积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.16.3.</span> <span class="toc-text">加载优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.16.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BB%99%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E8%A7%86%E5%9B%BE%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.17.</span> <span class="toc-text">如何解决给对象添加属性视图不刷新的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.17.1.</span> <span class="toc-text">为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.17.2.</span> <span class="toc-text">如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.18.</span> <span class="toc-text">v-if和v-for的优先级是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">1.19.</span> <span class="toc-text">v-if和v-show如何理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">1.19.1.</span> <span class="toc-text">共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">1.19.2.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9nextTick%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.20.</span> <span class="toc-text">说说你对nextTick的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.20.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.20.2.</span> <span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%AD%A4%E6%97%B6DOM%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.20.3.</span> <span class="toc-text">如何确保此时DOM是最新的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">什么是虚拟DOM？有什么作用？如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8js%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.21.1.</span> <span class="toc-text">在js中的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.21.2.</span> <span class="toc-text">虚拟DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VNode"><span class="toc-number">1.21.2.1.</span> <span class="toc-text">VNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.21.2.2.</span> <span class="toc-text">创建虚拟DOM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Vue%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.21.3.</span> <span class="toc-text">在Vue中的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4diff%E7%AE%97%E6%B3%95"><span class="toc-number">1.22.</span> <span class="toc-text">说说diff算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.22.1.</span> <span class="toc-text">具体复用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E4%B8%ADkey%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.23.</span> <span class="toc-text">说说你对vue中key的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.24.</span> <span class="toc-text">说说你对keep-alive的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4vue%E4%B8%AD%E7%9A%84Mixin"><span class="toc-number">1.25.</span> <span class="toc-text">说说vue中的Mixin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FVue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">跨域是什么？Vue项目中你是如何解决跨域的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">1.26.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-1"><span class="toc-number">1.26.2.</span> <span class="toc-text">如何解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-number">1.26.2.1.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy"><span class="toc-number">1.26.2.2.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-number">1.26.2.3.</span> <span class="toc-text">CORS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82"><span class="toc-number">1.27.</span> <span class="toc-text">如何理解简单请求和复杂请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%EF%BC%9F%E6%9C%89%E9%81%87%E5%88%B0%E5%B8%83%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%88%B7%E6%96%B0404%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">1.28.</span> <span class="toc-text">vue项目如何部署？有遇到布署服务器后刷新404问题吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2"><span class="toc-number">1.28.1.</span> <span class="toc-text">如何部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#404%E9%97%AE%E9%A2%98"><span class="toc-number">1.28.2.</span> <span class="toc-text">404问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%E7%A9%BA%E7%99%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.28.3.</span> <span class="toc-text">直接打开页面空白问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E4%BD%A0%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E4%BD%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%88%92%E5%88%86%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%92%E5%88%86%E7%BB%84%E4%BB%B6%E5%91%A2-%EF%BC%9F"><span class="toc-number">1.29.</span> <span class="toc-text">说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%A6%82%E4%BD%95%E5%81%9A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.30.</span> <span class="toc-text">Vue如何做权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-2"><span class="toc-number">1.30.1.</span> <span class="toc-text">如何做</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3"><span class="toc-number">2.</span> <span class="toc-text">Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2%E4%B8%8EVue3%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">2.1.</span> <span class="toc-text">Vue2与Vue3有什么不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Vue3做了哪些优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">2.2.2.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95API"><span class="toc-number">2.2.3.</span> <span class="toc-text">语法API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Proxy-API-%E6%9B%BF%E4%BB%A3-defineProperty-API-%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defineProperty"><span class="toc-number">2.3.1.</span> <span class="toc-text">defineProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue-3-0%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">说说Vue 3.0中Treeshaking特性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">如何做</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Composition-Api-%E4%B8%8E-Options-Api-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">Composition Api 与 Options Api 有什么不同？</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image:url(/images/cover/云湖少女.png)"><div id="footer-wrap"><div class="footer_custom_text"><div id="sanye"><svg class="icon" aria-hidden="true"><use href="#icon-banquan"></use></svg><span>2024 - 2025 By 三叶sanye</span><svg class="icon" aria-hidden="true"><use href="#icon-sanyecao"></use></svg></div><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/time.js"></script><script src="/js/iconfont.js"></script><script src="/bilibiliBanner/banner.js" defer></script><script src="/gallery/background.js" defer></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="/js/busuanzi.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?82b9a7c4e8fee04e39b57c7d4ffd9832"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,display:{position:"left",width:132,height:264},mobile:{show:!0},react:{opacity:.7},dialog:{enable:!1,hitokoto:!1},model:{jsonPath:"/live2d/live2d.json"}})</script></body></html>