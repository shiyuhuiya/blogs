<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>前端面试---vue部分 | 三叶的博客</title><meta name="author" content="三叶sanye"><meta name="copyright" content="三叶sanye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="vue2+vue3面试题（笔记）"><meta property="og:type" content="article"><meta property="og:title" content="前端面试---vue部分"><meta property="og:url" content="https://www.sanye.blog/posts/f33bd2b9.html"><meta property="og:site_name" content="三叶的博客"><meta property="og:description" content="vue2+vue3面试题（笔记）"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.sanye.blog/images/cover/%E5%B0%8F%E9%95%87.jpg"><meta property="article:published_time" content="2024-12-13T10:56:10.000Z"><meta property="article:modified_time" content="2025-06-12T11:17:36.631Z"><meta property="article:author" content="三叶sanye"><meta property="article:tag" content="vue"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.sanye.blog/images/cover/%E5%B0%8F%E9%95%87.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.sanye.blog/posts/f33bd2b9.html"><link rel="preconnect"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",(()=>{void 0===t.get("theme")&&(e.matches?o():a())}))}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-center"},infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"前端面试---vue部分",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/iconfont/iconfont.css"><link rel="stylesheet" href="/bilibiliBanner/banner.css"><link rel="stylesheet" href="/animeClips/play/index.css"><link rel="stylesheet" href="/gallery/background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i:0"></div><div class="iron-coil" style="--i:1"></div><div class="iron-coil" style="--i:2"></div><div class="iron-coil" style="--i:3"></div><div class="iron-coil" style="--i:4"></div><div class="iron-coil" style="--i:5"></div><div class="iron-coil" style="--i:6"></div><div class="iron-coil" style="--i:7"></div></div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/%E4%B8%89%E5%8F%B6.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-location-dot"></i> <span>分站</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://www.sanye.blog"><i class="fa-fw fa-solid fa-location-dot"></i> <span>vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.sanye.space"><i class="fa-fw fa-solid fa-location-dot"></i> <span>阿里云</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i> <span>图库</span></a></div><div class="menus_item"><a class="site-page" href="/animeClips/"><i class="fa-fw fa-solid fa-video"></i> <span>剪辑</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/cover/小镇.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name iconfont icon-sanyecao">三叶的博客</span></a><a class="nav-page-title" href="/"><span class="site-name iconfont icon-sanyecao">前端面试---vue部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-location-dot"></i> <span>分站</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://www.sanye.blog"><i class="fa-fw fa-solid fa-location-dot"></i> <span>vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.sanye.space"><i class="fa-fw fa-solid fa-location-dot"></i> <span>阿里云</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i> <span>图库</span></a></div><div class="menus_item"><a class="site-page" href="/animeClips/"><i class="fa-fw fa-solid fa-video"></i> <span>剪辑</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端面试---vue部分<a class="post-edit-link" href="https://github.com/shiyuhuiya/shiyuhuiya.github.io/issues_posts/前端面试-vue.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-13T10:56:10.000Z" title="发表于 2024-12-13 18:56:10">2024-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-12T11:17:36.631Z" title="更新于 2025-06-12 19:17:36">2025-06-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">46.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>172分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-06-12 19:17:36&quot;}" hidden></div><h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="headerlink" title="说说你对vue的理解"></a>说说你对vue的理解</h2><h3 id="前端发展背景"><a href="#前端发展背景" class="headerlink" title="前端发展背景"></a>前端发展背景</h3><p>最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，就是<code>纯静态页面</code></p><p>直到<code>CGI</code>技术的出现，通过 CGI Perl 运行一小段代码，与数据库或文件系统进行<code>交互</code>(前后端交互)</p><p>后来JSP(Java Server Pages)技术取代了CGI技术，其实就是Java + HTML</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=utf-8&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;JSP demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=<span class="string">&quot;http://localhost:8080/web05_session/1.jpg&quot;</span> width=<span class="string">&quot;200&quot;</span> height=<span class="string">&quot;100&quot;</span> alt=<span class="string">&quot;示例图片&quot;</span> /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>JSP有一个很大的<code>缺点</code>，就是不太灵活。JSP使用 <code>Java</code> 而不是 <code>JavaScript</code>，并且 Java 代码只能在服务器端运行。我们每次的请求：获取的数据、内容的加载，服务器都会做对应的处理，并渲染dom然后返回渲染好的dom，简单的来说，JSP把页面的渲染工作完全交给后端服务器。</p><p>后来<code>ajax</code>火了，它允许用户在不刷新整个页面的前提下，和后端服务器交换数据，并由浏览器执行js代码，更新部分页面。</p><p>随后移动设备的普及，Jquery的出现，以及SPA（Single Page Application 单页面应用）的雏形，Backbone EmberJS，AngularJS 这样一批前端框架随之出现，但当时SPA的路不好走，例如SEO问题，SPA 过多的页面、复杂场景下 View 的绑定等，都没有很好的处理。</p><p>经过这几年的飞速发展，节约了开发人员大量的精力、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度。我们可以看到Web技术的变化之大与快，每一种新的技术出现都是一些特定场景的解决方案，那我们今天的主角Vue又是为了解决什么呢？</p><h3 id="Vue是什么"><a href="#Vue是什么" class="headerlink" title="Vue是什么"></a>Vue是什么</h3><p>是一个用于创建<code>用户界面</code>的开源<code>JavaScript框架</code>，也是一个创建<code>单页应用（SPA）</code>的前端框架。关键词：</p><ul><li>js框架</li><li>单页面应用程序</li></ul><h3 id="Vue核心特性"><a href="#Vue核心特性" class="headerlink" title="Vue核心特性"></a><strong>Vue核心特性</strong></h3><ul><li><p><strong>数据驱动视图更新</strong></p><p>数据驱动(MVVM)，相比于react，开发者无需手动调用 <code>setState</code>等api来提示视图更新。</p><p>MVVM表示的是 Model-View-ViewModel</p><ul><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁，<strong>在vue中这个桥梁是vue实例</strong></li></ul></li><li><p><strong>组件化</strong></p><ul><li>降低了代码的耦合度，提高了代码的可维护性，可复用性，便于调试。</li><li>vue中的组件可分为<code>单文件组件</code>和<code>多文件组件</code>，vue中的组件是能实现部分功能的<code>css，js，html</code>等代码和资源的集合。</li></ul></li><li><p><strong>指令系统</strong></p><p>指令 (Directives) 是带有 <code>v- 前缀</code>的<code>特殊属性</code>，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。<strong>简单的来说，vue中的指令系统简化了dom操作</strong>，而react中没有指令系统。</p></li></ul><p>上述核心特性在后面都会有介绍，在此处不赘述。</p><h2 id="Vue的学习路线"><a href="#Vue的学习路线" class="headerlink" title="Vue的学习路线"></a><strong>Vue的学习路线</strong></h2><h3 id="原生开发"><a href="#原生开发" class="headerlink" title="原生开发"></a><strong>原生开发</strong></h3><p>通过script标签引入<code>vue.js</code>，src属性通常是http链接，或者下载到本地的vue.js文件的路径。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是http链接，当浏览器加载这个脚本，会发送一个get请求获取并执行vue的js代码。</p><p>引入vue.js后，<strong>Vue</strong>这个构造函数成为<strong>全局变量</strong>，挂载到<strong>window</strong>对象上</p><p>然后我们在页面的<strong>script</strong>标签中写些代码，创建一个vue实例，传入一个配置对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时我们还未引入<strong>组件</strong>的概念，但是我们已经能够学习vue的大部分知识点了。包括模板语法，数据绑定，数据代理如何实现，vue的常用指令，计算属性，数据监听，vue的生命周期等等。</p><h3 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h3><p>什么组件？组件化开发有什么好处？</p><p>在vue中，<strong>组件就是能实现<code>局部功能</code>的<code>html，css，js</code>代码的集合</strong>，组件化开发有利于<strong>代码复用</strong>，提高开发效率，同时把功能上密切相关的html，css，js代码放到一起，<strong>依赖关系明确</strong>，易于维护。</p><p>vue的组件可分为<strong>单文件组件</strong>和<strong>非单文件组件</strong></p><ul><li>非单文件组件就是通过<strong>Vue.extend({})<strong>，返回一个</strong>VueComponent</strong>构造函数</li><li>这个构造函数被用来创建<strong>组件实例</strong>，依赖的<strong>配置对象</strong>就是<code>Vue.extend(&#123;&#125;)</code>传入的对象</li><li>这个配置对象的结构，和<code>new Vue()</code>传入的配置对象的结构几乎一致。</li><li>存在如下关系，即<code>Vuecomponent</code>是Vue的<code>子类</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组件实例.<span class="property">_proto_</span> = <span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_proto_</span> = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><img src="C:/Users/35194/Desktop/hexo/blog/source/images/前端面试-vue/vue.png" style="zoom:80%"><h3 id="非单文件组件使用"><a href="#非单文件组件使用" class="headerlink" title="非单文件组件使用"></a><strong>非单文件组件使用</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">:name</span>=<span class="string">&quot;str&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;str&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">School</span>&gt;</span><span class="tag">&lt;/<span class="name">School</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个school组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">School</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">str</span>: <span class="string">&quot;haha&quot;</span>,</span><br><span class="line">      <span class="attr">keyword</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//组件注册</span></span><br><span class="line">    <span class="attr">components</span>:&#123;<span class="title class_">School</span>&#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a><strong>单文件组件</strong></h3><p>单文件组件就是我们熟知的<code>.vue</code>文件, 单文件组件解决了非单文件组件<code>无法复用css代码</code>的问题，我们开发过程中使用的最多的组件也是单文件组件。</p><p>显然，<code>.vue</code>文件是vue团队开发的文件，无法在浏览器上运行，所以我们需要借助模块化打包工具webpack来处理这个文件，webpack又是基于<code>nodejs</code>的，<code>nodejs</code>是使用模块化开发的。这样vue的开发就过渡到了基于<code>nodejs+webpack</code>的<strong>模块化</strong>开发，为了简化模块化开发过程中webpack的配置，vue团队就开发了<code>vue-cli</code>，即vue的脚手架</p><p>单文件组件的大致结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>其中<code>export default &#123;&#125;</code>由<code>export default Vue.extend(&#123;&#125;)</code>简化而来的，组件注册的时候会自动处理：如果发现注册的组件是一个对象，而不是一个VueComponet构造函数 ，则使用<code>Vue.extend</code>包裹，否则直接注册。</p></li><li><p>组件之间通过嵌套确定层级关系，所有其他组件都在根组件App.vue内，根组件直接嵌入<code>index.html</code>文件，这一嵌入操作是在<code>main.js</code>中实现的</p></li><li><p>组件化开发后不需要直接在html页面中写结构，内容被分解为一个一个vue组件中的模板。</p></li></ul><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>你们有没有思考过这个问题，render函数是如何得到的，调用render函数到底做了什么？</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><code>createElement</code>常常出现在渲染函数<code>render</code>中，下面举例子说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;span&gt;age:&#123;&#123;age&#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Child&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    age: Number</span><br><span class="line">  &#125;,</span><br><span class="line">  updated()&#123;</span><br><span class="line">    console.log(&#x27;更新了&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;      </span><br><span class="line">    &lt;!-- 向子组件传递一个基本数据类型 --&gt;</span><br><span class="line">    &lt;Child :age=&quot;age&quot;&gt;</span><br><span class="line">    &lt;/Child&gt;</span><br><span class="line">    &lt;button @click=&quot;add(&#x27;age&#x27;)&quot;&gt;age++&lt;/button&gt;  </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;@/components/Child.vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      age:1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    Child//js对象</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">      this.age++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上述组件模板<code>template</code>，最终会被<strong>编译</strong>为如下渲染函数render（在<code>$mount</code>方法中，在后文有介绍）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>, <span class="comment">// 根元素 div</span></span><br><span class="line">    [ <span class="comment">// 子节点数组</span></span><br><span class="line">      <span class="title function_">createElement</span>(<span class="string">&#x27;Child&#x27;</span>, &#123; <span class="comment">// 子组件 Child，绑定 props.age</span></span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">          <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span> <span class="comment">// 传递父组件的 age 属性</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 按钮元素，绑定 click 事件</span></span><br><span class="line">      <span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">on</span>: &#123;</span><br><span class="line">          <span class="attr">click</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(<span class="string">&#x27;age&#x27;</span>) <span class="comment">// 触发 add(&#x27;age&#x27;) 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="string">&#x27;age++&#x27;</span>)<span class="comment">//&#x27;age++&#x27;是标签体内容</span></span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建组件<strong>根实例</strong>的时候，使用的render函数中，也用到了<code>createElement</code>函数，不过这个render函数相当于是用户自定义的，而不是模板解析后得到的，结构非常简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(app);</span><br></pre></td></tr></table></figure><p><code>import</code>一个App组件，得到的到底是个啥？打印出来可以看到，<strong>App就是一个包含多个属性的，组件配置对象，包含了组件的所有信息。</strong></p><img src="..\images\前端面试-vue\vue组件.png" style="zoom:80%"><p>我们将这个对象交给<code>render</code>方法，最终交给h方法来调用，h方法就是<code>createElement</code>方法。</p><h3 id="CreateElement"><a href="#CreateElement" class="headerlink" title="CreateElement"></a>CreateElement</h3><p>所以<code>createElement</code>方法到底是个什么玩意？ <strong>createElement 是 Vue 中用于创建虚拟 DOM 节点（VNode）的核心函数</strong>。createElement大致源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 它接受多个参数来描述要创建的节点，并返回一个 VNode 或者 VNode 数组。</span></span><br><span class="line"><span class="comment"> * context - 当前组件实例，用于获取组件选项和其他上下文信息。</span></span><br><span class="line"><span class="comment"> * tag - 标签名或组件构造函数。</span></span><br><span class="line"><span class="comment"> * data - 节点的数据对象，包含属性、样式等信息。</span></span><br><span class="line"><span class="comment"> * children - 子节点，可以是字符串、数组或其他 VNode。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  context: Component,</span></span><br><span class="line"><span class="params">  tag: string | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  data: VNodeData | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  children: any</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 省略了许多代码......</span></span><br><span class="line">  <span class="comment">// 调用 _createElement 处理实际的 VNode 创建逻辑。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * _createElement 是 createElement 的内部实现，负责处理具体的 VNode 创建逻辑。</span></span><br><span class="line"><span class="comment"> * context - 当前组件实例。</span></span><br><span class="line"><span class="comment"> * tag - 标签名或组件构造函数。</span></span><br><span class="line"><span class="comment"> * data - 节点的数据对象。</span></span><br><span class="line"><span class="comment"> * children - 子节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  context: Component,</span></span><br><span class="line"><span class="params">  tag?: string | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  data?: VNodeData,</span></span><br><span class="line"><span class="params">  children?: any,                                </span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> vnode;</span><br><span class="line">  <span class="comment">// 检查 tag 是否为字符串类型。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span>;</span><br><span class="line">    <span class="comment">// 如果 tag 是保留标签（如 div, span 等），则创建普通元素的 VNode。</span></span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// 如果 tag 是已注册的组件，则创建组件类型的 VNode。</span></span><br><span class="line">      <span class="comment">// resolveAsset 函数用于从当前Vue实例的选项中，查找名为 &#x27;tag&#x27; 的组件</span></span><br><span class="line">      <span class="comment">// Ctor是组件的构造器，虽然通常情况是一个js对象，还需要在createComponent中进一步处理</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 tag 不是保留标签也不是已注册的组件，则将其视为未知标签处理。</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 tag 不是字符串，则直接创建组件类型的 VNode。</span></span><br><span class="line">    <span class="comment">// 这种情况出现在创建vue根实例中</span></span><br><span class="line">    <span class="comment">// const app = new Vue(&#123; render: (h) =&gt; h(App)&#125;).$mount(&quot;#app&quot;);</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 其他处理逻辑 ...</span></span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：createElement 根据 <code>tag</code> 的不同，调用不同的方法(new VNode或者createComponent)生成 VNode</strong></p><ul><li><p>如果<code>tag</code> 是字符串：</p><ul><li><p>如果tag是HTML内置的标签：直接调用<code>new VNode()</code>方法创建VNode</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">   config.<span class="title function_">parsePlatformTagName</span>(tag),</span><br><span class="line">   data,<span class="comment">// 节点的数据对象，包含属性、事件等</span></span><br><span class="line">   children,<span class="comment">// 子节点数组或单个子节点</span></span><br><span class="line">   <span class="literal">undefined</span>,<span class="comment">//文本内容，这里为undefined因为不是文本节点</span></span><br><span class="line">   <span class="literal">undefined</span>,</span><br><span class="line">   context<span class="comment">//当前的Vue实例上下文</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>如果tag是<strong>已注册的组件标签</strong>，则拿到对应的组件构造器Ctor（虽然通常情况是一个js对象），然后再调用createComponent</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">   <span class="comment">// 如果 tag 是已注册的组件，则创建组件类型的 VNode。</span></span><br><span class="line">   <span class="comment">// resolveAsset 函数用于从当前Vue实例的选项中查找名为 &#x27;tag&#x27; 的组件</span></span><br><span class="line">   <span class="comment">// Ctor是组件的构造器，虽然通常情况是一个js对象，还需要在createComponent中进一步处理</span></span><br><span class="line">   vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>如果tag是一个js对象，比如App，则直接调用<code>createComponent</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children);</span><br><span class="line"></span><br><span class="line"><span class="string">`new VNode()`</span>的作用很明显，就是创建一个<span class="title class_">VNode</span>；从总结中可以看出，传入<span class="string">`createComponent`</span>的是一个**组件配置对象**，那<span class="string">`createComponent`</span>的作用是什么，**如何处理类似<span class="title class_">App</span>这样的组件js对象？**</span><br><span class="line"></span><br><span class="line">#### createComponent</span><br><span class="line"></span><br><span class="line">createComponent 是**用于创建组件类型<span class="title class_">VNode</span>**，它最终也会调用<span class="string">`new VNode()`</span>返回据组件的<span class="title class_">VNode</span>。大致源码如下</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">// src/core/vdom/create-component.js</span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Ctor - 组件构造函数或配置对象。</span></span><br><span class="line"><span class="string"> * data - 组件的数据对象。</span></span><br><span class="line"><span class="string"> * context - 当前组件实例，提供上下文信息。</span></span><br><span class="line"><span class="string"> * children - 子节点数组。</span></span><br><span class="line"><span class="string"> * [tag] - 标签名，如果有的话。</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">export function createComponent(</span></span><br><span class="line"><span class="string">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span></span><br><span class="line"><span class="string">  data: ?VNodeData,</span></span><br><span class="line"><span class="string">  context: Component,</span></span><br><span class="line"><span class="string">  children: ?Array&lt;VNode&gt;,</span></span><br><span class="line"><span class="string">  tag?: string</span></span><br><span class="line"><span class="string">): VNode | Array&lt;VNode&gt; | void &#123;</span></span><br><span class="line"><span class="string">  // 如果 Ctor 未定义，则直接返回。</span></span><br><span class="line"><span class="string">  if (isUndef(Ctor)) &#123;</span></span><br><span class="line"><span class="string">    return;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 获取 Vue 的基础构造器，通常是指向 Vue 本身。</span></span><br><span class="line"><span class="string">  const baseCtor = context.$options._base;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 如果 Ctor 是一个对象，则通过 Vue.extend 方法扩展它，使其成为一个真正的组件构造函数。</span></span><br><span class="line"><span class="string">  if (isObject(Ctor)) &#123;</span></span><br><span class="line"><span class="string">    Ctor = baseCtor.extend(Ctor); // 使用 Vue.extend 创建子类构造函数</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 异步组件处理逻辑（省略）</span></span><br><span class="line"><span class="string">  // 初始化 data 对象，确保其存在。</span></span><br><span class="line"><span class="string">  data = data || &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 将组件 v-model 数据转换为 props 和 events（省略）</span></span><br><span class="line"><span class="string">  // 从 vnode data中提取 props 数据（propsData）（省略）。</span></span><br><span class="line"><span class="string">  // 提取 listeners，并将原生事件监听器移到 data.nativeOn 中（省略）。</span></span><br><span class="line"><span class="string">  // 安装组件钩子函数，如 init、prepatch 等（省略）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 实例化 VNode 并返回。注意，组件 VNode 没有 children。</span></span><br><span class="line"><span class="string">  const name = Ctor.options.name || tag;</span></span><br><span class="line"><span class="string">  const vnode = new VNode(</span></span><br><span class="line"><span class="string">     //tag属性，用来区别是组件类型的VNode，还是普通VNode，这里以vue-component-显然是组件类型的VNode</span></span><br><span class="line"><span class="string">    `</span>vue-component-$&#123;<span class="title class_">Ctor</span>.<span class="property">cid</span>&#125;$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&quot;&quot;</span>&#125;<span class="string">`,</span></span><br><span class="line"><span class="string">    data,</span></span><br><span class="line"><span class="string">    undefined, // 注意这里没有 children</span></span><br><span class="line"><span class="string">    undefined,</span></span><br><span class="line"><span class="string">    undefined,</span></span><br><span class="line"><span class="string">    context,</span></span><br><span class="line"><span class="string">    &#123; Ctor, propsData, listeners, tag, children &#125;,//提取出的 propsData 被传入组件 VNode 的 componentOptions 中</span></span><br><span class="line"><span class="string">    asyncFactory</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">  return vnode;//最终返回一个vnode，这个vnode就是组件的vnode</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><code>createComponent</code> 在这里主要做了2件事</p><ul><li><p>把传入的组件对象，使用<code>Vue.extend</code>构造成 <code>Vue</code> 的子类，我们书写组件的时候是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">HelloWorld</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>导入的<code>HelloWorld</code>是一个对象，因为是个对象，所以代码逻辑会走到 <code>Ctor = baseCtor.extend(Ctor)</code> 在这里 <code>baseCtor</code> 是 <code>Vue</code> 构造函数。 然后执行 <code>baseCtor.extend</code> 将我们传入的对象，转化为构造函数。</p></li><li><p>实例化 <code>VNode</code> 并返回：在createComponent中，最终还是要调用<code>new VNode()</code>方法创建一个VNode并返回</p></li></ul><h5 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend()"></a>Vue.extend()</h5><p>这个api我们在学习非单文件组件的时候就学习过，下面是简要的源码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">extend</span> = <span class="keyword">function</span> (<span class="params">extendOptions: <span class="built_in">Object</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="comment">// 如果 extendOptions 没有提供，则初始化为空对象。</span></span><br><span class="line">  extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Super 指向 Vue。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Super</span> = <span class="variable language_">this</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取 Super 的 cid（组件标识符）。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">SuperId</span> = <span class="title class_">Super</span>.<span class="property">cid</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取或初始化缓存构造器对象，用于缓存已经创建过的子类构造函数。（省略）</span></span><br><span class="line">  <span class="comment">// 如果已经存在以 SuperId 为键的子类构造函数，则直接返回缓存的实例（省略）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定新组件的名字，优先使用 extendOptions.name，否则使用 Super.options.name。</span></span><br><span class="line">  <span class="keyword">const</span> name = extendOptions.<span class="property">name</span> || <span class="title class_">Super</span>.<span class="property">options</span>.<span class="property">name</span></span><br><span class="line">  <span class="comment">// 在非生产环境中，如果提供了组件名，则验证其合法性（省略）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义新的构造函数 Sub，它将作为扩展后的 Vue 子类。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Sub</span> = <span class="keyword">function</span> <span class="title function_">VueComponent</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 _init 方法进行实例化，这是 Vue 实例初始化的入口。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置 Sub.prototype 为 Super.prototype 的副本，实现原型链继承。</span></span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 分配一个唯一的 cid 给新的子类构造函数。</span></span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">cid</span> = cid++</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 合并 Super.options 和 extendOptions 来生成 Sub 的 options（省略）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 Super 设为 Sub 的 super 属性，方便访问父类。</span></span><br><span class="line">  <span class="title class_">Sub</span>[<span class="string">&#x27;super&#x27;</span>] = <span class="title class_">Super</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略了许多代码。。。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回扩展后的子类构造函数。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Sub</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vue.extend()</code>的主要作用就是：</p><ul><li>根据传入的组件配置对象，创建一个组件构造函数并返回</li><li>这个组件构造函数的名称是<code>VueComponent</code>，它的父类是Vue构造函数</li></ul><p>调用<code>VueComponent</code>构造函数，就开始了组件实例的创建和初始化流程。<strong>不过这个构造函数，不是在createComponent中被直接调用的，而是挂载到createComponent返回的VNode中，也就是组件的VNode中</strong></p><p>具体来说，<strong>子组件的 VNode</strong> 包含了一个特殊的 <code>componentOptions</code> 属性，其中包含了子组件的构造函数，以及其他相关信息如 <code>propsData</code>, <code>children</code> 等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">   <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&quot;&quot;</span>&#125;</span>`</span>,</span><br><span class="line">   data,</span><br><span class="line">   <span class="literal">undefined</span>, <span class="comment">// 注意这里没有 children</span></span><br><span class="line">   <span class="literal">undefined</span>,</span><br><span class="line">   <span class="literal">undefined</span>,</span><br><span class="line">   context,</span><br><span class="line">   &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;<span class="comment">//componentOptions,</span></span><br><span class="line">   asyncFactory</span><br><span class="line"> );</span><br><span class="line"> <span class="keyword">return</span> vnode;<span class="comment">//最终返回一个vnode，这个vnode就是组件的vnode</span></span><br></pre></td></tr></table></figure><p>那这个构造函数具体是何时被调用呢？</p><ul><li>调用父组件的render函数的时候，就会调用这个构造函数，开启子组件实例的创建吗？并不会！</li><li>父组件调用render的时候，只会创建子组件的VNode，创建子组件的构造函数，但是不会调用子组件的构造函数。只有当父组件调用<code>_update</code>方法将虚拟DOM转化成真实DOM的时候，在<code>createEle</code>方法（将虚拟DOM转化成真实DOM）中，才会调用子组件的构造函数，创建组件实例。</li></ul><p>创建组件实例的时候又发生了什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Sub</span> = <span class="keyword">function</span> <span class="title function_">VueComponent</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 _init 方法进行实例化，这是 Vue 实例初始化的入口。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分内容在《说说Vue实例挂载过程中发生了什么》中有介绍。</p><h2 id="说说Vue实例挂载过程中发生了什么"><a href="#说说Vue实例挂载过程中发生了什么" class="headerlink" title="说说Vue实例挂载过程中发生了什么"></a>说说Vue实例挂载过程中发生了什么</h2><p>我们都听过知其然知其所以然这句话</p><p>那么不知道大家是否思考过<code>new Vue()</code>这个过程中究竟做了些什么？</p><p>过程中是如何完成<code>数据的绑定</code>，又是如何将<code>数据渲染到视图</code>的等等。下面给出简要流程：</p><ul><li><p>在构造函数中调用<code>_init</code>方法</p></li><li><p>在<code>_init</code>方法内部：</p><ul><li>做一些初始化工作</li><li>调用<code>beforeCreate</code>钩子</li><li>初始化<code>Injections</code></li><li>初始化<code>state</code></li><li>初始化<code>Provide</code></li><li>调用<code>created</code>钩子</li><li>调用<code>vm.$mount</code>方法</li></ul></li><li><p>在<code>initState</code>方法内部，依次调用：</p><ul><li><code>initProps</code></li><li><code>initMethods</code></li><li><code>initData</code></li><li><code>initComputed</code></li><li><code>initWatch</code></li></ul></li><li><p>在<code>initData</code>方法内部</p><ul><li>检查data中的属性，是否和props和method中的属性有冲突</li><li>调用proxy方法，把数据代理到this上，简化访问路径</li><li>调用observe方法，给数据添加响应式</li></ul></li><li><p>在<code>initProps</code>方法内部</p><ul><li><p>创建一个空对象，赋值给<code>vm._props</code></p></li><li><p>校验props中的key是否合法，得到一个value</p></li><li><p>把这个value和对应的key，响应式地添加到<code>vm._props</code>，最终代理到vm。</p></li></ul></li></ul><h3 id="vue构造函数"><a href="#vue构造函数" class="headerlink" title="vue构造函数"></a>vue构造函数</h3><p>首先找到<code>vue</code>的构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：src\core\instance\index.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>) ) &#123;</span><br><span class="line">    <span class="comment">//如果不说生产环境且不是Vue实例调用这个构造函数就报错</span></span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//this指向创建的Vue实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>options</code>是用户传递入的配置对象，包含<code>data、methods</code>等常用属性。</p><p><code>vue</code>构建函数调用了<code>_init</code>方法，并传入了<code>options</code>，所以我们关注的核心就是<code>_init</code>方法：</p><h3 id="init"><a href="#init" class="headerlink" title="_init"></a>_init</h3><img src="..\images\前端面试-vue\vue挂载.png" style="zoom:80%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：src\core\instance\init.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="comment">//vm = this = vue实例</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    ....</span><br><span class="line">	<span class="comment">// 初始化组件生命周期标志位</span></span><br><span class="line">	<span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">	<span class="comment">// 初始化组件事件侦听</span></span><br><span class="line">	<span class="title function_">initEvents</span>(vm)</span><br><span class="line">	<span class="comment">// 初始化渲染方法</span></span><br><span class="line">	<span class="title function_">initRender</span>(vm)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用生命周期钩子&#x27;beforeCreate&#x27;</span></span><br><span class="line">	<span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 初始化注入内容，在初始化data、props之前。</span></span><br><span class="line">	<span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">	<span class="comment">// 初始化 props/data/method/watch/methods/computed</span></span><br><span class="line">	<span class="title function_">initState</span>(vm)</span><br><span class="line">	<span class="comment">//之所以最后初始化Provide，因为Provide引用的数据就是data或者computed等属性中的。</span></span><br><span class="line">	<span class="title function_">initProvide</span>(vm)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用生命周期钩子&#x27;created&#x27;，此时不光是data，props，method，watch，provide等几乎所有配置属性都完成了初始化的工作</span></span><br><span class="line">	<span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">// 挂载元素</span></span><br><span class="line">	<span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">	   vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析后得出如下结论：</p><ul><li>在调用<code>beforeCreate</code>之前，主要做一些数据初始化的工作，<code>数据初始化</code>并未完成，像<code>data</code>、<code>props</code>这些对象内部属性无法通过<code>this</code>访问到。所以说<code>beforeCreate</code>的执行时机<code>先于data()函数调用</code>，data函数调用，是在初始化data的时候被触发的。</li><li><code>initInjections</code> 在 <code>initState</code> 之前执行，因为 <code>inject</code> 可能被 <code>data</code> 或 <code>computed</code> 依赖。</li><li><code>initProvide</code> 在最后执行，因为它依赖于 <code>data</code> 或 <code>computed</code> 的值。</li><li>执行<code>created</code>的时候，所有配置属性几乎都初始化完成，能够直接通过<code>this</code>访问<code>data</code>、<code>props</code>这些对象的属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</li><li>通过调用<code>vm.$mount</code>方法实现了dom挂载</li></ul><h3 id="initInjections和initProvide"><a href="#initInjections和initProvide" class="headerlink" title="initInjections和initProvide"></a>initInjections和initProvide</h3><p>关于<code>initInjections</code>和<code>initProvide</code>的详细介绍，在后文《组件传值-provide和inject》部分中。</p><h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><img src="..\images\前端面试-vue\vue挂载2.png" style="zoom:67%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：src\core\instance\state.js</span></span><br><span class="line"><span class="comment">//vm是vue实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化组件的watcher列表</span></span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="comment">// 初始化methods，要做的其实很简单，单纯把methods中的全部方法挂载到this上就行</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化data  </span></span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化computed</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="comment">// 初始化watch</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析后发现，<code>initState</code>方法<strong>依次，统一</strong>初始化了<code>props/methods/data/computed/watch</code>，说明在<code>created</code>的时候，这些东西都准备好了，或者说初始化工作都完成了。</p><p>我们继续分析<code>initState</code>中的<code>initData</code>方法，关于<code>initProps</code>和<code>initComputed</code>等其他属性的初始化做了什么，这里暂时不深入研究。</p><h3 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的第二个参数是子组件中的props属性的值（props配置对象）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initProps</span>(<span class="params">vm, propsOptions</span>) &#123;</span><br><span class="line">  <span class="comment">//propsData是从父组件中传递过来的值的集合</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.<span class="property">$options</span>.<span class="property">propsData</span> || &#123;&#125;;</span><br><span class="line">  <span class="comment">//创建一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">_props</span> = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历 Props 配置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">//使用propsOptions校验propsData</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm);</span><br><span class="line">    <span class="comment">// 给创建的props（空对象）添加响应式</span></span><br><span class="line">    <span class="title function_">defineReactive</span>(props, key, value);</span><br><span class="line">    <span class="comment">// 代理到实例（this），然后就能直接通过this访问</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">&#x27;_props&#x27;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>propsOptions = vm.$options.props</code>，是props配置对象，是我们自定义的，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line"> <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line"> <span class="comment">// 对象形式  </span></span><br><span class="line"> <span class="attr">age</span>:&#123;    </span><br><span class="line">     <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">     <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">     <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>vm.$options.propsData</code>，是组件接收到的，父组件传递过来的值，<code>vm._props</code>的值是一个响应式数据，它的属性会被代理到vm上。</p><p><code>initProps</code>无非就是做了这么几件事：</p><ul><li>创建一个空对象，赋给<code>vm._props</code></li><li>使用<code>propsOptions</code>校验<code>propsData</code>，并拿到一个一个的值value</li><li>调用 <code>defineReactive(props, key, value)</code>，将一个一个的值响应式地代理到<code>vm._props</code>上</li><li>调用<code>proxy(vm, &#39;_props&#39;, key)</code>，将<code>vm._props</code>上的值代理到vm上</li></ul><h3 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h3><p>简要源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化自 Vue 2.x 的源代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initMethods</span>(<span class="params">vm, methods</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 开发环境下的一些检查</span></span><br><span class="line">      <span class="comment">// 如果值不是一个函数，则报错</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> methods[key] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has type <span class="subst">$&#123;<span class="keyword">typeof</span> methods[key]&#125;</span> in the component definition.`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果和props上的属性冲突，则报错</span></span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a prop.`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm[key] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">//如果值为空则报错</span></span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; conflicts with an existing Vue instance method.`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将方法绑定到 Vue 实例上</span></span><br><span class="line">    <span class="comment">// bind(methods[key], vm)等价于methods[key].bind(vm)</span></span><br><span class="line">    vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">&#x27;function&#x27;</span> ? noop : <span class="title function_">bind</span>(methods[key], vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出initMethods做的事情是非常简单的，<strong>约等于直接把方法挂载到vm</strong>上。</p><h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  <span class="comment">// 判断data的类型是不是函数，如果是则调用函数，并把返回值赋予局部变量data，同时赋值给vm._data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  .....</span><br><span class="line">  <span class="comment">//获取data中所有可枚举属性</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 属性名不能与methods中的属性名重复</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性名不能与props名称重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123; <span class="comment">// 验证key值的合法性</span></span><br><span class="line">      <span class="comment">// 将vm._data中的key属性，代理到vm上, 这样就可以通过this.key访问到vm._data.key的值（this=vm）</span></span><br><span class="line">      <span class="comment">// 所以说vm._data指向的对象是代理源对象</span></span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 监听data中数据的变化，data中的数据改变会触发视图更新</span></span><br><span class="line">  <span class="comment">// 由第一行代码可知data指的是一个局部变量，它和vm._data指向同一个数据对象，由于添加了数据代理</span></span><br><span class="line">  <span class="comment">// 修改this.key的值也会触发视图更新</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读源码后发现：</p><ul><li><code>props</code>和<code>method</code>在<code>data</code>之前就被初始化了，所以<code>data</code>中的属性值不能与<code>props</code>和<code>methods</code>中的属性值<code>重复</code>；之所以要防止重复，因为它们都会被代理到<code>this(vm)</code>上（是的，包括props中的数据），都是直接通过<code>this</code>来访问，重复了就会产生冲突。同时我们也可以发现，<code>props</code>中的数据的优先级是高于<code>data</code>中的数据的，<strong>因为初始化的时机更早</strong>。</li><li><code>data</code>定义的时候可选择<code>函数形式</code>或者<code>对象形式</code>（组件只能为函数形式），<code>data()</code>函数调用是为了产出数据，挂载到<code>vm._data</code>上，然后再给数据<code>添加代理</code>，<code>添加响应式</code>，所以<code>data</code>函数被调用的时候，内部是无法直接通过<code>this</code>来访问其他数据的。</li><li><code>initData</code>方法把<code>vm._data</code>中的属性代理到<code>vm</code>上并给<code>vm._data</code>上的数据添加了<code>响应式</code>（实现了数据的代理，给数据添了响应式）。</li></ul><p>vue的<strong>数据代理</strong>核心在于<code>proxy</code>方法，我们来看看它做了什么</p><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><strong>proxy</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">target, sourceKey, key</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[sourceKey][key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      target[sourceKey][key] = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span> <span class="comment">// 允许后续删除或重新定义该属性</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br></pre></td></tr></table></figure><p>再次之后，访问<code>target.key</code>返回的就是<code>target.sourceKey.key</code>，说到底还是从<code>target</code>上面取数据，只不过简化了访问的路径。</p><p>vue<strong>给数据添加响应式</strong>的核心在于<code>observe</code>方法，我们来分析一下这个方法</p><h4 id="observe"><a href="#observe" class="headerlink" title="observe"></a><strong>observe</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">  <span class="comment">//如果传入的不是对象或者传入的是null（typeof null返回的也是object）就直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(obj);  <span class="comment">//返回一个Observer实例，这个实例的value属性就是添加了响应式的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observe方法调用<code>new Observer(obj)</code>，并返回</p><h5 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a><strong>Observer</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = obj;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="title function_">def</span>(obj, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)<span class="comment">//this就是observer实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(obj);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;  </span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, key, obj[key]);  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在Observer类的构造器中：</p><ul><li><p>将obj赋给<code>this.value</code></p></li><li><p>创建了Dep实例：这个 <code>Dep</code> 实例<strong>主要是为了处理数组类型的对象，或对象本身作为一个整体被访问的情况</strong>。对于数组，Vue 重写了某些数组方法（如 <code>push</code>, <code>pop</code> 等），以便在调用这些方法时也能够触发依赖的更新，</p></li><li><p><code>def(obj, &#39;__ob__&#39;, this)</code>的作用是，将这个Observer实例，赋给这个<code>obj</code>的<code>__ob__</code>属性，<strong>这样使用<code>obj.__ob__.dep</code>就能管理obj这一整个对象的订阅者。</strong></p></li><li><p>调用<code>this.walk</code>方法，将value转化成响应式数据。在walk方法内部：</p><ul><li><p>调用<code>Object.keys</code>方法获得这个<strong>对象自己的所有可枚举属性</strong></p></li><li><p>然后对每个属性都调用<code>defineReactive</code>方法添加响应式</p></li></ul></li></ul><h5 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, value</span>) &#123;</span><br><span class="line">  <span class="comment">//如果是对象，则递归添加响应式</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observe</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//为每个key创建一个Dep实例</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//触发getter收集依赖，调用dep.depend()方法</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)&#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这里不能写成obj[key]，否则会陷入无限递归，即在get中触发了get</span></span><br><span class="line">      <span class="comment">//返回的是闭包中的value值（也就是函数第三个参数），也就是说再添加getter之前，先把数据取出来</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 修改的是闭包中的value值，并没有直接修改obj中的数据。</span></span><br><span class="line">      <span class="comment">// 修改obj[key]也会陷入无限递归，因为再set中触发了set</span></span><br><span class="line">      <span class="keyword">if</span>(value === val)&#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      value = val</span><br><span class="line">      <span class="comment">//通知依赖更新</span></span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defineReactive</code>方法内部到底做了些什么呢？其实它主要就做了如下工作：</p><ul><li><p>劫持属性，这是通过<code>Object.defineProperty</code>实现的</p></li><li><p>其他逻辑</p><ul><li><p>判断value是不是对象，如果是对象，还要递归添加响应式</p></li><li><p>为每个属性（key）都创建一个<strong>Dep实例</strong>，用来存储这个属性的subs</p></li><li><p>触发getter的时候，调用<code>dep.depend()</code>，进行依赖收集</p></li><li><p>触发setter的时候，调用<code>dep.notify</code>，通知所有订阅者更新</p></li></ul></li></ul><p>在前面的内容中，我们发现在<code>Observer</code>类的构造函数中，还有<code>defineReative</code>函数中，都使用到了<code>Dep</code>类，调用了主要Dep实例的<code>dep.depend</code>，<code>dep.notify()</code>方法，那它到底有什么作用呢？</p><h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a><strong>Dep</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 Watcher 类型和一些工具函数</span></span><br><span class="line"><span class="keyword">import</span> type <span class="title class_">Watcher</span> <span class="keyword">from</span> <span class="string">&#x27;./watcher&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;../config&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span> <span class="comment">// 用于生成 Dep 实例的唯一 ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dep 类是 Vue 响应式系统中的核心部分，它允许多个指令订阅同一个数据属性。</span></span><br><span class="line"><span class="comment"> * 每当数据发生变化时，Dep 将负责通知所有订阅者（Watcher）进行更新。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="comment">// 静态变量，保存当前正在评估的 Watcher 实例。全局唯一，因为同一时间只能有一个 Watcher 在评估。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">target</span>: ?<span class="title class_">Watcher</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">id</span>: number;<span class="comment">// Dep 实例的唯一标识符</span></span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Watcher</span>&gt;;<span class="comment">// 订阅者数组，包含所有监听此依赖的 Watcher 对象，可以理解为一个明星有多少粉丝</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造函数初始化 Dep 实例。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++ <span class="comment">// 分配一个唯一的 ID 给每个 Dep 实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []  <span class="comment">// 初始化订阅者数组为空</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加一个新的订阅者到 Dep 实例中。</span></span><br><span class="line"><span class="comment">   * sub: 新的订阅者（Watcher 实例）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addSub</span> (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub) <span class="comment">// 将新的订阅者添加到订阅者列表中</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从 Dep 实例中移除指定的订阅者。</span></span><br><span class="line"><span class="comment">   * sub :要移除的订阅者（Watcher 实例）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeSub</span> (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub) <span class="comment">// 使用 remove 函数从订阅者列表中移除指定的订阅者</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当某个属性被访问时调用此方法，将当前活跃的 Watcher 添加为该属性的依赖。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">depend</span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123; <span class="comment">// 如果存在当前活跃的 Watcher</span></span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>) <span class="comment">// 将当前 Dep 添加到该 Watcher 的依赖列表中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当属性值（或者对象，数组）发生改变时调用此方法，通知所有订阅者进行更新。</span></span><br><span class="line">  <span class="title function_">notify</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>() <span class="comment">// 复制一份订阅者列表以避免在遍历过程中修改原列表</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不是生产环境且非异步模式下，对订阅者列表进行排序以确保正确的触发顺序</span></span><br><span class="line">      subs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>() <span class="comment">// 遍历并调用每个订阅者的 update 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局静态变量初始赋值为 null，表示当前没有活跃的 Watcher</span></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数组来实现栈结构，用于存储 Watcher 实例</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个 Watcher 实例压入栈中，并设置为当前活跃的 Watcher。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target Watcher 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span> (<span class="params">target: ?Watcher</span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">push</span>(target) <span class="comment">// 将 Watcher 实例加入栈顶</span></span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = target       <span class="comment">// 设置为当前活跃的 Watcher</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从栈中弹出顶部的 Watcher 实例，并恢复上一个活跃的 Watcher。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span> (<span class="params"></span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">pop</span>() <span class="comment">// 移除栈顶元素</span></span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack[targetStack.<span class="property">length</span> - <span class="number">1</span>] <span class="comment">// 恢复上一个活跃的 Watcher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Dep-target"><a href="#Dep-target" class="headerlink" title="Dep.target"></a>Dep.target</h5><p><code>Dep.target</code>表示当前活跃的Watcher实例，同时只能有一个</p><h5 id="subs"><a href="#subs" class="headerlink" title="subs"></a>subs</h5><p>每个dep实例都有唯一的id和subs（订阅者数组，Watcher数组）</p><h5 id="dep-depend"><a href="#dep-depend" class="headerlink" title="dep.depend"></a>dep.depend</h5><p>当响应式数据的getter被触发后，这个方法就会被调用，但是这个方法其实是在调用<code>Dep.target.addDep(this)</code>方法，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">depend</span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123; <span class="comment">// 如果存在当前活跃的 Watcher</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>) <span class="comment">// 将当前 Dep 添加到该 Watcher 的依赖列表中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中传入的this就是dep实例</strong>，说白了就是在调用Watcher实例的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addDep</span> (<span class="attr">dep</span>: <span class="title class_">Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.<span class="property">id</span><span class="comment">//获取dep实例的id</span></span><br><span class="line">  <span class="comment">//如果不是新的dep实例</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)<span class="comment">//push依赖（dep）到Watcher的newDeps数组</span></span><br><span class="line">    <span class="comment">//this.depIds 是 Watcher 实例内部维护的一个 Set 数据结构，用于记录 该 Watcher 所依赖的所有 Dep 实例的 ID。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="comment">//这里的this指向的是Watcher实例</span></span><br><span class="line">      dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)<span class="comment">//然后再调用dep的addSub方法，push订阅者（Watcher）到dep的subs数组</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，<code>dep.depend()</code> 方法通过利用全局变量 <code>Dep.target</code>，在数据读取时建立了 <code>Dep</code>和 <code>Watcher</code>之间的<strong>双向关联。</strong>具体的来说，是Watcher先进行依赖收集，然后deps再收集它的订阅者（<code>Dep.target</code>）</p><h5 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify"></a>dep.notify</h5><p>当响应式数据改变的时候，调用这个方法通知订阅者更新，遍历并调用每个订阅者（Watcher）的 <strong>update</strong> 方法</p><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a><strong>Watcher</strong></h4><p>dep的订阅者是Watcher，dep类似现实生活中的明星，Watcher就是它们的粉丝，一个dep可以有多个Wather（一个明星可以有多个粉丝），一个Watcher也可以有多个dep(一个粉丝还可以喜欢其他多个明星)，那Watcher是如何工作的呢？</p><p>大致源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// 属性定义...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, expOrFn, cb, options, isRenderWatcher</span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数：初始化 watcher</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; ... &#125;             <span class="comment">// 获取值并收集依赖</span></span><br><span class="line">  <span class="title function_">addDep</span>(<span class="params">dep</span>) &#123; ... &#125;       <span class="comment">// 添加依赖</span></span><br><span class="line">  <span class="title function_">cleanupDeps</span>(<span class="params"></span>) &#123; ... &#125;     <span class="comment">// 清理旧依赖</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123; ... &#125;          <span class="comment">// 数据变化后调用，准备更新</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123; ... &#125;             <span class="comment">// 真正执行更新</span></span><br><span class="line">  <span class="title function_">evaluate</span>(<span class="params"></span>) &#123; ... &#125;        <span class="comment">// 懒加载求值（用于 computed）</span></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123; ... &#125;          <span class="comment">// 通知依赖进行依赖收集</span></span><br><span class="line">  <span class="title function_">teardown</span>(<span class="params"></span>) &#123; ... &#125;        <span class="comment">// 销毁 watcher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>Watcher 类有点长，我们先来看<strong>构造函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component,               <span class="comment">// Vue类/组件 实例</span></span></span><br><span class="line"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,  <span class="comment">// 字符表达式或函数</span></span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,                <span class="comment">// 回调函数，收到更新通知时执行</span></span></span><br><span class="line"><span class="params">    options?: ?<span class="built_in">Object</span>,           <span class="comment">// 其他选项</span></span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean    <span class="comment">// 是否为渲染 watcher</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123; <span class="comment">// 如果是渲染 watcher，对象赋值给 vm._watcher</span></span><br><span class="line">      vm.<span class="property">_watcher</span> = <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm.<span class="property">_watchers</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>) <span class="comment">// 对象放入 vm 的 _watchers 中</span></span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = !!options.<span class="property">deep</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sync</span> = !!options.<span class="property">sync</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">before</span> = options.<span class="property">before</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//默认不是深度监听，默认不是用户自定义Wacther，默认不是懒更新，默认是异步</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = <span class="variable language_">this</span>.<span class="property">user</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> = <span class="variable language_">this</span>.<span class="property">sync</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = ++uid <span class="comment">// uid for batching // 实例ID</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">true</span> <span class="comment">//Watcher是否是激活状态，一般都是激活状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化 dirty = lazy，主要用于计算属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []     <span class="comment">// 当前观察的 dep</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []  <span class="comment">// 新收集的需要观察的 dep</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()     <span class="comment">// deps 的ID集合</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()  <span class="comment">// newDeps 的ID集合</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expression</span> = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      ? expOrFn.<span class="title function_">toString</span>()</span><br><span class="line">      : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// 获取getter函数</span></span><br><span class="line">    <span class="comment">// expOrFn 转成 getter 函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = noop</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是 lazy 的 watcher（如果不是计算属性watcher） 则立即执行 get 成员方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span></span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数接收几个参数：</p><ul><li><code>vm</code>: 当前 Vue 实例</li><li><code>expOrFn</code>: 要监听的内容，可以是一个字符串 <code>&#39;a.b.c&#39;</code> 或一个函数</li><li><code>cb</code>: 数据变化时要执行的回调函数</li><li><code>options</code>: 可选配置项（如 deep、lazy、sync）</li><li><code>isRenderWatcher</code>: 是否是渲染 watcher（也就是用来更新视图的那个）</li></ul><p>在<strong>构造函数</strong>中主要做了这么几件事情：</p><ul><li><p>根据options初始化属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">deep</span> = !!options.<span class="property">deep</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">sync</span> = !!options.<span class="property">sync</span></span><br></pre></td></tr></table></figure><p>这里 <code>!!</code> 的作用就是把任意值转换成布尔值，防止传进来的是数字、字符串等类型。如果未配置对应属性，则取默认值<code>false</code>。</p></li><li><p>判断是否是渲染 watcher：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">  vm.<span class="property">_watcher</span> = <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是渲染 watcher（即更新视图的 watcher），就把这个 watcher 存到 <code>vm._watcher</code> 上，方便后面更新视图时直接使用。</p></li><li><p>把当前 watcher 加入实例的 <code>_watchers</code> 数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">_watchers</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure><p><code>vm._watchers</code>，是一个数组，存放这个组件中所有的 watcher：</p><ul><li>渲染 watcher（1个）</li><li>用户通过 <code>$watch</code> 添加的 watcher（多个）</li><li>computed 属性对应的 watcher（多个）</li></ul></li><li><p>设置getter函数</p></li><li><p>调用get方法</p></li></ul><h5 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h5><p>getter函数的作用就是<strong>访问响应式数据，触发依赖收集(dep.depend)，并返回一个值value</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>expOrFn</code>是函数的时候，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span></span><br><span class="line">&#125;, cb)</span><br></pre></td></tr></table></figure><p>那么 <code>this.getter</code> 就是这个函数本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">getter</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>expOrFn</code>是字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, <span class="string">&#x27;a.b.c&#x27;</span>, cb)</span><br></pre></td></tr></table></figure><p>Vue 内部会调用 <code>parsePath(&#39;a.b.c&#39;)</code> 把它转换成一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">getter</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 等价于：return this.a.b.c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不管<code>expOrFn</code>是函数还是字符串路径，最后都会变成一个能从vm取值并返回的函数，这就是 <code>getter</code></strong></p><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> ? <span class="literal">undefined</span> : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br></pre></td></tr></table></figure><p>如果不是 lazy watcher（不是计算属性Watcher），就立即执行一次 <code>get()</code> 方法，收集依赖并保存初始值。</p><p>创建除了计算属性<code>Watcher</code>以外的所有Watcher时，都会调用<code>get</code>函数，其实<code>get</code>方法不仅会再构造函数中被调用，还会在<code>run</code>方法中被调用。</p><p><strong>get函数</strong>到底是什么，它做了什么事情？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dep类中的代码</span></span><br><span class="line"><span class="comment">// 定义一个数组来实现栈结构，用于存储 Watcher 实例</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"><span class="comment">//将一个 Watcher 实例压入栈中，并设置为当前活跃的 Watcher。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span> (<span class="params">target: ?Watcher</span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">push</span>(target) <span class="comment">// 将 Watcher 实例加入栈顶</span></span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = target       <span class="comment">// 设置为当前活跃的 Watcher</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span> (<span class="params"></span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">pop</span>() <span class="comment">// 移除栈顶元素</span></span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack[targetStack.<span class="property">length</span> - <span class="number">1</span>] <span class="comment">// 恢复上一个活跃的 Watcher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span> () &#123;</span><br><span class="line">  <span class="comment">// 设置当前 watcher 为目标</span></span><br><span class="line">  <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)  </span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)  <span class="comment">// 执行 getter，返回一个值，并触发依赖收集（会调用dep.depend方法）</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) <span class="title function_">traverse</span>(value)  <span class="comment">// 深度监听对象/数组内部变化</span></span><br><span class="line">    <span class="title function_">popTarget</span>()                     <span class="comment">//  this.getter可能触发多个依赖收集，所有依赖收集完毕后，再结束依赖收集</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()              <span class="comment">// 清理不再需要的依赖</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上述代码，我们可以得知<code>get</code>方法无非就做了这么几件事：</p><ul><li>调用<code>pushTarget(this)</code> ，<strong>把当前Watcher（调用get方法的Watcher）设置为target</strong>（ Dep.target &#x3D; this）</li><li>调用getter方法<strong>更新value</strong>触发依赖收集， <code>Dep.target</code>就会被deps收集到subs里</li><li>所有依赖收集结束后，调用<code>popTarget()</code> 修改Dep.target，<strong>结束依赖收集</strong>。</li></ul><p>简而言之，<strong>get能确保当前Watcher的所有依赖，都能收集到这个Watcher，同时还会返回最新的值</strong></p><h5 id="update"><a href="#update" class="headerlink" title="update"></a><strong>update</strong></h5><p>当响应式数据修改，会触发setter，调用<code>dep.notify</code>方法通知所有<code>Watcher</code>更新，遍历调用Watcher的update方法，那么这个方法做了什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">update</span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span>  <span class="comment">// 计算属性标记为脏，下次再重新计算</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>()         <span class="comment">// 同步执行更新</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>) <span class="comment">// 加入异步队列更新（优化性能）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="run"><a href="#run" class="headerlink" title="run"></a><strong>run</strong></h5><p>在update方法中，调用<code>run()</code> 执行的是真正的更新过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">run</span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;<span class="comment">// 如果 watcher 是激活状态，大部分情况下都是激活状态</span></span><br><span class="line">    <span class="comment">//也就是说，每次run几乎都会触发this.get()， 每次都会调用getter</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">get</span>()<span class="comment">// 获取新值并重新收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">//值真的变了 → 需要执行回调</span></span><br><span class="line">      <span class="comment">//如果是对象或数组，即使地址没变（值没变），内容可能被修改了（Vue 可以追踪这种变化）→ 需要执行回调</span></span><br><span class="line">      <span class="comment">//如果开启了深度监听（如 &#123; deep: true &#125;），即使对象地址没变，也认为内部可能变了 → 需要执行回调</span></span><br><span class="line">      <span class="comment">//这三个条件只要满足任意一个，就会执行回调！</span></span><br><span class="line">      value !== <span class="variable language_">this</span>.<span class="property">value</span> ||<span class="title function_">isObject</span>(value) ||<span class="variable language_">this</span>.<span class="property">deep</span></span><br><span class="line">    ) &#123;<span class="comment">//如果满足上述条件，还会执行回调函数cb</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span><span class="comment">//存储旧的值,等于Watcher.value</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value<span class="comment">// 更新当前值</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;<span class="comment">//用户定义的watcher，就是通过watch配置的，自定义的watcher</span></span><br><span class="line">        <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">        <span class="comment">//执行回调函数（带错误处理）</span></span><br><span class="line">        <span class="title function_">invokeWithErrorHandling</span>(<span class="variable language_">this</span>.<span class="property">cb</span>, <span class="variable language_">this</span>.<span class="property">vm</span>, [value, oldValue], <span class="variable language_">this</span>.<span class="property">vm</span>, info)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//执行回调函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可得知，<code>run</code>方法无非就做了这么几件事：</p><ul><li>调用<code>get</code>更新当前值（this.value），这意味着会调用<code>getter</code></li><li>执行回调函数cb（如果满足判断条件）</li></ul><p><strong>3大类Watcher</strong></p><p>每个Watcher都有value，getter，get，cb，update，run属性。Watcher又可分为三类，<strong>渲染Watcher，计算属性 Watcher，用户自定义Watcher</strong>。为什么Watcher只有这3类，因为响应式数据，通常只在，<strong>模板，计算属性，watch</strong>中被使用。</p><p>这三类Watcher的<strong>value，getter和cb</strong>分别是什么情况呢？首先我们可以看看这三类Watcher是在哪里，如何被创建的。</p><h5 id="渲染Watcher"><a href="#渲染Watcher" class="headerlink" title="渲染Watcher"></a>渲染Watcher</h5><h6 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h6><p>渲染 Watcher在<code>mountComponent</code>（后面会介绍）方法中被创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">  updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     .....</span><br><span class="line">     <span class="comment">//调用_update方法将虚拟dom转化成真实dom并放入页面</span></span><br><span class="line">     vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">     .....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">      <span class="title function_">before</span> () &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">          <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br></pre></td></tr></table></figure><ul><li><p>可以看到第5个参数 为 <code>true /* isRenderWatcher */</code>； 说明是渲染watcher；</p></li><li><p>在 <code>new Watcher(vm, updateComponent, noop, &#123; ... &#125;, true)</code> 中，<code>updateComponent</code> 是第二个参数，那么它应该是 <code>expOrFn</code>，最终会赋值给<code>this.getter</code>；</p></li><li><p><code>cb</code>是<code>noop</code>，就是空回调函数的意思。对于渲染Watcher来说，没有实际的回调函数<code>cb</code></p></li></ul><p>既然**<code>updateComponent</code>是渲染Watcher的getter<strong>，那它是如何</strong>触发依赖收集的**？返回值又是什么？</p><h6 id="render-1"><a href="#render-1" class="headerlink" title="_render"></a>_render</h6><p>我们先来看看updateComponent中调用的<code>_render</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置当前渲染上下文</span></span><br><span class="line">  vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里执行了 render 函数</span></span><br><span class="line">    vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回虚拟节点</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了这么几件事：</p><ul><li>从vm.$options中拿到准备好的render函数（render函数由模板解析得到）</li><li>调用render函数并返回得到的VNode</li></ul><blockquote><p>补充：<code>vm.$createElement</code>就是我们常说的 <code>createElement</code> 方法。render方法其实就是使用createElement来创建VNode</p></blockquote><p>render方法中会访问响应式数据（如 <code>this.age</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>, <span class="comment">// 根元素 div</span></span><br><span class="line">    [ <span class="comment">// 子节点数组</span></span><br><span class="line">      <span class="title function_">createElement</span>(<span class="string">&#x27;Child&#x27;</span>, &#123; <span class="comment">// 子组件 Child，绑定 props.age</span></span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">          <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span> <span class="comment">// 传递父组件的 age 属性</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 按钮元素，绑定 click 事件</span></span><br><span class="line">      <span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">on</span>: &#123;</span><br><span class="line">          <span class="attr">click</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(<span class="string">&#x27;age&#x27;</span>) <span class="comment">// 触发 add(&#x27;age&#x27;) 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="string">&#x27;age++&#x27;</span>)<span class="comment">//&#x27;age++&#x27;是标签体内容</span></span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用render方法 →响应式数据被访问 → 触发 getter → 收集依赖<strong>，因此<code>updateComponent</code>是一个规范的getter，它确实能触发依赖收集</strong></p><h6 id="update-1"><a href="#update-1" class="headerlink" title="_update"></a>_update</h6><p>调用完render方法得到VNode后，还会调用<code>_update</code>方法，将虚拟DOM转化成真实DOM。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法有2个形参vnode, hydrating</span></span><br><span class="line"><span class="comment">//第一个是最新的VNode，第二个是一个布尔值，表示是否复用服务端渲染的DOM</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">  vm.<span class="property">_vnode</span> = vnode<span class="comment">//更新实例的虚拟DOM</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// 初次渲染</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新阶段</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>vm.__patch__</code>就是我们常说的<strong>patch</strong>方法，在后面的<strong>diff算法</strong>中有介绍。它的作用是：</p><ul><li>首次渲染时：把虚拟 DOM 转换成真实 DOM，其实就是<code>createEle</code>方法，并挂载到页面</li><li>更新时：对比新旧虚拟 DOM，进行高效的 Diff 算法，只更新变化的部分</li></ul><ul><li>从中可以看出update方法并没有返回值（或者说返回值是undefined），这就意味着<code>updateComponent</code>方法没有返回值，这就意味着渲染Watcher的<code>getter</code>没有返回值，这就意味着<code>渲染Watcher</code>的value始终是<code>undefined</code>，<strong>也就是说，渲染Watcher的value不重要</strong></li></ul><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h6><ul><li><p>渲染Watcher没有cb，只有getter；而且getter没有返回值，<strong>说明渲染Watcher的value不重要，更新后只触发getter</strong></p></li><li><p>如果响应式数据在模板中被使用，当<strong>创建渲染Watcher的时候</strong>（组件初次挂载），会在<strong>构造函数</strong>中调用<code>this.get</code>方法:</p><ul><li><code>this.get</code>内部会调用<code>pushTarget(this)</code> ，<strong>将渲染Watcher设置为target</strong>（将渲染Watcher赋给<code>Dep.target</code>）</li><li>再调用<code>this.getter</code>方法，也就是<code>updateComponent</code>方法。</li><li>updateComponent方法内部会<strong>调用render方法</strong>，访问响应式数据，触发getter：调用<code>dep.depend()</code>方法，其在内部调用<code>Dep.target.addDep(this)</code>方法，让渲染Watcher订阅dep</li><li>addDep方法内部调用dep.addSub(this)，让dep收集渲染Watcher到subs。</li><li>调用完render方法，收集好依赖，返回虚拟DOM后，<code>updateComponent</code>还会调用update方法，将虚拟DOM转化成真实DOM</li></ul></li><li><p>我们可以得出结论：</p><ul><li><strong>创建渲染Watcher的时候，渲染Watcher会被赋给Dep.target</strong></li><li><strong>我们常常说的render，在创建渲染Watcher的时候会被调用</strong>，后续渲染Watcher调用run方法，也会调用<code>get-&gt;getter-&gt;render</code>方法</li><li><strong>render函数执行的时候会触发依赖收集，render函数被调用的时候，就是渲染Watcher被dep收集的时候</strong></li><li>render方法只在<code>this.get</code>中被调用，而渲染Watcher调用get方法的时候，就会将渲染Watcher赋给Dep.target，所以<strong>调用render方法的时候，deps收集的Watcher一定是渲染Watcher</strong></li></ul></li><li><p>当响应式数据改变，调用<code>dep.notify()</code>，遍历所有Watcher，调用它们的<code>update</code>方法，最终会调用它们的<code>run</code>方法：</p><ul><li>run方法内部会再次调用<code>this.get()</code>方法，其内部会调用<code>pushTarget(this)</code> ，将渲染Watcher设置为target（将渲染Watcher赋给Dep.target）</li><li><code>this.get()</code>方法内部还会调用<code>this.getter</code>方法，对渲染Watcher来说，也就是调用<code>updateComponent</code>方法，这个方法内部会<strong>调用<code>render</code>方法</strong></li><li>render方法再次访问响应式数据，根据最新的值，创建新的VNode；由于已经收集过依赖，所以再次访问响应式数据不会重复收集依赖。</li><li>调用完render方法，返回新的VNode后，updateComponent还会调用update方法，将虚拟DOM转化成真实DOM，这里就涉及到diff算法了。</li></ul></li></ul><p>简单的来说，在vue中，数据改变，视图更新，是因为调用了渲染Watcher的<code>update</code>方法，这个方法将<code>渲染Watcher</code>放入<code>异步更新队列</code>（后续在this.$nextTick原理中会介绍）。在微任务阶段清空异步更新队列，调用队列中所有Watcher的run方法。当调用渲染Watcher的run方法，run方法会调用<code>get-&gt;getter</code>方法（也就是updateComponent方法），getter方法中会调用render方法创建新的VNode，再调用patch方法根据新旧虚拟DOM更新DOM，DOM更新了，视图就更新了。</p><h5 id="计算属性Watcher"><a href="#计算属性Watcher" class="headerlink" title="计算属性Watcher"></a>计算属性Watcher</h5><h6 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h6><p>计算属性的配置方式，有2种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Computing fullName&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fullName2</span>: &#123;</span><br><span class="line">    	<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      	  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting fullName&#x27;</span>);</span><br><span class="line">      	  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    	&#125;,</span><br><span class="line">    	<span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">          <span class="comment">//不能直接修改计算属性，尝试修改计算属性会修改计算属性的依赖</span></span><br><span class="line">      	  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Setting fullName&#x27;</span>);</span><br><span class="line">      	  <span class="keyword">const</span> names = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      	  <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>];</span><br><span class="line">      	  <span class="variable language_">this</span>.<span class="property">lastName</span> = names[<span class="number">1</span>];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h6><p>计算属性Watcher在<code>initComputed</code>的时候被创建，<code>initComputed</code>在<code>initState</code>函数中被调用，我们来看看<code>initComputed</code>做了什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm.<span class="property">_computedWatchers</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="comment">// 如果computed[key]是函数，则直接用来当作计算属性Watcher的getter，否则将computed[key].get作为getter</span></span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="property">get</span></span><br><span class="line">    <span class="comment">// 为每一个计算属性，创建一个 computed watcher</span></span><br><span class="line">    watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">      vm,</span><br><span class="line">      getter,</span><br><span class="line">      noop,<span class="comment">//计算属性Watcher也没有实际的回调函数cb，noop就是一个空函数</span></span><br><span class="line">      &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;  <span class="comment">// 关键点：lazy 表示懒执行，不立即求值</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 定义响应式属性</span></span><br><span class="line">    <span class="title function_">defineComputed</span>(vm, key, userDef)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看<code>initComputed</code>到底<strong>做了什么</strong>：</p><ul><li><p>遍历每个计算属性，在给每个计算属性创建Watcher之前，先确定每个计算属性的getter。拿到每个计算属性的value，如果这个value是一个函数，则直接把它作为计算属性Watcher的<code>getter</code>，否则把<code>value.get</code>作为<code>getter</code>，无论如何，得到的<code>getter</code>的格式形如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，计算属性的getter的主要作用是<strong>求值</strong>，由于访问了响应式属性还会触发<strong>依赖收集</strong></p></li><li><p>确定好<code>getter</code>之后，<strong>为每个计算属性创建一个Watcher</strong>，并存储在<code>vm._computedWatchers[key]</code>中，从代码中可以看出，计算属性Watcher也没有实际的回调函数<code>cb</code>，它的<code>cb</code>是一个空函数(noop)，<strong>说明计算属性Watcher的cb不重要</strong>。</p></li><li><p>对于 计算属性（computed） 来说，它对应的 Watcher 有两个<strong>特殊标志</strong>：</p><ul><li><p>lazy：表示是否延迟求值（即不立即调用 <code>get()</code> 方法获取值）</p></li><li><p>dirty：表示当前值是否是“脏”的（需要重新计算）</p></li><li><p>因为计算属性Watcher的lazy属性为true，这就是意味着，创建计算属性Watcher的时候，并不会立即调用<code>this.get</code>方法取值，也就不会触发收集依赖。<strong>只有在模板或其他地方访问它的时候才会真正去求值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span> (<span class="params"></span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span>? <span class="attr">undefined</span>: <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建完计算属性的Watcher后，调用defineComputed方法</p></li></ul><h6 id="defineComputed"><a href="#defineComputed" class="headerlink" title="defineComputed"></a>defineComputed</h6><p>我们再来看看<code>defineComputed</code>到底做了什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助变量和函数</span></span><br><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noop,</span><br><span class="line">  <span class="attr">set</span>: noop</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noop</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineComputed</span> (<span class="params">target, key, userDef</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = <span class="literal">true</span>; <span class="comment">// 在 Vue 2 中 computed 默认都支持缓存</span></span><br><span class="line">  <span class="keyword">const</span> isFunction = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span>; <span class="comment">// 判断用户定义的是函数还是对象形式</span></span><br><span class="line">  <span class="comment">// 定义 getter</span></span><br><span class="line">  <span class="keyword">if</span> (isFunction) &#123;<span class="comment">//如果userDef是函数</span></span><br><span class="line">    <span class="comment">//调用createComputedGetter得到计算属性的getter</span></span><br><span class="line">    <span class="comment">//如果userDef是函数。说明一定没有定义set</span></span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = <span class="title function_">createComputedGetter</span>(key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不是函数，但是有get方法，则还是调用createComputedGetter得到计算属性的getter</span></span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = userDef.<span class="property">get</span></span><br><span class="line">      ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">      : noop;</span><br><span class="line">    <span class="comment">//如果定义了set，直接赋给sharedPropertyDefinition.set</span></span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = userDef.<span class="property">set</span> || noop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 Object.defineProperty 把计算属性代理到 vm 上</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，defineComputed的最终目的是，<strong>使用Object.defineProperty把计算属性代理到vm上方便访问的</strong>，但是在这之前，还需要确定计算属性的<strong>get和set</strong>：</p><ul><li>计算属性的<code>get</code>等于<code>createComputedGetter (key)</code></li><li>计算属性的<code>set</code>等于<code>userDef.set</code> ，如果没有配置set，则set为noop，空函数。</li></ul><p><strong>要注意的是，计算属性虽然会被代理到vm上，就像一般响应式数据一样，但是计算属性没有自己的dep</strong></p><h6 id="createComputedGetter"><a href="#createComputedGetter" class="headerlink" title="createComputedGetter"></a>createComputedGetter</h6><p>我们来看看<code>createComputedGetter</code>是如何构造计算属性的<code>get</code>的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 computed 属性的 getter 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComputedGetter</span> (<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">computedGetter</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//先查找是否存在对应的watcher</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="variable language_">this</span>.<span class="property">_computedWatchers</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_computedWatchers</span>[key];</span><br><span class="line">    <span class="comment">//如果没有找到直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (!watcher) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到计算</span></span><br><span class="line">    <span class="comment">// 如果是 dirty 的，就重新求值</span></span><br><span class="line">    <span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">      watcher.<span class="title function_">evaluate</span>();<span class="comment">//在这个过程中，会触发依赖收集，计算属性Watcher会被dep收集为订阅者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集依赖：将当前 Dep.target（渲染 watcher）添加到该 computed watcher 的依赖中</span></span><br><span class="line">    <span class="comment">// 主要做的是一个依赖收集的工作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      watcher.<span class="title function_">depend</span>();<span class="comment">//这段代码也是一个依赖收集的工作，让计算属性Watcher的dep也收集渲染Watche为订阅者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是dirty的，就直接返回缓存的值</span></span><br><span class="line">    <span class="comment">// 如果是dirty，则先重新求知后再返回</span></span><br><span class="line">    <span class="comment">// 可以看出返回的值是计算属性watcher存储的值</span></span><br><span class="line">    <span class="keyword">return</span> watcher.<span class="property">value</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createComputedGetter会立即返回一个具名函数computedGetter，在computedGetter 函数的内部，<strong>或者说计算属性get的内部</strong>，是这样工作的：</p><ul><li><p>先在<code>this._computedWatchers</code>中查找当前key（计算属性）是否存在对应的watcher，不存在直接退出</p></li><li><p>找到计算属性的Watcher后，根据<code>Watcher.dirty</code>属性判断计算属性是否是脏的，如果是，则调用<code>watcher.evaluate()</code></p></li><li><p>如果有Watcher正在收集依赖，则调用<code>watcher.depend()</code>方法</p></li><li><p>最后，返回<code>watcher.value</code>。这就说明，<strong>计算属性的get返回的值，本质就是对应的计算属性<code>watcher.value</code><strong>，而<code>watcher.value</code>的更新，则是由<code>watcher.get</code>负责的，</strong>要把计算属性的get和计算属性Watcher的get区分开来啊</strong>。确定计算属性的set就没那么麻烦了，如果自己定义了set，直接就当作计算属性的set。</p></li></ul><p>来看看<code>watcher.evaluate()</code>具体做了什么?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Watcher的 evaluate 简要源码如下</span></span><br><span class="line"><span class="title function_">evaluate</span> () &#123;</span><br><span class="line">  <span class="comment">// 重新取值，把计算结果缓存下来，这里的this指向计算属性Watcher</span></span><br><span class="line">  <span class="comment">// 因为 get 还会调用 pushTarget 方法，也就是说哪个Watcher调用get方法，哪个Watcher就会被dep收集</span></span><br><span class="line">  <span class="comment">// 在这里计算属性Watcher会被dep收集</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span> <span class="comment">//标记为“干净”，下次访问时如果依赖未变，就直接返回缓存值，不再重新计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它无非就做了2件事：</p><ul><li>调用计算属性的get方法，计算新的值并收集依赖</li><li>修改this.dirty为false</li></ul><p>get方法的内部，会将当前计算属性Watcher赋给Dep.target，然后调用getter，类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问响应式数据，于是<strong>计算属性Watcher被dep收集到dep.subs</strong>，这是第一次依赖收集</p><p><code>watcher.depend()</code>做了什么，还要此时的Dep.target为什么是渲染Watcher？</p><ul><li><p>如果<strong>模板中使用了计算属性</strong>，于是在<code>组件首次挂载-&gt;创建渲染Watcher-&gt;调用get方法-&gt;将渲染Watcher设置为Dep.target-&gt;render函数</code>的时候，就会访问计算属性，触发计算属性的<code>get</code></p></li><li><p>由于计算属性初始是<code>dirty</code>的，所以首次触发计算属性的<code>get</code>，会调用<code>watcher.evaluate()</code>，进而调用<code>watcher.get()</code>，<strong>进行计算属性Watcher的依赖收集。</strong></p></li><li><p>计算属性Watcher的依赖收集结束后，<code>Dep.target</code>切换为渲染Watcher，为什么是渲染Watcher？创建渲染Watcher的时候，在构造函数内会调用<code>this.get</code>方法：</p><ul><li>这个方法内部，渲染Watcher会赋给<code>Dep.target</code></li><li>然后再调用<code>this.getter</code>，这个方法内部会调用<code>render</code>函数，当访问到计算属性，触发计算属性的get，于是调用计算属性watcher的evaluate方法，然后就回到了先前的分析了。</li></ul></li><li><p>然后调用<code>watcher.depend</code>方法，遍历计算属性Watcher的所有依赖(dep)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Watcher的 depend 简要源码如下</span></span><br><span class="line"><span class="title function_">depend</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">  <span class="comment">//遍历计算属性的所有依赖，调用它们的depned方法</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">depend</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用它们的depend方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dep的depend方法</span></span><br><span class="line"><span class="title function_">depend</span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123; <span class="comment">// 如果存在当前活跃的 Watcher</span></span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>) <span class="comment">// 将当前 Dep 添加到该 Watcher 的依赖列表中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的来说，在访问计算属性时，**<code>watcher.depend()</code> 会让渲染 Watcher 去订阅计算属性所依赖的底层数据的 <code>dep</code>，而计算属性 Watcher 本身也是这些 dep 的订阅者。因此，这些 dep 的 <code>subs</code> 列表中会同时包含计算属性 Watcher 和渲染 Watcher。**</p></li><li><p>这么做的效果就是，如果某个计算属性在模板中使用了，当其某个依赖的改变后，会同时通知计算属性Watcher更新和渲染Watcher更新；</p><ul><li><p>对于计算属性Watcher，调用update方法，只会修改dirty属性为true，不进行实际的更新操作；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">update</span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span>  <span class="comment">// 计算属性标记为脏，下次再重新计算</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>()         <span class="comment">// 同步执行更新</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>) <span class="comment">// 加入异步队列更新（优化性能）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是对于渲染Watcher，调用update方法回将其放入异步更新队列。然后在微任务阶段，清空异步更新队列的时候，调用渲染Watcher的<code>run-&gt;get-&gt;getter-&gt;render</code>方法，从计算属性中取值，触发计算属性的<code>getter</code>：</p><ul><li>调用<code>watcher.evaluate()</code>方法（watcher是从<code>this._computedWatchers</code>中找到的），<code>watcher.evaluate()</code>内部会调用<code>this.get()</code>获取新的值，并将dirty更新为false，</li><li>最后再返回最新的值。</li></ul><p>然后调用<code>update-&gt;patch-&gt;patchVNode</code>方法给DOM打补丁，更新视图。</p></li></ul></li></ul><h5 id="用户自定义Watcher"><a href="#用户自定义Watcher" class="headerlink" title="用户自定义Watcher"></a>用户自定义Watcher</h5><h6 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">message</span>(<span class="params">newVal, oldVal</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message changed from &#x27;</span> + oldVal + <span class="string">&#x27; to &#x27;</span> + newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">news</span>:&#123;</span><br><span class="line">       <span class="title function_">handler</span>(<span class="params">newVal, oldVal</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始值是:&#x27;</span>, newVal);</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="initWatcher"><a href="#initWatcher" class="headerlink" title="initWatcher"></a>initWatcher</h6><p>用户自定义Watcher在<code>initWatch</code>的时候被创建，而initWatch在initState方法中被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initWatch简要源码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initWatch</span> (<span class="params">vm: Component, watch: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="comment">//为watcher中的每个属性都创建一个Watcher</span></span><br><span class="line">    <span class="comment">//通常走这步</span></span><br><span class="line">     <span class="title function_">createWatcher</span>(vm, key, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createWatcher</span> (<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  expOrFn: string | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  handler: any,</span></span><br><span class="line"><span class="params">  options?: <span class="built_in">Object</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, expOrFn, handler, <span class="title function_">mergeOptions</span>(&#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="literal">true</span></span><br><span class="line">  &#125;, options))<span class="comment">//其中expOrFn是一个key，即字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上述代码，我们能得到以下结论：</p><ul><li><p><strong>watch配置对象中的每一个属性都会创建一个Watcher</strong>，这一点就非常像计算属性Watcher</p></li><li><p>用户自定义Watcher的<code>expOrFn</code>，就是watch配置对象的key（一个字符串），<strong>也就是说自定义Watcher的getter是需要通过转化得到的</strong>，cb通常就是<code>watch.key</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getter</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用户自定义Watcher的<code>user</code>属性为true</p></li><li><p>因为自定义Watcher的lazy属性不为true，所以创建自定义Watcher的时候，就会依次调用：<code>get -&gt; getter</code>，调用<code>getter</code>方法会访问响应式数据，从而触发依赖收集。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">   <span class="title function_">message</span>(<span class="params">newVal, oldVal</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message changed from &#x27;</span> + oldVal + <span class="string">&#x27; to &#x27;</span> + newVal);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，<code>message</code>对应的自定义Watcher，就会被<code>this.message</code>属性收集为subs（订阅者）。</p></li><li><p>用户自定义Watcher区别于前面2类Watcher，它有自己的<code>cb</code>，是用户定义的，当自定义Watcher的依赖更新后，用户自定义的Watcher就会调用<code>update-&gt;run</code>方法，然后在<code>run</code>方法中调用<code>cb</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;<span class="comment">//用户定义的watcher，就是通过watch配置的，自定义的watcher</span></span><br><span class="line">  <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">  <span class="comment">//执行回调函数（带错误处理），并传入参数</span></span><br><span class="line">  <span class="title function_">invokeWithErrorHandling</span>(<span class="variable language_">this</span>.<span class="property">cb</span>, <span class="variable language_">this</span>.<span class="property">vm</span>, [value, oldValue], <span class="variable language_">this</span>.<span class="property">vm</span>, info)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//执行回调函数，并传入参数</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们自定义Watch的时候还能拿到新旧值，这说明对于用户自定义Watcher，它的value也是有意义的。</p></li></ul><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table><thead><tr><th>Watcher 类型</th><th>update() 是否调用 run()?</th><th>是否有回调 cb?</th><th>如何处理更新</th></tr></thead><tbody><tr><td>渲染 Watcher</td><td>✅ 是</td><td>❌ 否（内部机制处理更新）</td><td>放入队列，最终调用 <code>run()</code> 更新视图</td></tr><tr><td>用户 Watcher（watch 选项）</td><td>✅ 是</td><td>✅ 是</td><td>放入队列，调用 <code>run()</code> 执行回调</td></tr><tr><td>计算属性 Watcher</td><td>❌ 否</td><td>❌ 否</td><td>仅标记为 <code>dirty = true</code>，下次访问时重新计算</td></tr></tbody></table><p>vue的构造函数中使用的挂载方法是<code>vm.$mount</code>，我们尝试分析它的源码：</p><h3 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a>vm.$mount</h3><img src="..\images\前端面试-vue\vue挂载3.png" style="zoom:67%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el?: string | Element,hydrating?: boolean</span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 如果目标元素存在，捕获它，得到它的dom</span></span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line">  <span class="comment">// vue不允许直接挂载到body或着html上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//提取出options，后续使用不需要通过this</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">  <span class="comment">//如果没有render属性,也就是说没有render函数,解析 template/el 并转换为 render 函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="comment">//如果配置对象中没有render，则提取出template</span></span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">    <span class="comment">// 存在template模板，解析vue模板文件</span></span><br><span class="line">    <span class="comment">// 第一个if主要是为了处理template属性的另类值，比如id选择器，dom对象，最终都是为了转换成模板字符串</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//如果template是字符串，但是是id选择器</span></span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">//将id选择转化成模板</span></span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line">          .....</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;<span class="comment">//这个条件语句用于检查 template是 是一个 DOM节点对象</span></span><br><span class="line">        <span class="comment">//返回的是一个字符串，代表了template元素内部的 HTML 内容，将他作为模板</span></span><br><span class="line">        template = template.<span class="property">innerHTML</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        .....</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">// 如果没有template属性，通过选择器获取元素内容（即获取tempalte）</span></span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//此时template的值如果存在，一定是HTML字符串的形式，比如&#x27;&lt;p&gt;123&lt;/p&gt;&#x27;</span></span><br><span class="line">    <span class="comment">//然后再进行模板编译，得到渲染函数</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">        <span class="comment">//省略.....</span></span><br><span class="line">      &#125;, <span class="variable language_">this</span>)</span><br><span class="line">      options.<span class="property">render</span> = render</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line">      .......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">mountComponent</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读上面代码，我们发现<code>vm.$mount</code>无非是那么几件事</p><ul><li><p>判断el属性是否为空，如果非空，则捕获对应的dom，然后判断这个dom是不是<code>body</code>或者<code>html</code>，如果是则报错</p></li><li><p>判断配置对象中是否存在<code>render</code>函数，如果存在，则直接调用<code>mountComponent</code>方法</p></li><li><p>如果没有<code>render</code>函数，则尝试生成这个函数：</p><ul><li><p>判断配置对象中是否有<code>template</code>属性，我们期望是一个html字符串，但如果这个字符串是id选择器，我们则获取对应的html结构作为模板字符串（<code>idToTemplate</code>）。</p></li><li><p>实际还可能是dom对象，我们把这个dom对象的<code>innerHTML</code>作为模板</p></li><li><p>如果既没有<code>render</code>也没有<code>template</code>，那就必须有<code>el</code>，通过<code>getOuterHTML(el)</code>得到的值来充当<code>template</code>，包括了元素本身以及其内部的所有 HTML 内容。</p></li><li><p><strong>无论如何，最终<code>template</code>属性的值是一个html字符串</strong></p></li><li><p>解析，编译模板字符串，得到<code>render</code>函数，挂载到配置对象<code>options</code>上，再调用<code>mountComponent</code>开始开始渲染</p></li></ul></li></ul><p><strong>概括的来说，vm.$mount就做了2件事情，准备render函数，调用mountComponent方法。</strong></p><h3 id="mountComponent-1"><a href="#mountComponent-1" class="headerlink" title="mountComponent"></a>mountComponent</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  el: ?Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="comment">//这个传入的 DOM 元素（el）就是组件将来要挂载到的位置。</span></span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 如果没有获取解析的render函数，则会抛出警告，render是解析模板文件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">	....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行beforeMount钩子</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">//调用_render方法生成vnode</span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">//调用_update方法将虚拟dom转化成真实dom并放入页面</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定义更新函数</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建渲染Watcher</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    <span class="title function_">before</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据更新引发的组件更新</span></span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  <span class="comment">//vm.$vnode` 是组件实例上的一个属性，表示该组件在父组件 VNode 树中的描述节点（即父组件中创建的组件 VNode）</span></span><br><span class="line">  <span class="comment">//在父组件的render函数中会给子组件创建组件 VNode，这个 VNode 会赋值给子组件的 `$vnode` 属性</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最终返回创建好的组件实例</span></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mountComponent无非就是做了这么几件事</p><ul><li>先判断 <code>vm.$options.render</code>是否存在，如果不存在的话就让它等于 <code>createEmptyVNode</code>。</li><li>执行beforeMount钩子</li><li>准备好updateComponent，创建渲染Watcher</li></ul><p>从上述代码中可以看出，在beforeMount钩子被调用的时候，模板已经编译完毕，render函数已经准备好了，不过还没有被调用。</p><ul><li>render函数准备好</li><li>调用beforeMount</li><li>调用render函数生成虚拟dom</li><li>调用update函数将虚拟dom转化成真实dom挂载到<code>vm.$el</code></li><li>调用mounted方法</li></ul><p>在创建渲染Watcher的时候，在构造函数中，updateComponent会立即执行，也就是说会调用<code>_render</code>函数；再调用<code>_update</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">//提取出render函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置当前渲染上下文</span></span><br><span class="line">  vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里执行了 render 函数</span></span><br><span class="line">    vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回虚拟节点</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法有2个形参vnode, hydrating</span></span><br><span class="line"><span class="comment">//第一个是最新的VNode，第二个是一个布尔值，表示是否复用服务端渲染的DOM</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">  vm.<span class="property">_vnode</span> = vnode<span class="comment">//更新实例的虚拟DOM</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// 初次渲染</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新阶段</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>vm.__patch__</code>就是我们常说的<strong>patch</strong>方法，在后面的<strong>diff算法</strong>中有介绍。它的作用是：</p><ul><li>首次渲染时：把虚拟 DOM 转换成真实 DOM，其实就是<code>createEle</code>方法，并挂载到页面</li><li>更新时：对比新旧虚拟 DOM，进行高效的 Diff 算法，只更新变化的部分</li></ul><h2 id="Vue组件通信的方式有哪些"><a href="#Vue组件通信的方式有哪些" class="headerlink" title="Vue组件通信的方式有哪些"></a>Vue组件通信的方式有哪些</h2><p><code>vue</code>中，每个组件之间的都有<code>独自的作用域</code>，组件间的数据是无法共享的，但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的，要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。</p><h3 id="组件间通信的分类"><a href="#组件间通信的分类" class="headerlink" title="组件间通信的分类"></a>组件间通信的分类</h3><ul><li>父子组件之间的通信</li><li>兄弟组件之间的通信</li><li>祖孙与后代组件之间的通信</li><li>非关系组件间之间的通信</li></ul><h3 id="组件间通信的方案"><a href="#组件间通信的方案" class="headerlink" title="组件间通信的方案"></a>组件间通信的方案</h3><h4 id="props传递数据"><a href="#props传递数据" class="headerlink" title="props传递数据"></a>props传递数据</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>适用场景：父组件传递数据给子组件，即父子组件之间的通信</p><p>父组件通过给子组件标签添加属性，来传递值，子组件设置<code>props</code>属性，接收父组件传递过来的参数，同时还能限制父组件传递过来的数据的类型，还能设置默认值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">name</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">age</span>=<span class="string">18</span> /&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Children.vue</span></span><br><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line"> <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line"> <span class="comment">// 对象形式  </span></span><br><span class="line"> <span class="attr">age</span>:&#123;    </span><br><span class="line">     <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">     <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">     <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><strong>props中的数据是父组件的，子组件不能直接修改，遵循”谁的数据谁来维护”的原则</strong>。</li><li>子组件标签的所有属性中，未被子组件接收（props中未声明）的数据，也能在<code>this.$attr</code>，即<code>组件实例的属性</code>中拿到，因为未被接受的属性，就会被当作组件自身的普通属性。</li></ul><h5 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h5><p>再问大家一个问题，<strong>为什么父组件中的数据更新，子组件中通过<code>props</code>接收的数据也会随之改变，子组件视图也会更新？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;span&gt;age:&#123;&#123;age&#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Child&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    age: Number</span><br><span class="line">  &#125;,</span><br><span class="line">  updated()&#123;</span><br><span class="line">    console.log(&#x27;更新了&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;      </span><br><span class="line">    &lt;!-- 向子组件传递一个基本数据类型 --&gt;</span><br><span class="line">    &lt;Child :age=&quot;age&quot;&gt;</span><br><span class="line">    &lt;/Child&gt;</span><br><span class="line">    &lt;button @click=&quot;add(&#x27;age&#x27;)&quot;&gt;age++&lt;/button&gt;  </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;@/components/Child.vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      age:1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">      this.age++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>父组件的模板，在模板编译的时候，会被解析成一个<code>render</code>函数</strong>，这一点我们在前面已经介绍过了，在上述例子中，父组件的模板解析成<code>render</code>函数大概是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>, <span class="comment">// 根元素 div</span></span><br><span class="line">    [ <span class="comment">// 子节点数组</span></span><br><span class="line">      <span class="title function_">createElement</span>(<span class="string">&#x27;Child&#x27;</span>, &#123; <span class="comment">// 子组件 Child，绑定 props.age</span></span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">          <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span> <span class="comment">// 传递父组件的 age 属性</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 按钮元素，绑定 click 事件</span></span><br><span class="line">      <span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">on</span>: &#123;</span><br><span class="line">          <span class="attr">click</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(<span class="string">&#x27;age&#x27;</span>) <span class="comment">// 触发 add(&#x27;age&#x27;) 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="string">&#x27;age++&#x27;</span>)<span class="comment">//&#x27;age++&#x27;是标签体内容</span></span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>createElement</code>方法是用来创建VNode的，render方法返回的其实就是虚拟DOM，这一点和React中完全相同</li><li>调用父组件的模板<code>render</code>函数时，访问了父组件实例的<code>age</code>属性，赋值给子组件的<code>props.age</code>，这个过程中触发<code>age</code>属性的<code>getter</code>，<strong>于是收集父组件自身的<code>render</code>函数为依赖</strong>（就是渲染Watcher）</li><li>调用父组件的模板<code>render</code>函数，遇到子组件标签时，会调用<code>createElement</code>方法，根据子组件的配置，创建子组件的VNode（这部分内容前面介绍过） ，然后再将子组件VNode转化成真实DOM的时候，会调用子组件构造函数，其会调用<code>initProps</code>方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的第二个参数，是子组件中的props属性的值（props配置对象）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initProps</span>(<span class="params">vm, propsOptions</span>) &#123;</span><br><span class="line">  <span class="comment">//拿到子组件声明并接收到的所有props数据（不包括普通标签属性）</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.<span class="property">$options</span>.<span class="property">propsData</span> || &#123;&#125;;</span><br><span class="line">  <span class="comment">//创建一个空对象，挂载到组件实例_props属性上</span></span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">_props</span> = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历props配置对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">// 使用propsOptions校验propsData</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm);</span><br><span class="line">    <span class="comment">// 组件接收的属性，会被添加到vm._props上，并添加响应式</span></span><br><span class="line">    <span class="title function_">defineReactive</span>(props, key, value);</span><br><span class="line">    <span class="comment">// 代理到实例（this），然后就能直接通过this访问</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">&#x27;_props&#x27;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父组件传递了，且子组件通过<code>props</code>接收的数据，会被存储在<code>vm.$options.propsData</code></li><li>子组件初始化的时候（调用<code>initProps</code>的时候），会将通过<code>props</code>接收的数据，添加响应式，并代理到<code>vm</code>上，缩短访问路径。</li></ul><p>上述例子中，父组件传递给子组件的值，只不过是<code>this.age</code>，是一个普通数据类型，压根不是响应式数据，这种传递会导致响应式丢失，触发<code>getter</code>的位置，也是在父组件渲染函数内，子组件压根就没被<code>age</code>属性收集为依赖，后续是子组件自己把<code>age</code>属性添加到<code>vm._props</code>并添加响应式的（后续又代理到vm）。</p><p>既然在父组件的<code>age</code>属性并<strong>没有收集子组件Watcher为订阅者</strong>，为什么父组件更新age属性，子组件视图也会更新呢？</p><ul><li><p>当父组件中的<code>age</code>属性改变，会触发对应的<code>setter</code>，然后通知依赖更新，<strong>其中的依赖就包括父组件渲染Watcher</strong></p></li><li><p>父组件<code>渲染Watcher</code>最终会调用<code>run</code>方法，这个方法会调用<code>render</code>函数，创建<strong>新的组件vnode</strong>（props的值是新的）</p></li><li><p>在patchVnode阶段，更新组件实例，修改子组件的<code>_props</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (<span class="params">oldVnode, vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否是组件 VNode</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRealComponent</span>(vnode)) &#123;</span><br><span class="line">    <span class="comment">// 组件 VNode 有自己的一套 prepatch 流程</span></span><br><span class="line">    <span class="keyword">const</span> prevComponent = oldVnode.<span class="property">componentInstance</span>;</span><br><span class="line">    <span class="keyword">const</span> hook = vnode.<span class="property">data</span>?.<span class="property">hook</span>;</span><br><span class="line">    <span class="keyword">if</span> (hook &amp;&amp; hook.<span class="property">prepatch</span>) &#123;</span><br><span class="line">      <span class="comment">//这是 Vue 内部定义的一个钩子函数，用于处理组件更新逻辑</span></span><br><span class="line">      hook.<span class="title function_">prepatch</span>(oldVnode, vnode); <span class="comment">//在这里调用 updateChildComponent</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不是组件VNode的时候的处理逻辑</span></span><br><span class="line">  <span class="comment">//..........</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">prepatch</span>(<span class="params">oldVnode, vnode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = vnode.<span class="property">componentOptions</span>;</span><br><span class="line">    <span class="keyword">const</span> childInstance = vnode.<span class="property">componentInstance</span> = oldVnode.<span class="property">componentInstance</span>;</span><br><span class="line">    <span class="comment">// 👇 更新 props、listeners、插槽等</span></span><br><span class="line">    <span class="title function_">updateChildComponent</span>(</span><br><span class="line">      childInstance,</span><br><span class="line">      vnode.<span class="property">propsData</span>,</span><br><span class="line">      vnode.<span class="property">listeners</span>,</span><br><span class="line">      vnode,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateChildComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  propsData: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  listeners: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  parentVnode: VNode,</span></span><br><span class="line"><span class="params">  renderChildren: ?<span class="built_in">Array</span>&lt;VNode&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span>;</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> oldProps = vm.<span class="property">_props</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">const</span> prop = props[key];</span><br><span class="line">      <span class="keyword">const</span> newVal = <span class="title function_">validateProp</span>(key, props, propsData, vm);</span><br><span class="line">      <span class="keyword">const</span> oldVal = oldProps[key];</span><br><span class="line">      <span class="keyword">if</span> (newVal !== oldVal) &#123;</span><br><span class="line">        vm.<span class="property">_props</span>[key] = newVal; <span class="comment">// 👈 更新 props</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新监听器和插槽...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于<code>this._props</code>是响应式的，所以会自动触发视图更新。</p></li></ul><p>简单的来说，父组件修改传递给子组件的数据，子组件视图也会更新，**是因为父组件内部重新调用了render方法，创建了新的组件Vnode，然后在patchVnode的时候，会更新组件实例的<code>_props</code>属性(<code>this._props</code>)**。</p><p>流程：父组件修改数据 → 触发重新渲染（render）→ 创建新的组件 VNode → 在 <code>patchVnode</code> 阶段触发组件的 <code>prepatch</code> 钩子 → 调用 <code>updateChildComponent</code> → 更新子组件 <code>_props</code> → 子组件视图更新。</p><p>参考文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/53218851">【Vue原理】Props - 白话版 - 知乎</a></p><h4 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h4><p>适用场景：子组件传递数据给父组件(父子组件通信)</p><p>子组件通过<code>$emit</code>触发自定义事件，<code>$emit</code>第一个参数为自定义的事件名，第二个参数为传递给父组件的数值</p><p>父组件在子组件上绑定事件监听，通过传入的<code>回调函数</code>拿到子组件的传过来的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Children.vue</span><br><span class="line">this.$emit(&#x27;add&#x27;, good)  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Father.vue</span><br><span class="line">&lt;Children @add=&quot;cartAdd&quot; /&gt;  </span><br></pre></td></tr></table></figure><p>要注意的是，给组件添加的事件监听是<strong>自定义事件</strong>，因为组件标签不是原生标签，无法添加原生事件监听，也就没有原生事件对象，所以传递给回调函数的是子组件传递过来的值，而不是原生dom事件。</p><p>在vue2中，我们只要给父组件传递数据，并给对应的属性添加<code>sync</code>修饰符，就能省去在给组件标签添加事件监听，书写回调逻辑，同步父组件数据的代码，在vue3中，这一功能则是通过<code>v-mode</code>l实现的，更多介绍参考本博客内的《vue》一文。</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>在 Vue 2 中，<code>this.$refs</code> 是一个对象，它包含了所有通过 <code>ref</code> 属性注册的 <code>DOM 元素</code>或<code>组件实例</code>。可以使用 <code>this.$refs</code> 来直接访问这些dom元素或组件实例，从而进行操作，如获取DOM节点、调用子组件实例的方法，获取数据等。</p><p><strong>注意：</strong><code>this.$refs</code> 只能在父组件中，用来引用通过 <code>ref</code> 属性标记的<code>子组件</code>或 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> ref=<span class="string">&quot;foo&quot;</span> /&gt;  </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">foo</span>  <span class="comment">// 获取子组件实例，通过子组件实例我们就能拿到对应的数据  </span></span><br></pre></td></tr></table></figure><p>同时，子组件也可通过<code>this.$parent</code>拿到父组件实例</p><h4 id="EventBus-事件总线"><a href="#EventBus-事件总线" class="headerlink" title="EventBus(事件总线)"></a><strong>EventBus(事件总线)</strong></h4><p>使用场景：兄弟组件传值</p><ul><li><p>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信</p><p>兄弟组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>,<span class="variable language_">this</span>.<span class="property">add</span>)   </span><br></pre></td></tr></table></figure><p>另一个兄弟组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="title function_">emit</span>(<span class="string">&#x27;add&#x27;</span>) <span class="comment">//注意的是，这里不是$emit</span></span><br></pre></td></tr></table></figure></li></ul><p>本质就是要找到一个<strong>两个兄弟组件都能访问到的vue实例</strong>，在这个实例上注册事件监听，同时也在这个实例上触发事件，本质和emit是一样的（父组件在子组件实例上添加事件监听，子组件通过自己的实例（this）调用emit方法）。这个vue实例的作用好像连接这两个组件的管道，通过这个Vue实例来通行。</p><h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><h5 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h5><p>跨层级传递数据，传递方向是<strong>单向</strong>的，只能顶层向底层传递。</p><p>在<code>祖先组件</code>定义<code>provide</code>属性，<code>返回</code>传递的值，在后代组件通过<code>inject</code>，接收祖先组件传递过来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类型是响应式的复杂类型则不是，这和vue2数据响应式的实现方式（递归添加响应式）有关</span></span><br><span class="line"><span class="comment">// 这里丢失响应式的原因，和解构响应式对象失去响应式的原因是一样的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="comment">// 普通类型（非响应式）</span></span><br><span class="line">      <span class="attr">userInfo</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125; <span class="comment">// 复杂类型（响应式）</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//使用data或者computed中的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">color</span>, <span class="comment">// 非响应式，因为this.color的值只是个普通类型</span></span><br><span class="line">      <span class="attr">userInfo</span>: <span class="variable language_">this</span>.<span class="property">userInfo</span>, <span class="comment">// 响应式，因为this.userInfo的值是个对象，而vue中对象是递归添加响应式的</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 如果多个祖先组件都提供了同名的属性，那么最接近的祖先组件提供的属性，会被优先使用（就近原则）。</span></span><br><span class="line">	<span class="attr">inject</span>: [<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;userInfo&#x27;</span>],</span><br><span class="line">	<span class="title function_">created</span> () &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>, <span class="variable language_">this</span>.<span class="property">userInfo</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="深入理解-1"><a href="#深入理解-1" class="headerlink" title="深入理解"></a><strong>深入理解</strong></h5><p>如果父组件通过<code>Provide</code>传递的是一个基本数据类型，在子组件内接收了，后续即便父组件修改这个基本数据类型，子组件也不会更新，为什么？但如果父组件通过<code>Provide</code>传递的是一个对象，这一情况就完全不同？</p><p>我们先看看initProvide的源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initProvide</span>(<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> provide = vm.<span class="property">$options</span>.<span class="property">provide</span></span><br><span class="line">  <span class="keyword">if</span> (provide) &#123;</span><br><span class="line">    vm.<span class="property">_provided</span> = <span class="keyword">typeof</span> provide === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">      ? provide.<span class="title function_">call</span>(vm)<span class="comment">//使用vm调用provide函数</span></span><br><span class="line">      : provide</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>initProvide</code>的源码非常简单：</p><ul><li>如果组件定义了Provide属性，且值是一个函数，则使用<code>call(vm)</code>调用这个函数，确保this指向准确。</li><li>最后将函数调用的返回值赋给<code>vm._provided</code>属性。</li></ul><p>再看看<code>initInjections</code>的源码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/inject.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initInjections</span>(<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">resolveInject</span>(vm.<span class="property">$options</span>.<span class="property">inject</span>, vm); <span class="comment">// 解析 inject 配置，拿到对应的值</span></span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>); <span class="comment">// 关闭深度响应式观察</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(result).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">defineReactive</span>(vm, key, result[key]); <span class="comment">// 设置为响应式</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">true</span>); <span class="comment">// 恢复深度响应式观察</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolveInject 函数逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveInject</span>(<span class="params">inject: any, vm: Component</span>): ?<span class="title class_">Object</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (inject) &#123;</span><br><span class="line">    <span class="comment">//创建一个空对象result，用来存储对应的值</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(inject);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = keys[i];</span><br><span class="line">      <span class="keyword">const</span> provideKey = inject[key].<span class="property">from</span>;</span><br><span class="line">      <span class="keyword">let</span> source = vm;</span><br><span class="line">      <span class="comment">//双重循环，每个key都向上查找祖先组件是否provide对应的值</span></span><br><span class="line">      <span class="keyword">while</span> (source) &#123;</span><br><span class="line">        <span class="comment">//如果这个祖先组件实例有_provided属性（也就是provide了值），且source._provided中提供了特定的值</span></span><br><span class="line">        <span class="keyword">if</span> (source.<span class="property">_provided</span> &amp;&amp; <span class="title function_">hasOwn</span>(source.<span class="property">_provided</span>, provideKey)) &#123;</span><br><span class="line">          <span class="comment">// 找到匹配的 provide 值，直接取出来然赋给result[key]</span></span><br><span class="line">          result[key] = source.<span class="property">_provided</span>[provideKey]; </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没找到，继续向上查找父组件</span></span><br><span class="line">        source = source.<span class="property">$parent</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果在所有祖先组件中都没找到，但设置了默认值</span></span><br><span class="line">      <span class="keyword">if</span> (!source &amp;&amp; <span class="string">&quot;default&quot;</span> <span class="keyword">in</span> inject[key]) &#123;</span><br><span class="line">        <span class="comment">// 未找到时使用默认值</span></span><br><span class="line">        <span class="keyword">const</span> provideDefault = inject[key].<span class="property">default</span>;</span><br><span class="line">        <span class="comment">// 如果默认值是函数，则指定vm调用这个函数</span></span><br><span class="line">        result[key] = <span class="keyword">typeof</span> provideDefault === <span class="string">&quot;function&quot;</span>? provideDefault.<span class="title function_">call</span>(vm): provideDefault;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!source &amp;&amp; process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Injection &quot;<span class="subst">$&#123;key&#125;</span>&quot; not found`</span>, vm);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initInjections</code>无非就是做了这么几件事：</p><ul><li><p><strong>从祖先元素取值</strong>：调用 <code>resolveInject(vm.$options.inject, vm)</code>，向上查找祖先组件的 <code>provided</code> 属性，找到匹配的 <code>provide</code> 值，最终返回以一个<code>result</code>对象。大致步骤如下：</p><ul><li><p>创建一个空对象result，遍历inject配置对象中的每个属性，从当前组件实例开始：</p><ul><li><p>检查这个组件实例是否提供了对应的值，如果提供了，则把这个值取出来，存到result中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result[key] = source.<span class="property">_provided</span>[provideKey]</span><br></pre></td></tr></table></figure></li><li><p>如果没有找到，则继续去下一个祖先元素中查找，类似原型链查找</p></li><li><p>如果在所有祖先元素中都没有找到，则检查<code>inject[key]</code>中是否提供的默认值，如果提供了则使用默认值，存到result中</p></li><li><p>如果默认值都没提供，则直接报错</p></li></ul></li></ul></li><li><p><strong>代理到组件实例上并添加响应式</strong>：使用 <code>defineReactive(vm, key, value)</code> 将result上的属性<strong>代理到vm上并添加为响应式</strong>，但 <strong>不进行深度响应式处理</strong>（即嵌套对象的属性不会被劫持）。</p></li></ul><p>ok，分析完源码后，我们来尝试解决开始提到的问题</p><ul><li><p>所以说，即便父组件<code>Provide</code>的值被修改了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//使用data或者computed中的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">color</span>, <span class="comment">// 非响应式，因为this.color的值只是个普通类型</span></span><br><span class="line">      <span class="attr">userInfo</span>: <span class="variable language_">this</span>.<span class="property">userInfo</span>, <span class="comment">// 响应式，因为this.userInfo的值是个对象，而vue中对象是递归添加响应式的</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如<code>this.color</code>修改了 ，也并不会重新<code>Provide</code>这个值，所以如果父组件通过<code>Provide</code>传递的是一个基本数据类型（比如this.color），在子组件内接收了，后续即便父组件修改这个基本数据类型，子组件实例vm上的color也不会改变。</p></li><li><p>但是如果父组件通过<code>Provide</code>传递的，是一个对象，<strong>由于在vue中响应式是递归添加的，所以这个对象是个响应式对象</strong>，而且由于传递的是一个引用，其实父子组件是<strong>共用这个响应式对象</strong>的，如果子组件中在模板中使用了这个对象，则子组件的渲染Watcher会被它收集为依赖，这样即便在父组件内修改这个对象，在子组件的视图也会更新。</p></li></ul><h5 id="与props的比较"><a href="#与props的比较" class="headerlink" title="与props的比较"></a>与props的比较</h5><p>在vue2中，inject的写法和props的写法完全相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组写法</span></span><br><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;theme&#x27;</span>]</span><br><span class="line"><span class="comment">//对象写法</span></span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">inject</span>: &#123;</span><br><span class="line">  <span class="attr">theme</span>: <span class="title class_">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//高级写法</span></span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">inject</span>: &#123;</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">name</span>: <span class="string">&#x27;Guest&#x27;</span> &#125;),</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件给子组件通过传递props传递的数据，就是<code>vm.$options.propsData</code>，本身也不是个响应式对象，父组件provide的数据，也不是一个响应式的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">createElement</span>(<span class="string">&#x27;Child&#x27;</span>, &#123; <span class="comment">// 子组件 Child，绑定 props.age</span></span><br><span class="line">     <span class="attr">props</span>: &#123;</span><br><span class="line">       <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">     &#125;<span class="comment">//这部数据就是propsData</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//使用data或者computed中的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">color</span>, <span class="comment">// 非响应式，因为this.color的值只是个普通类型</span></span><br><span class="line">      <span class="attr">userInfo</span>: <span class="variable language_">this</span>.<span class="property">userInfo</span>, <span class="comment">// 响应式，因为this.userInfo的值是个对象，而vue中对象是递归添加响应式的</span></span><br><span class="line">    &#125;;<span class="comment">//返回的对象就是vm._provided，也就是提供的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们本身都类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">color</span>, </span><br><span class="line">   <span class="attr">userInfo</span>: <span class="variable language_">this</span>.<span class="property">userInfo</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>也就是父组件从自己身上取值，然后存到一个对象身上，在这个取值的过程，其实是会丢失响应式的</strong>，但如果取出的是一个对象，比如userInfo，由于在vue中响应式是递归添加的，所以这个对象userInfo还是个响应式对象。</p><ul><li><p>通过props传值的时候，由于是在模板中使用响应式数据，父组件的响应式数据会收集父组件的渲染Watcher为订阅者，但是通过provide传值，真的就只是传了一个值（前面介绍过）</p></li><li><p>后续<code>initProps</code>，子组件会把<code>propsData</code>上的数据代理到<code>vm._props</code>上并添加响应式，最终代理vm上方便访问。通过vm直接访问props接收的数据，数据源是<code>vm._props</code>，而<code>vm._props</code>的数据源是闭包中（defineReactive）的一个一个<code>value</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = vm.<span class="property">_props</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">// 使用propsOptions校验propsData</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm);</span><br><span class="line">    <span class="comment">// 组件接收的属性，会被添加到vm._props上，并添加响应式</span></span><br><span class="line">    <span class="title function_">defineReactive</span>(props, key, value);</span><br><span class="line">    <span class="comment">// 代理到实例（this），然后就能直接通过this访问</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">&#x27;_props&#x27;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后续<code>initInjections</code>，子组件从祖先组件的<code>vm._provided</code>上取值，并存储到<code>result</code>对象上，由于<code>result</code>单纯是浅拷贝一些祖先组件上<code>_provide</code>的值，<strong>所以result对象也是一个普通的对象</strong>，后续把result上的数据直接代理到vm上并添加响应式。直接通过vm访问inject的数据，数据源也是闭包中的数据<code>result[key]</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(result).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">defineReactive</span>(vm, key, result[key]); <span class="comment">// 设置为响应式</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>也就是说，通过props或者inject接收的数据，最终都会代理到vm上方便访问，且都会变成响应式的</strong></p></li><li><p>通过props传递的即便是一个基本数据类型，在父组件中修改了，子组件视图也会更新；因为会调用父组件的render方法，创建新的组件VNode，然后再<code>patchVNode</code>阶段，更新组件实例的<code>_props</code>，由于<code>_props</code>是响应式的，所以能触发子组件视图更新。</p></li><li><p>但是如果通过provide传递一个基本数据类型，在父组件中修改了，子组件视图也不会更新。<strong>因为不会触发子组件的更新过程</strong>。</p></li></ul><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>关于vuex的介绍，详见<a href="http://www.sanye.blog/posts/8b27fabc.html">vue | 三叶的博客</a></p><h2 id="谈谈对el和template属性的理解"><a href="#谈谈对el和template属性的理解" class="headerlink" title="谈谈对el和template属性的理解"></a>谈谈对el和template属性的理解</h2><p>当我们在学习Vue的基础语法，vue的组件的时候一定涉及到了这两个容易混淆的属性。</p><ul><li><p>创建Vue根实例必须要给出el属性，指明要为哪个容器服务，这个容器会成为<strong>模板</strong>；创建组件实例<strong>不能</strong>传入el属性，<strong>简单的来说，el属性是Vue根实例独有的</strong>。</p></li><li><p>虽然el属性是vue根实例独有的，但它也不是什么优先级很高的东西，如果创建<strong>vue根实例</strong>同时配置了el和template属性，则template将<strong>替换el</strong>指定的容器（拜拜了el），成为模板(可以参考<code>vm.$mount</code>源码，template属性优先级更高)</p></li><li><p>不过要注意的是nodejs开发环境中，通过<code>import</code>导入的<code>vue</code>是精简版的，<strong>没有模板解析器的</strong>，模板解析器被单独提取出来，作为一个开发环境的包，只在打包的时候发挥作用，**只用来处理<code>.vue</code>文件中的<code>template</code>**，不会包含到最终文件中，从而减小最终文件的体积。所以在创建vue根实例的时候不能使用<code>template</code>，因为打包后的文件中已经没有模板解析器了，所以无法借助它实现在页面中自动插入<code>&lt;App&gt;&lt;/App&gt;</code>的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;App&gt;&lt;/App&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123;<span class="title class_">App</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码会报错，不能配置<code>template</code></p><p>应当修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">render</span>:<span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)<span class="comment">//传入的h是createElement函数，用来创建VNode</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者引入完整版的vue.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue/dist/vue.js&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>创建组件必须指定组件的结构，即template，组件的模板，不必指定组件为哪个容器服务（不要el）</p></li><li><p>el指定的容器中的<code>结构</code>可以被抽离为一个一个单独的模板<code>template</code>，一个个单独的组件，也就是说模板中可以不写实际结构，只写组件标签，这些组件标签会在模板解析的时候被解析。</p></li><li><p>其实组件中的<code>template</code>也能被拆分，从而形成一个一个组件，这就是组件的嵌套。</p></li></ul><h2 id="说说Vue的生命周期"><a href="#说说Vue的生命周期" class="headerlink" title="说说Vue的生命周期"></a><strong>说说Vue的生命周期</strong></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>vue的生命周期指的是<strong>vue实例</strong>从创建到销毁的过程，可分为vue实例初始化前后，dom挂载前后，数据更新前后，vue实例销毁前后四个阶段。这四个阶段分别对应了<code>8</code>个生命周期函数。生命周期函数指的是在vue实例特定时间段执行的函数。</p><h3 id="Vue2中的生命周期函数"><a href="#Vue2中的生命周期函数" class="headerlink" title="Vue2中的生命周期函数"></a>Vue2中的生命周期函数</h3><ul><li>beforeCreate：vue实例刚被创建，能拿到this，部分初始化工作完成，但是<strong>数据代理</strong>还未开始(未调用<code>initState</code>方法)，此时无法通过this方法<strong>data和methods等</strong></li><li>created: 此时几乎所有配置属性比如inject，data，method，computed，props，watch，provide都初始化完成，但是<strong>模板解析（是为了得到render函数，render函数是用来创建虚拟dom的）</strong>还未开始（未调用<code>vm.$mount</code>方法），页面展示的是<strong>未经vue编译的dom</strong>。</li><li>beforeMount：<strong>template模板已经解析结束，render函数创建完毕</strong>，但是render函数还未调用，还没生成虚拟dom，此时展示的还是旧的页面（未经编译的页面）</li><li>mounted：此时render函数已经被调用，而且虚拟 DOM 已转换为真实 DOM，挂载到页面上，此时对DOM的操作是有效的。</li><li>beforeUpdate：此时数据是新的，页面展示的内容是旧的，<strong>因为vue视图是异步更新的</strong>，关于异步更新这一点，可以参考后文《说说你对nextTick的理解》</li><li>updated: 此时<code>新旧虚拟dom比较</code>完毕，页面已更新。</li><li>beforeDestroy：当执行beforeDestroy的钩子的时候，Vue实例就已经从运行阶段进入销毁阶段，但身上所有的data和methods，以及过滤器、指令等，都处于可用状态，还未真正执行销毁的过程</li><li>destroyed: 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器；并不能清除DOM，仅仅销毁实例。所以页面并不会改变，但是变得无法响应交互。</li></ul><h3 id="深入理解-2"><a href="#深入理解-2" class="headerlink" title="深入理解"></a>深入理解</h3><p><strong>数据请求在created和mouted的区别</strong></p><ul><li>这两个阶段<code>数据</code>和<code>方法</code>都已经初始化，都能通过<code>this</code>访问到，因为<code>created</code>的执行时期更早，所以能更早的发送请求，更快的返回数据。</li><li>一个组件中有子组件，它们的生命周期函数的执行顺序是先执行父组件的前三个声明周期函数，再执行子组件的前四个生命周期函数，然后在执行哦父组件的<code>mouted</code>函数。</li></ul><p><strong>对于存在子组件的情况，为什么先执行父组件的<code>created</code>钩子，再执行子组件的<code>created</code>，<code>mounted</code>钩子，最后再执行父组件的<code>mounted</code>钩子</strong></p><ul><li>在创建父组件实例的时候，在调用完<code>initState</code>之后，就会调用父组件的<code>created</code>钩子</li><li>然后在<code>mountComponent</code>中，创建父组件的<strong>渲染Watcher</strong>的时候，就会调用render方法，<strong>创建父组件的VNode</strong></li><li>在父组件的render方法中，还会调用<code>createComponent</code>方法创建子组件的<code>VNode</code>，<strong>子组件的Vnode中挂载了子组件的构造函数</strong></li><li>然后调用<code>patch</code>方法，<strong>递归将父组件的<code>VNode</code>转化成真实<code>DOM</code><strong>，并挂载到指定的DOM元素上；在这一过程中，对于父组件VNode中包含的子组件VNode，会</strong>调用子组件的构造函数</strong>，开启子组件的构建流程，<strong>因此会调用子组件的<code>created</code>，<code>mounted</code>钩子</strong>。</li><li>然后调用父组件的<code>mounted</code>钩子</li></ul><p>对于vue3中的生命周期的介绍，参考《vue》一文。</p><h2 id="说说你对vue双向绑定的理解"><a href="#说说你对vue双向绑定的理解" class="headerlink" title="说说你对vue双向绑定的理解"></a>说说你对vue双向绑定的理解</h2><p><code>双向绑定</code>不等同于<code>响应式</code>了，这两个东西是有区别的。</p><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>当更改<code>响应式数据</code>时，视图会随即<code>自动更新</code>，关于响应式如何实现，参考《说说Vue实例挂载过程中发生了什么》其中有详细的介绍。</p><p>和生命周期函数的联系：</p><ul><li>如果一个组件内的某个响应式属性没有任何依赖，即便修改这个响应式属性，也不会触发组件的<code>beforeUpdate，updated</code>钩子</li><li><code>updated</code> 只在<strong>组件自身的 DOM 或子组件的 DOM 被重新渲染</strong>后才会触发，简单的来说，只有<strong>视图</strong>更新了，<code>beforeUpdate，updated</code>才会触发，后者说，<code>beforeUpdate，updated</code>指的就是视图更新前后。</li><li>如果修改的数据未影响到模板中的任何部分（例如只是修改了一个未被使用的变量），则不会触发<code>beforeUpdate，updated</code></li></ul><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>双向绑定，是<strong>数据变化驱动视图更新，视图更新触发数据变化</strong>。其实就是<code>v-model</code>的功能，而我们知道<code>v-model</code>只是一个语法糖。因此如果要问双向绑定的原理，思路应该是<strong>如何实现这个语法糖</strong>。其原理是把<code>input</code>的value绑定data的一个值，当原生input的事件触发时，用事件的值来更新data的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 v-model --&gt;</span><br><span class="line">&lt;input v-model=&quot;message&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 编译后的等效代码 --&gt;</span><br><span class="line">&lt;input :value=&quot;message&quot; @input=&quot;e =&gt; &#123;message = e.target.value&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue-observable你有了解过吗？说说看"><a href="#Vue-observable你有了解过吗？说说看" class="headerlink" title="Vue.observable你有了解过吗？说说看"></a>Vue.observable你有了解过吗？说说看</h2><p><code>Vue.observable</code>，让一个对象变成响应式数据。<code>Vue</code> 内部会用它来处理 <code>data</code> 函数返回的对象</p><p>在 <code>Vue 2.x</code> 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，它和被返回的对象是同一个对象，不过在原来的基础上添加了响应式，这一点，看看前面对<code>defineReactive</code>方法的介绍就很容易理解了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj,key,obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj,key,value</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">observe</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,key,&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)&#123;</span><br><span class="line">                dep.<span class="title function_">addDep</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">val</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(val===value)&#123;</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">           &#125;</span><br><span class="line">           val = value</span><br><span class="line">           dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Vue 3.x</code> 中，则会返回一个可响应的代理对象，而对源对象直接进行变更仍然是不可响应的，因为在vue3中响应式的实现是基于<code>Proxy</code>这个构造函数，传入一个对象，会返回一个<code>新的</code>代理对象，对代理对象的修改会映射到源对象。</p><p><strong>使用场景</strong></p><p>创建一个<code>js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue</span></span><br><span class="line"><span class="string">// 创建state对象，使用observable让state对象可响应</span></span><br><span class="line"><span class="string">export let state = Vue.observable(&#123;</span></span><br><span class="line"><span class="string">  name: &#x27;</span>张三<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">  &#x27;</span>age<span class="string">&#x27;: 38</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>在<code>.vue</code>文件中直接使用即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    姓名：&#123;&#123; name &#125;&#125;</span><br><span class="line">    年龄：&#123;&#123; age &#125;&#125;</span><br><span class="line">    &lt;button @click=&quot;changeName(&#x27;李四&#x27;)&quot;&gt;改变姓名&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;setAge(18)&quot;&gt;改变年龄&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import &#123; state, mutations &#125; from &#x27;@/store</span><br><span class="line">export default &#123;</span><br><span class="line">  // 在计算属性中拿到值</span><br><span class="line">  computed: &#123;</span><br><span class="line">    name() &#123;</span><br><span class="line">      return state.name</span><br><span class="line">    &#125;,</span><br><span class="line">    age() &#123;</span><br><span class="line">      return state.age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 调用mutations里面的方法，更新数据</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeName(name) &#123;</span><br><span class="line">       state.name = name</span><br><span class="line">  	&#125;,</span><br><span class="line">  	setAge(age) &#123;</span><br><span class="line">       state.age = age</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何解决给对象添加属性视图不刷新的问题"><a href="#如何解决给对象添加属性视图不刷新的问题" class="headerlink" title="如何解决给对象添加属性视图不刷新的问题"></a>如何解决给对象添加属性视图不刷新的问题</h2><p>我们从一个例子开始</p><p>定义一个<code>p</code>标签，通过<code>v-for</code>指令进行遍历</p><p>然后给<code>botton</code>标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in item&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addProperty&quot;</span>&gt;</span>动态添加新属性<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例化一个<code>vue</code>实例，定义<code>data</code>属性和<code>methods</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">   	<span class="attr">data</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       	<span class="attr">item</span>:&#123;</span><br><span class="line">            <span class="attr">oldProperty</span>:<span class="string">&quot;旧属性&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">addProperty</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">newProperty</span> = <span class="string">&quot;新属性&quot;</span>  <span class="comment">// 为items添加新属性</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">items</span>)  <span class="comment">// 输出带有newProperty的items</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击按钮，发现结果不及预期，数据虽然更新了（<code>console</code>打印出了新属性），但页面并没有更新</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>为什么产生上面的情况呢？下面来分析一下</p><p><code>vue2</code>是用过<code>Object.defineProperty</code>实现数据响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">let</span> val = obj.<span class="property">val</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;val&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get val:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set val:<span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">val</span> <span class="comment">//get val:0</span></span><br><span class="line">obj.<span class="property">val</span> = <span class="number">1</span> <span class="comment">//set val:1</span></span><br></pre></td></tr></table></figure><p>当我们访问<code>val</code>属性或者设置<code>foo</code>值的时候，都能够触发<code>setter</code>与<code>getter</code></p><p>但是我们为<code>obj</code>添加新属性的时候，却无法触发事件属性的拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">bar</span>  = <span class="string">&#x27;新属性&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>这是<code>Object.defineProperty</code>在设计上存在的问题，无法监听到对象属性的添加，删除，只能监听已有属性的getter和setter</strong></p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>可以通过**Vue.set()或者this.$set()**来给新增属性添加响应式，这2个api的参数是一样的</p><p><code>Vue.set( target, key, value )</code></p><ul><li><code>target</code>：可以是一个对象，也可以是一个数组</li><li><code>key</code>：可以是一个字符串类型的属性，也可以是一个下标（数字）</li><li><code>value</code>：值可以是任意类型</li></ul><p>这个方法的本质就是<strong>使用Object.defineProperty()来添加一个新的响应式属性</strong>，因为直接给对象添加的属性，是不具备响应式的。</p><p>但是，我们只能监听已有属性的getter和setter，即便添加了一个响应式属性，也是无法监听到的，<strong>所以还需要通知所有依赖target的Watcher(告诉它们，我新增一个属性啦)，触发视图更新。</strong></p><p>同样的，通过<code>Vue.delete()</code>和<code>this.$delete</code>来解决删除对象属性，视图不更新的问题。</p><h2 id="说说你对slot的理解？slot使用场景有哪些？"><a href="#说说你对slot的理解？slot使用场景有哪些？" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些？"></a>说说你对slot的理解？slot使用场景有哪些？</h2><p><code>slot</code>的作用就是用来<strong>自定义组件内部的结构</strong></p><p><code>slot</code>可以分来以下三种：</p><ul><li>默认插槽</li><li>具名插槽</li><li>作用域插槽</li></ul><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>子组件用<code>&lt;slot&gt;</code>标签，来确定渲染的位置，标签里面可以放<code>DOM</code>结构，当父组件没有往插槽传入内容，标签内<code>DOM</code>结构，就会显示在页面</p><p>父组件在使用的时候，直接在子组件的标签内写入内容即可</p><p>子组件<code>Child.vue</code>，使用slot标签占位，标签体内的结构是默认结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件向子组件传递结构，只需要在子组件标签体内写结构就好了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>默认插槽<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件给子组件传入的自定义结构，可以在子组件的<code>this.$slots</code>属性中拿到。</p><img src="..\images\前端面试-vue\slot.png" style="zoom:67%"><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>默认插槽形如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们给<code>slot</code>标签添加<code>name</code>属性，默认插槽就变成了具名插槽</p><p>当我们需要在子组件内部的多个位置使用插槽的时候，为了把各个插槽区别开，就需要给每个插槽取名。</p><p>同时父组件传入自定义结构的时候，也要指明是传递给哪个插槽的，形象的来说，就是子组件挖了多个坑，然后父组件来这些填坑，需要把具体的结构填到具体的哪个坑。</p><p>子组件<code>Child.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具名插槽⽤插槽名做参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:content</span>&gt;</span>内容...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>template</code>标签是用来分割，包裹自定义结构的。<code>v-slot</code>属性用来指定这部分结构用来替换哪个插槽，所以<code>v-slot</code>指令是放在template标签上的，要注意的是如果想要将某部分结构传递给指定的插槽，因该使用<code>v-slot:xxx</code>，而不是<code>v-slot=&#39;xxx&#39;</code></p><p><code>v-slot:default</code>可以简化为<code>#default</code>，<code>v-slot:content</code>可以简化成<code>#content</code></p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>子组件在<code>slot</code>标签上绑定属性，来将子组件的信息传给父组件使用，所有绑定的属性（除了name属性），都会被收集成一个对象，被父组件的<code>v-slot</code>属性接收。</p><p>子组件<code>Child.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">testProps</span>=<span class="string">&quot;子组件的值&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>没传footer插槽<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过解构获取<code>v-slot=&#123;user&#125;</code>，还可以重命名<code>v-slot=&quot;&#123;user: newName&#125;&quot;</code>和定义默认值<code>v-slot=&quot;&#123;user = &#39;默认值&#39;&#125;&quot;</code></p><p>所在<code>slot</code>中也存在’’双向数据传递’’，父组件给子组件传递<code>页面结构</code>，子组件给父组件传递子组件的数据。</p><h2 id="你有写过自定义指令吗？自定义指令的应用场景有哪些？"><a href="#你有写过自定义指令吗？自定义指令的应用场景有哪些？" class="headerlink" title="你有写过自定义指令吗？自定义指令的应用场景有哪些？"></a>你有写过自定义指令吗？自定义指令的应用场景有哪些？</h2><h3 id="什么是指令"><a href="#什么是指令" class="headerlink" title="什么是指令"></a>什么是指令</h3><p>在<code>vue</code>中提供了一套为<code>数据驱动视图</code>更为方便的操作，这些操作被称为<code>指令系统</code>。简单的来说，<code>指令系统</code>能够简化dom操作，帮助方便的实现<code>数据驱动视图更新</code>。</p><p>我们看到的<code>v-</code>开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能</p><p>除了核心功能默认<code>内置的指令</code> (<code>v-model</code> 和 <code>v-show</code>)，<code>Vue</code> 也允许注册<code>自定义指令</code></p><p><strong>指令使用的几种方式：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会实例化一个指令，但这个指令没有参数 </span></span><br><span class="line">v-xxx</span><br><span class="line"></span><br><span class="line"><span class="comment">//将值传到指令中</span></span><br><span class="line">v-xxx=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串传入到指令中，如v-html=&quot;&#x27;&lt;p&gt;内容&lt;/p&gt;&#x27;&quot;</span></span><br><span class="line">v-xxx=<span class="string">&quot;&#x27;string&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参数（arg），如v-bind:class=&quot;className&quot;</span></span><br><span class="line">v-<span class="attr">xxx</span>:arg=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用修饰符（modifier）</span></span><br><span class="line">v-<span class="attr">xxx</span>:arg.<span class="property">modifier</span>=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：指令中传入的都是<strong>表达式</strong>，无论是不是自定义指令，比如<code>v-bind:name = &#39;tom&#39;</code>，传入的是tom这个变量的值，而不是tom字符串，除非写成<code>&quot;&#39;tom&#39;&quot;</code>，传入的才是字符串。</p></blockquote><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>关于自定义指令，我们关心的就是三大方面，<strong>自定义指令的定义，自定义指令的注册，自定义指令的使用</strong>。</p><p><code>自定义指令</code>的使用方式和<code>内置指令</code>相同，我们不再研究，其中的难点就是<code>定义自定义指令</code>部分。</p><h4 id="注册自定义指令"><a href="#注册自定义指令" class="headerlink" title="注册自定义指令"></a>注册自定义指令</h4><p>注册一个自定义指令有<code>全局注册</code>与<code>局部注册</code>两种方式</p><p>全局注册主要是通过<code>Vue.directive</code>方法进行注册</p><p><code>Vue.directive</code>第一个参数是指令的名字（不需要写上<code>v-</code>前缀），第二个参数可以是对象数据，也可以是一个指令函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局注册一个自定义指令 `v-focus`</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()  <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部注册通过在组件配置对象中设置<code>directives</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>() <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure><p>在vue3中，局部注册的语法就不同了。如果混合使用<code>选项式api</code>，就可以像vue2一样借助<code>directives</code>属性解决，如果使用的是<code>setup语法糖</code>写法，就需要遵守如下语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用局部注册的自定义指令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-highlight</span>=<span class="string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>This text will be highlighted in yellow<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; directive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义一个高亮指令</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> highlight = <span class="title function_">directive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="property">style</span>.<span class="property">backgroundColor</span> = binding.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义一个聚焦指令</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> focus = <span class="title function_">directive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="title function_">focus</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入<code>directive</code>函数，传入自定义指令，完成组件的局部注册。</p><h4 id="定义自定义指令"><a href="#定义自定义指令" class="headerlink" title="定义自定义指令"></a>定义自定义指令</h4><p>自定义指令本质就是一个<strong>包含特定钩子函数的js对象</strong></p><p>在vue2中，这些常见的钩子函数包括：</p><ul><li><p><strong>bind()</strong></p><p><code>只调用一次</code>，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置，此时无法通过<code>el</code>拿到父级元素，也就是<code>el.parentNode</code>为空，但是也已经能拿到绑定的dom元素了。</p></li><li><p><strong>inserted()</strong></p><p>绑定指令的元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中，因为父元素可能还没插入文档中呢)，此时可以通过<code>el.parentNode</code>拿到父级元素</p></li><li><p><strong>mounted()</strong></p><p>指令绑定的元素被插入到<code>文档</code>中之后</p></li><li><p><strong>update()</strong></p><p>传入指令的值改变后触发</p></li><li><p><strong>unbind()</strong></p><p>只调用一次，指令与元素<code>解绑</code>时调用</p></li></ul><blockquote><p>注意：上述钩子函数在vue3中并不都有效，vue3中的自定义指令钩子函数和生命周期函数一致，具体见官方文档，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/reusability/custom-directives#directive-hooks">https://cn.vuejs.org/guide/reusability/custom-directives#directive-hooks</a></p></blockquote><p>所有的钩子函数的参数都有以下：</p><ul><li><p><strong>el</strong>：指令所绑定的元素，可以用来直接操作 <code>DOM</code>，省去了手动捕获dom的步骤</p></li><li><p><strong>binding</strong>：</p><p>一个对象，包含以下property</p><ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：传入指令的表达式的值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>，又比如<code>v-for=&quot;(value, key, index) in obj&quot;</code>，传入的表达式为<code>&quot;(value, key, index) in obj&quot;</code></li><li><code>arg</code>：<strong>传给指令的参数</strong>，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>，又比如<code>v-bind:class = &quot;[&#39;box&#39;]&quot;</code>的参数为<code>class</code>，为什么是arg不是args，因为传递给指令的参数只能有一个，而修饰符却可以有多个。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code></li></ul></li><li><p><code>vnode</code>：<code>Vue</code> 编译生成的虚拟节点</p></li><li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用</p></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>给某个元素添加节流</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.设置v-throttle自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;throttle&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">bind</span>: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> throttleTime = binding.<span class="property">value</span>; <span class="comment">// 节流时间</span></span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; <span class="comment">// 用户若不设置节流时间，则默认2s</span></span><br><span class="line">      throttleTime = <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="comment">//el是绑定指令的元素</span></span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!timer) &#123; <span class="comment">// 第一次执行</span></span><br><span class="line">      	<span class="comment">//开启定时器，占用临界资源</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//一定时间后，释放资源</span></span><br><span class="line">          timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">        <span class="comment">//同时绑定的另一个监听器也被调用，触发sayHello函数，因为事件流没有被阻止传播</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果在前throttleTime的时间内已经点击过了，调用event.stopImmediatePropagation()</span></span><br><span class="line">        <span class="comment">//它不仅会阻止事件继续沿 DOM 树传播，还会阻止在同一阶段内其他监听器的执行，包括目标阶段的监听器。</span></span><br><span class="line">        event &amp;&amp; event.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);<span class="comment">//捕获触发，触发的顺序在冒泡触发之前</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.为button标签设置v-throttle自定义指令</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">v-throttle</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Vue常用的修饰符有哪些有什么应用场景"><a href="#Vue常用的修饰符有哪些有什么应用场景" class="headerlink" title="Vue常用的修饰符有哪些有什么应用场景"></a>Vue常用的修饰符有哪些有什么应用场景</h2><h3 id="修饰符是什么"><a href="#修饰符是什么" class="headerlink" title="修饰符是什么"></a>修饰符是什么</h3><p>在<code>Vue</code>中，修饰符是用来修饰Vue中的指令的，它<strong>处理了许多<code>DOM</code>事件的细节</strong>，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。</p><p><code>vue</code>中修饰符分为以下五种：</p><ul><li>表单修饰符</li><li>事件修饰符</li><li>鼠标按键修饰符</li><li>键值修饰符</li><li>v-bind修饰符</li></ul><h3 id="修饰符的具体作用"><a href="#修饰符的具体作用" class="headerlink" title="修饰符的具体作用"></a>修饰符的具体作用</h3><h4 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h4><p>在我们填写表单的时候用得最多的是<code>input</code>标签，指令用得最多的是<code>v-model</code></p><p>关于表单的修饰符有如下：</p><ul><li>lazy</li><li>trim</li><li>number</li></ul><p><strong>lazy</strong></p><p>在我们填完信息，光标离开标签的时候，才会将值赋予给<code>value</code>，也就是在<code>change</code>事件之后再进行信息同步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>trim</strong></p><p>自动过滤用户输入的首尾空格字符，而中间的空格不会过滤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">trim</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>number</strong></p><p>自动将用户的输入值转为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.<span class="property">number</span>=<span class="string">&quot;age&quot;</span> type=<span class="string">&quot;number&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ul><li><p>stop：阻止事件冒泡，等在传入的回调函数中添加 <code>event.stopPropagation()</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.<span class="property">stop</span>=<span class="string">&quot;handleClick&quot;</span>&gt;点击不会冒泡&lt;/button&gt;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClickWithStop</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();  <span class="comment">// 手动阻止冒泡</span></span><br><span class="line">  <span class="comment">// 其他业务逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>prevent：阻止默认行为，等同于在传入的回调函数中添加 <code>event.preventDefault()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;handleSubmit&quot;</span>&gt;</span>提交表单不会刷新页面<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>capture：使用事件捕获模式（默认是冒泡模式）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">&quot;parentClick&quot;</span>&gt;</span>父级先触发<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>self：仅当事件从元素本身（而非子元素）触发时执行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.self</span>=<span class="string">&quot;onlySelfClick&quot;</span>&gt;</span>点击子元素不触发<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>once：事件只触发一次，之后自动移除对该事件的监听，避免因长期持有未使用的监听函数导致内存泄漏、</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;oneTimeAction&quot;</span>&gt;</span>仅首次点击有效<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实在原生dom事件中，实现这个效果也是非常简单的，只需要在第三个参数传入<code>&#123; once: true &#125;</code>，手动通过removeEventListener还是比较消耗精力的，不过灵活度更大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>passive：提升滚动性能，不与 <code>prevent</code> 同时使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>滚动更流畅<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当监听 <code>touchstart</code>、<code>touchmove</code> 或 <code>wheel</code>（滚动）等高频事件时，浏览器的默认行为是：等待事件处理函数执行完毕</p><p>再决定是否执行默认行为（如滚动页面），如果事件处理函数中存在耗时操作（如复杂计算），会导致 <strong>滚动卡顿</strong>，因为浏览器必须等待函数执行完毕，才能滚动页面（默认行为）。</p><p><code>passive</code> 修饰符的作用，是通过将事件监听器标记为 <strong>被动模式（Passive）</strong>，本质是向浏览器承诺：<br>​“此事件处理函数不会调用 <code>event.preventDefault()</code>”​，从而允许浏览器 ​<strong>立即触发默认行为</strong>，无需等待函数执行。</p><p>Vue 3 的 <code>.passive</code> 修饰符对应原生 <code>addEventListener</code> 的 <code>&#123; passive: true &#125;</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 编译后的等效代码</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p><code>.passive</code> 向浏览器承诺 <strong>不会阻止默认行为</strong>，而 <code>.prevent</code> 的作用是 <strong>主动阻止默认行为</strong>，二者语义冲突，所以不能同时使用。</p></li></ul><h2 id="Vue中组件和插件有什么区别"><a href="#Vue中组件和插件有什么区别" class="headerlink" title="Vue中组件和插件有什么区别"></a>Vue中组件和插件有什么区别</h2><h3 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h3><p>在vue中，组件就是能实现<code>部分功能</code>的html，css，js代码的集合。</p><p><strong>优势</strong></p><ul><li><p>降低整个系统的<code>耦合度</code></p><p>在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</p></li><li><p>提高代码的<code>可维护性</code>，和<code>可复用性</code></p><p>由于每个组件的职责单一，并且组件在系统中是被复用的。</p></li></ul><h3 id="插件是什么"><a href="#插件是什么" class="headerlink" title="插件是什么"></a>插件是什么</h3><p>插件通常用来为 <code>Vue</code> 添加全局功能，比如通过全局混入来添加一些组件选项。如<code>vue-router</code></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>两者的区别主要表现在以下几个方面：</p><ul><li>编写形式</li><li>注册形式</li></ul><h4 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h4><p><strong>组件</strong></p><p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件。</p><p><strong>插件</strong></p><p><code>vue</code>插件就是一个实现了 <code>install</code> 方法的对象。这个方法的第一个参数是 <code>Vue</code> 构造函数，第二个参数是一个可选的选项对象(options)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">myGlobalMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">bind</span> (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params">methodOptions</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册形式"><a href="#注册形式" class="headerlink" title="注册形式"></a>注册形式</h4><p><strong>组件注册</strong></p><p><code>vue</code>组件注册主要分为<code>全局注册</code>与<code>局部注册</code></p><p>局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure><p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component1 = &#123;...&#125;<span class="comment">// 定义一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="attr">components</span>:&#123;</span><br><span class="line">		component1<span class="comment">//局部注册</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在vue3中的组件注册</strong>：</p><p>全局注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>; <span class="comment">// 引入你的组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="title class_">MyComponent</span>); <span class="comment">// 全局注册组件</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>局部注册：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">MyComponent</span> <span class="comment">// 局部注册组件</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>; <span class="comment">// 引入你的组件</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用局部注册的组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>&lt;script setup&gt;</code> 中导入的组件会<strong>自动注册</strong>并在模板中可用，无需显式地在 <code>components</code> 选项中列出它们。</p><p><strong>插件注册</strong></p><p>插件的注册通过<code>Vue.use()</code>的方式进行注册，第一个参数为<code>插件的名字</code>，第二个参数是可选择的<code>配置项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名字[,options])</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">use</span> = <span class="keyword">function</span>(<span class="params">plugin,options</span>)&#123;</span><br><span class="line">    <span class="comment">//this指向Vue构造函数</span></span><br><span class="line">    <span class="comment">//在use方法内部，会调用插件的install方法</span></span><br><span class="line">    plugin.<span class="title function_">install</span>(<span class="variable language_">this</span>,options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用<code>之前</code>完成，<code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次。</p></blockquote><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><h3 id="什么是SPA，和MPA有什么区别？"><a href="#什么是SPA，和MPA有什么区别？" class="headerlink" title="什么是SPA，和MPA有什么区别？"></a>什么是SPA，和MPA有什么区别？</h3><ul><li><p>SPA指的是<strong>只有一个页面的web应用程序</strong>，所有必要的代码（<code>HTML</code>、<code>JavaScript</code>和<code>CSS</code>）都通过单个页面的加载而被加载（这样首屏加载速度就很慢），或者根据需要（通常是为响应用户操作），动态装载适当的资源，并添加到页面，页面在任何时间点都不会重新加载，也不会将控制转移到其他页面。</p></li><li><p>MPA（多页面应用程序）指的是有多个页面的web应用程序</p></li><li><p>SPA通过js操作dom，来局部更新页面内容；而MPA是通过页面切换，来实现整页的刷新，整页刷新就需加载整个页面所有<code>资源</code>，并重新渲染页面，速度慢；</p></li><li><p>SPA刷新速度更快，用户体验更好，同时把页面渲染工作交给客户端，减轻了服务端的压力。</p></li><li><p>缺点是不利于搜索引擎优化(SEO)，首屏加载速度较慢，当然这些问题都是可以解决的。</p></li></ul><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/spa.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFspa">面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢 | web前端面试 - 面试官系列</a></p><h3 id="如何实现SPA"><a href="#如何实现SPA" class="headerlink" title="如何实现SPA"></a>如何实现SPA</h3><p>SPA是通过hash路由或者history路由实现的，问如何实现SPA，其实就是在询问这两种路由是如何实现，关于这一点，可以参考后文。</p><h3 id="如何提高首屏加载速度？"><a href="#如何提高首屏加载速度？" class="headerlink" title="如何提高首屏加载速度？"></a>如何提高首屏加载速度？</h3><p>首屏加载时间，指的是浏览器从<strong>响应用户输入网址</strong>，到<strong>首屏内容</strong>渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容。</p><p><strong>首屏加载慢的原因</strong></p><ul><li>网络延时问题</li><li>资源文件体积是否过大</li><li>资源是否重复发送请求去加载了</li><li>加载脚本的时候，渲染内容堵塞了</li></ul><h4 id="使用路由懒加载"><a href="#使用路由懒加载" class="headerlink" title="使用路由懒加载"></a>使用路由懒加载</h4><blockquote><p>使用路由懒加载能减少资源的加载时间，确保只加载首屏需要的资源</p></blockquote><ul><li>对于非首屏组件，使用路由懒加载，当需要访问这些组件的时候，再加载对应的资源。<strong>路由懒加载本质就是异步加载js，css文件，或者说按需加载js，css文件。</strong></li><li>开发单页面应用程序时，只有一个<code>html</code>页面，打包后也只有一个<code>index.html</code>页面，其他所谓的<code>页面</code>，都是通过 <code>JavaScript</code> 动态地修改<code>DOM</code>来实现的。</li><li>开发过程中，一个页面对应一个或者多个<code>组件</code>，在打包后，每个组件都会转化成对应的<code>css</code>，<code>js</code>代码，其中的<code>js代码</code>不光包括业务逻辑，也负责修改dom，构建页面。</li><li>如果使用<code>路由懒加载</code>，我们可以观察到，<strong>打包后的js，css文件<code>数量</code>变多了，每个文件的体积也变小了</strong>，是因为Webpack &#x2F; Vite 等构建工具<strong>会将每个懒加载的组件打包成一个独立的 chunk</strong>（代码块）。这样，<code>index.html</code>引入的的<code>js</code>，<code>css</code>文件的体积也会变小，因为只包含<code>首屏组件</code>需要的<code>js，css</code>代码。</li></ul><p>关于路由懒加载的介绍可参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/7034719865910853662">Vue Webpack 打包优化——路由懒加载（按需加载）原理讲解及使用方法说明- 掘金</a></p><h4 id="缓存静态资源"><a href="#缓存静态资源" class="headerlink" title="缓存静态资源"></a>缓存静态资源</h4><blockquote><p>使用缓存能直接避免加载资源，直接使用缓存中的资源</p></blockquote><p>对于已经请求过的资源，<strong>再次请求</strong>直接使用缓存。比如我们每天都要刷b站，可以观察到，B站的页面样式改变的频率是比较低的，如果我们每次登录b站，都要重新请求这些css样式文件，然后再解析渲染，就比较慢了，但是如果我们缓存这些css文件，下次就可以省去加载这些资源的时间，从而提高首屏加载速度。再比如，对于首屏固定不变的图片，如果我们缓存了，下次也可以直接使用。</p><h4 id="给script标签添加defer或者async属性"><a href="#给script标签添加defer或者async属性" class="headerlink" title="给script标签添加defer或者async属性"></a>给script标签添加defer或者async属性</h4><blockquote><p>给script标签添加defer或者async属性，能让加载js文件的时候，不阻塞dom树的构建</p></blockquote><h4 id="压缩等js，css，html等静态资源的大小"><a href="#压缩等js，css，html等静态资源的大小" class="headerlink" title="压缩等js，css，html等静态资源的大小"></a>压缩等js，css，html等静态资源的大小</h4><blockquote><p>压缩静态资源的大小能减少资源的加载时间</p></blockquote><p>这一点是显而易见的，压缩静态资源的大小，我们加载这些资源的时间就变少了，从而提高了首屏加载速度。我在部署自己的博客前，也会先把将要上传的图片，样式表，js文件，html文件等静态资源统一压缩，再上传，以求提高首屏加载速度。在实际开发过程中，这个功能通常是由webpack等模块化打包工具自动实现的。</p><h4 id="内联首屏关键js，css"><a href="#内联首屏关键js，css" class="headerlink" title="内联首屏关键js，css"></a>内联首屏关键js，css</h4><p>内联首屏关键css或者js文件，这样首屏关键css和js就会随着html文件的下载而被下载，<strong>不但能减少请求的次数，还能提高首屏的渲染速度。</strong></p><h4 id="从http请求优化"><a href="#从http请求优化" class="headerlink" title="从http请求优化"></a>从http请求优化</h4><blockquote><p>减少http请求的次数，能缩短资源的加载时间</p></blockquote><ul><li>将多个体积较小的css或者js文件，合并为单个文件（如 <code>bundle.css</code>），减少请求次数。</li><li>使用雪碧图（或者说精灵图），减少请求小图片的次数</li></ul><h4 id="使用服务端渲染SSR"><a href="#使用服务端渲染SSR" class="headerlink" title="使用服务端渲染SSR"></a>使用服务端渲染SSR</h4><blockquote><p>使用服务端渲染，可以省去前端拼接html结构的工作</p></blockquote><p>将首页的html结构的拼接工作，交给后端服务器，关于服务端渲染的介绍参考后文。</p><p>对于vue，推荐使用<code>nuxt.js</code></p><h3 id="如何提高SPA的SEO"><a href="#如何提高SPA的SEO" class="headerlink" title="如何提高SPA的SEO"></a><strong>如何提高SPA的SEO</strong></h3><p>首先我们思考一个问题，为什么需要提高SPA的seo？</p><ul><li>传统web开发，一般就是多页面应用程序，每个页面的html结构都在服务端拼接好，所以没有SEO问题。</li></ul><ul><li>SPA的页面内容通过 Js 动态渲染，初始 HTML 通常是空壳（如 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>），真实内容由 JS 后续填充。</li><li>传统搜索引擎爬虫（如早期 Googlebot）可能<strong>无法执行 JavaScript</strong>，导致只能抓取空白页面。</li></ul><p>那如何解决SPA的SEO问题呢？答案是使用服务端渲染</p><p>服务端渲染（SSR），指由<code>服务端</code>完成页面的 <code>HTML结构拼接</code>的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。使用服务端渲染，返回的页面，就已经包含了一定的页面结构，能够被搜索引擎爬虫爬取</p><p>除了能提高SPA的SEO，使用服务端渲染还能提高首屏的加载速度，因为不需要浏览器执行js来拼接html。</p><p>简单实现的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  &#123;&#123;&#123;metas&#125;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span></span></span><br><span class="line"><span class="tag">  &lt;!<span class="attr">--下面的注释</span>，<span class="attr">最终会被渲染好的模板内容替代</span>，<span class="attr">注意不能有空格--</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为是在服务端运行的代码，所以使用的是cjs语法</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vue</span> = <span class="built_in">require</span>(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> vueServerRenderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 以utf-8的格式，同步读取模板html文件，返回一个string</span></span><br><span class="line"><span class="keyword">const</span> template = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./index.html&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">// console.log(typeof template)</span></span><br><span class="line"><span class="comment">// 根据传入的html模板，创建一个renderer，渲染好的模板会本放入html模板的指定位置</span></span><br><span class="line"><span class="keyword">const</span> renderer = vueServerRenderer.<span class="title function_">createRenderer</span>(&#123;template&#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">      <span class="attr">url</span>:req.<span class="property">url</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&quot;&lt;div&gt;&#123;&#123;url&#125;&#125;&lt;/div&gt;&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//更多html模板配置参数</span></span><br><span class="line">  <span class="keyword">const</span> context = &#123;</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&#x27;Vue SSR&#x27;</span>,</span><br><span class="line">    <span class="attr">metas</span>:<span class="string">`&lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用renderer对象的renderToString方法</span></span><br><span class="line">  <span class="comment">//第一个参数传入vue实例，第二个参数传入模板html文件的更多配置参数，第三个参数传入一个渲染成功后触发的回调函数</span></span><br><span class="line">  <span class="comment">//回调函数的第一个参数是一个错误对象，第二个参数才是渲染好后的html字符串</span></span><br><span class="line">  renderer.<span class="title function_">renderToString</span>(vue, context ,<span class="function">(<span class="params">err,html</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="comment">//链式调用</span></span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">end</span>(<span class="string">&#x27;服务端错误&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.<span class="title function_">end</span>(html)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器开启成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="hash路由和history路由的实现原理，二者有什么区别？"><a href="#hash路由和history路由的实现原理，二者有什么区别？" class="headerlink" title="hash路由和history路由的实现原理，二者有什么区别？"></a>hash路由和history路由的实现原理，二者有什么区别？</h2><img src="..\images\前端面试-vue\前端路由.png" style="zoom:67%"><p><code>哈希路由</code>（Hash-based Routing）和 <code>History 路由</code>（History API-based Routing）是前端路由的两种常见实现方式，它们用于在单页面应用程序 (SPA) 中模拟多页面体验，而无需重新加载整个页面。</p><h3 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><ul><li><code>前端路由</code>被放到<code>url</code>的<code>hash</code>部分，即url中<code>#</code>后面的部分。</li><li><code>哈希值</code>改变也不会触发页面<code>重新加载</code>，但是会产生历史记录。</li><li>浏览器不会将<code>哈希值</code>发送到服务器，因此无论<code>哈希值</code>如何变化，刷新页面，服务器只会返回同一个初始 HTML 文件。</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul><li>不需要服务器配置支持，因为哈希值不会被发送给服务器。</li><li><code>兼容性好</code>，几乎所有浏览器都支持哈希变化事件。</li><li>URL 中包含显眼的 <code>#</code> 符号，可能影响美观。</li><li>前端路由部分十分明确，方便部署，可以部署在服务器的<code>任何位置</code>。</li></ul><h4 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a><strong>如何做</strong></h4><img src="..\images\前端面试-js\hash.png" style="zoom:67%"><p>可以直接设置 <code>window.location.hash</code> 属性来<code>改变</code> URL 中的哈希部分，改变 <code>window.location.hash</code> 不会触发<code>页面刷新</code>，但它会添加一个<code>新的历史记录条目</code>。</p><p>前端 JavaScript 监听 <code>hashchange</code> 事件来<code>检测</code>哈希的变化，并根据新的哈希值更新页面内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//存储当前的hash值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentHash</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">//存储路由</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;</span><br><span class="line">    <span class="comment">//页面初次加载的时候，获取当前路由，根据当前路由执行对应的回调函数</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//如果hash值为&quot;&quot; ，则修改hash值为 &#x27;/&#x27;，否则直接执行对应的回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentHash</span> = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">currentHash</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">currentHash</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//hash值改变了，及时更新this.currentHash</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentHash</span> = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//调用对应的回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">currentHash</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来根据当前hash路由，执行对应的回调函数</span></span><br><span class="line">  <span class="title function_">callback</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> callbackFunc = <span class="variable language_">this</span>.<span class="property">routes</span>[path]</span><br><span class="line">    <span class="keyword">if</span> (callbackFunc) &#123;</span><br><span class="line">      <span class="title function_">callbackFunc</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前hash路由没有注册对应的回调函数&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来注册路由，对应的回调函数--</span></span><br><span class="line">  <span class="title function_">route</span>(<span class="params">path, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修改当前页面的hash值，模拟路由跳转，这一操作会触发hashchange，然后就会执行对应的回调函数</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    location.<span class="property">hash</span> = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将创建的实例挂载到window上，成为全局变量</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">miniRouter</span> = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"><span class="comment">// 注册路由</span></span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;page1&#x27;</span>))</span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&#x27;/page2&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;page2&#x27;</span>))</span><br><span class="line"><span class="comment">// 模拟导航操作</span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>); <span class="comment">// 应该输出 &#x27;page1&#x27;</span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&#x27;/page2&#x27;</span>); <span class="comment">// 应该输出 &#x27;page2&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="history路由"><a href="#history路由" class="headerlink" title="history路由"></a>history路由</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><p>使用标准的路径形式，例如 <code>http://example.com/page1</code>，<code>前端路由</code>被放到<code>url</code>中的<code>资源路径</code>部分</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul><li><p>没有显眼的<code>#</code>号，更为美观</p></li><li><p>非常适合用来做服务端渲染，从而提高页面的SEO</p><ul><li>使用History 路由的项目，前端路由混合在url的资源路径部分</li><li>这意味着前端路由能发送到后端服务器，后端服务器能为每一个前端路由生成对应的完整的html文件。</li><li>使用了ssr的History 路由项目，搜索引擎爬取每一个前端页面都能得到完整的html结构，从而提高了项目的seo。</li></ul></li><li><p>需要后端支持，否则会出现<code>404</code>问题，因为前端路由会被当作资源路径，发送到后端，而后端并未做对应配置。</p></li><li><p>对较老版本的浏览器兼容性较差，因为history路由是基于在H5才提出的History API</p></li><li><p>要求<code>index.html</code>文件引用资源的路径，必须使用绝对路径</p><ul><li><p>因为基于History API，我们可以改变URL但是不实现页面跳转，展示的始终是同一个index.html文件。</p></li><li><p>但是当我们改变路由后（比如从<code>http://localhost:3000</code>变成<code>http://localhost:3000/it/about</code>），再手动刷新页面的时候，就会发送<code>get</code>请求<code>http://localhost:3000/it/about</code>到服务器(假设是开发服务器devServer)，</p></li><li><p>显然对于这个请求url，开发服务器找不到对应的资源，于是返回根目录(通常是public文件)下的<code>index.html</code>文件（歪打正着）</p></li><li><p>但是其他资源就没有这么好运了，浏览器拿到这个页面进行解析渲染，然后加载页面中的资源，比如css文件，如果我们使用的是相对路径，最终请求这些资源的请求路径，还会与当前页面url拼接，所以当前页面的url是不确定的，而我们资源的位置肯定是固定的，所以很容易找不到对应的资源，所以开发服务器返回<code>index.html</code>文件，你没看错，我们请求css文件结果服务端返回了html文件，然后浏览器就报错了。</p></li></ul></li><li><p>history路由的项目一般部署在<code>服务器根目录</code>，域名后面的路径就是<code>前端路径</code>，否则需要在<code>前端路由库</code>(比如VueRouter)中做额外配置，确保浏览器能从url中提取出前端路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;/app/&#x27;</span>, <span class="comment">// 设置基础路径</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 你的路由配置</span></span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如，如果用户的 URL 是 <code>http://example.com/app/user/profile</code>，那么前端路由库会将 <code>/user/profile</code> 视为<code>实际的路由路径</code>，而 <code>/app/</code> 则被视为基础路径。</p></li></ul><h4 id="如何做-1"><a href="#如何做-1" class="headerlink" title="如何做"></a><strong>如何做</strong></h4><img src="..\images\前端面试-js\history.png" style="zoom:67%"><p>使用 <code>HTML5</code> 的 History API (<code>history.pushState()</code> 和 <code>history.replaceState()</code>) 来<code>修改</code> URL，而不会触发页面刷新。</p><p>要注意的是，调用这2个api都不会触发<code>popstate</code>事件，只有在用户导航历史栈（通过浏览器的后退或前进按钮）时，才会触发 <code>popstate</code> 事件；而<code>hashchange</code>事件，无论是通过js修改hash，还是点击<code>前进后退</code>按钮修改hash，都会触发<code>hashchange</code>事件</p><p><strong>history.pushState(state, title, url)</strong></p><ul><li><p><strong>功能</strong>：</p><ul><li><p>向浏览器的<code>历史栈</code>中添加一个新的记录，历史栈长度+1，</p></li><li><p>并更新<code>当前 URL</code>，但不重新加载页面。</p></li></ul></li><li><p><strong>参数</strong></p><ul><li><p><code>state</code>: 一个对象，用于存储与该状态相关联的数据，可以通过 <code>popstate</code> 事件的事件对象event访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//console.log(e)</span></span><br><span class="line">      <span class="keyword">const</span> path = e.<span class="property">state</span> &amp;&amp; e.<span class="property">state</span>.<span class="property">path</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以通过<code>history.state</code>属性访问。</p></li><li><p><code>title</code>：通常被忽略或设为空字符串（大多数浏览器不支持）。</p></li><li><p><code>url</code>：新的 URL，可以是相对路径或绝对路径，<strong>但不能改变域名，否则会报错</strong>。</p></li></ul><img src="..\images\前端面试-js\a.png" style="zoom:90%"></li></ul><p><strong>history.replaceState(state, title, url)</strong></p><ul><li><strong>功能</strong>：<ul><li>替换当前的历史记录条目，而不是添加新的条目。</li><li>它同样更新<code>当前 URL</code> 但不刷新页面。</li></ul></li><li><strong>参数</strong>：与 <code>pushState</code> 相同。</li></ul><p>监听 <code>popstate</code> 事件来响应浏览器的前进&#x2F;后退按钮操作。</p><p>最终代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//存储路由</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;;</span><br><span class="line">    <span class="comment">//页面初次加载的时候，修改路径为 &#x27;/&#x27;，并触发对应的事件回调</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      history.<span class="title function_">replaceState</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;, <span class="literal">null</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routes</span>[<span class="string">&#x27;/&#x27;</span>] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[<span class="string">&#x27;/&#x27;</span>]();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 监听popstate事件，也就是监听浏览器返回/前进按钮点击，然后触发对应的回调函数</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//这里是通过popstate的事件对象获取到了当前页面的状态（栈顶页面，或者说前进，回退操作后的页面）</span></span><br><span class="line">      <span class="comment">//其实还是可以通过location获得的吧，就是location.pathname</span></span><br><span class="line">      <span class="keyword">const</span> path = e.<span class="property">state</span>.<span class="property">path</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来注册路由</span></span><br><span class="line">  <span class="title function_">route</span>(<span class="params">path, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来修改路由</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    history.<span class="title function_">pushState</span>(&#123; path &#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="comment">//修改之后立马调用对应的回调函数，而不是等待触发popstate事件，因为不会触发</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Router  </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">miniRouter</span> = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"><span class="comment">//注册路由</span></span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;首页&#x27;</span>));</span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">&#x27;/page2&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;page2&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转  </span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">&#x27;/page2&#x27;</span>);  <span class="comment">// 输出 &#x27;page2&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="vue如何做前端性能优化"><a href="#vue如何做前端性能优化" class="headerlink" title="vue如何做前端性能优化"></a>vue如何做前端性能优化</h2><p>前端性能优化就包括了《如何提高首屏的加载速度》。</p><h3 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h3><ul><li>使用事件代理：使用事件委托能减少内存占用，减少不必要的重复代码。关于事件委托的介绍，可以参考<a href="https://www.sanye.blog/posts/aef189c3.html">前端面试—js部分 | 三叶的博客</a></li><li>使用<code>keep-alive</code>缓存组件：会缓存不活动的<strong>组件实例</strong>，而不是销毁它们，<strong>防止重复渲染DOM</strong>。</li><li>使用<strong>路由懒加载</strong>，本质是按需加载css，js文件</li><li>保证key值唯一，有利于diff算法复用dom，虽然key值不唯一也会提示，也不需要我们操心。</li></ul><h3 id="减少资源体积"><a href="#减少资源体积" class="headerlink" title="减少资源体积"></a>减少资源体积</h3><p>这部分的内容，其实主要是<code>模块化打包工具</code>帮助我们实现的，不需要我们操心。</p><ul><li>压缩css，js文件：使用打包工具比如webpack，vite压缩css，js文件（删除注释，空格，合并多个文件）</li><li><code>tree-shaking</code>：使用tree-shaking移除未使用的代码，减少最终打包后的文件体积，虽然现在的打包工具都默认支持tree-shaking。</li><li>压缩图片体积：使用webp格式替代jpg或者png格式的图片，压缩图片体积。</li></ul><h3 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h3><ul><li>使用图片懒加载，我们可以手动实现图片懒加载指令</li><li><strong>缓存</strong>图片，css，js文件等静态资源。在构建过程中，为静态资源文件名添加内容哈希值（例如 <code>app.a1b2c3d4.js</code>），这样每次更新文件时都会生成一个新的URL，浏览器会认为这是一个全新的资源而重新下载它，而不是使用缓存，这是也是打包工具会帮忙做的事情。</li></ul><h3 id="http请求优化"><a href="#http请求优化" class="headerlink" title="http请求优化"></a>http请求优化</h3><h4 id="减少http请求的次数"><a href="#减少http请求的次数" class="headerlink" title="减少http请求的次数"></a>减少http请求的次数</h4><ul><li>将多个体积较小的css或者js文件，合并为单个文件（如 <code>bundle.css</code>），减少请求次数。</li><li>使用雪碧图（或者说精灵图），减少请求小图片的次数</li><li><strong>内联首屏关键css或者js文件</strong>，这样首屏关键css和js就会随着html文件的下载而被下载，不但能减少请求的次数，还能提高首屏的渲染速度。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>每个请求和响应都包含头部信息</strong>，虽然这些头部信息通常很小，但在大量小文件的情况下，累积起来也会影响性能。</li><li>浏览器对<strong>同一域名下的并发请求数</strong>有限制（通常是6个），这意味着如果同时有超过这个数量的请求，则需要排队等待，进一步增加了加载时间。</li></ul><h2 id="v-if和v-for的优先级是什么"><a href="#v-if和v-for的优先级是什么" class="headerlink" title="v-if和v-for的优先级是什么"></a>v-if和v-for的优先级是什么</h2><p>在vue2中，v-for的优先级高于v-if，也就是说会遍历所有元素，然后再通过<code>v-if</code>判断是否是要渲染，即使某些项最终不满足 <code>v-if</code> 条件，<code>v-for</code> 仍会遍历这些项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;item.isVisible&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">//这个例子中，Vue 2 首先遍历 `items` 数组（通过 `v-for`），然后对每个项应用 `v-if` 来决定是否渲染该项。</span><br></pre></td></tr></table></figure><p>而在vue3中，<code>v-if</code>的优先级高于<code>v-for</code>，所以在vue3中，上述代码会报错，会提示item未被定义；</p><p>这也意味着在vue3中，无法根据某个对象的属性，使用v-if来控制渲染。</p><p>其实最推荐的做法是只迭代并渲染需要渲染的数据，不在同一个元素上使用<code>v-if</code>和<code>v-for</code>，<strong>这就需要我们提前过滤元素</strong>。</p><h2 id="v-if和v-show如何理解"><a href="#v-if和v-show如何理解" class="headerlink" title="v-if和v-show如何理解"></a>v-if和v-show如何理解</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>二者都是用来控制页面中元素的显示与隐藏，当表达式值为<code>false</code>的时候，都不会占据页面的位置。</p><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p><code>v-show</code>本质是通过<code>切换css样式</code>来实现元素的显示与隐藏，令<code>display:none</code>让元素隐藏，dom元素还存在。</p><p><code>v-if</code>本质则是通过<code>控制dom元素的创建与删除</code>来实现元素的显示与隐藏，因为<code>v-if</code>直接操作<code>dom</code>，所以<code>v-if</code>有更高的性能消耗。</p><p><code>v-if</code>才是真正的<code>条件渲染</code>，<code>v-show</code>的值为<code>false</code>的元素，也会被渲染，因为它还是会出现在文档中，只是变得不可见且不占据位置。</p><h2 id="说说你对nextTick的理解"><a href="#说说你对nextTick的理解" class="headerlink" title="说说你对nextTick的理解"></a>说说你对nextTick的理解</h2><p>在vue中，虽然是数据驱动视图更新，但是数据改变（同步改变），vue异步操作dom来更新视图，而传入<code>nextTick</code>的回调函数，能确保在DOM更新之后再被执行，所以nextTick回调函数中能访问到最新的DOM。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><code>Vue.nextTick(()=&gt;&#123;&#125;)</code>或者<code>this.$nextTick(()=&gt;&#123;&#125;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;原始值&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用回调函数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;修改后的值&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;原始的值&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;修改后的值&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果调用nextTick的时候，没有传入回调函数，则会返回一个Promise对象，当这个Promise对象的值改变后，就能访问到最新的DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用async/await</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;修改后的值&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;原始的值&#x27;</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.$nextTick()<span class="comment">//此时没有传入回调函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;修改后的值&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []  <span class="comment">// 存放传入nextTick的回调函数</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>  <span class="comment">// 控制timerFunc的调用频率</span></span><br><span class="line"><span class="keyword">let</span> timerFunc  <span class="comment">// 后续会被定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  <span class="comment">//将传入的回调函数，放入callbacks中</span></span><br><span class="line">  <span class="comment">//这个过程是同步发生的，但是callbacks中的函数被执行却是发生在微任务阶段</span></span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    <span class="comment">//如果是首次调用nextTick，再调用一次timerFunc</span></span><br><span class="line">    <span class="comment">//pending = true的意义是如果再调用nextTick，不再调用timerFunc</span></span><br><span class="line">    <span class="comment">//这意味着即便多次同步调用nextTick，只会在第一次调用的时候，将清空callback的任务，放入者微任务（或者宏任务）队列</span></span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()<span class="comment">//效果是将flushCallbacks放入微任务（或者宏任务）队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="comment">// 如果没传入回调函数，且当前浏览器支持promise对象，则返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callbacks</code>新增回调函数后，又执行了<code>timerFunc</code>函数，那么这个<code>timerFunc</code>函数是做什么用的呢，我们继续来看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="comment">//判断1：是否原生支持Promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">//判断2：是否原生支持MutationObserver</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">//判断3：是否原生支持setImmediate</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//判断4：上面都不行，直接用setTimeout</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码描述了<code>timerFunc</code>的<strong>是如何被定义的</strong>，做了四个判断，对当前环境进行不断的降级处理，尝试使用原生的<code>Promise.then</code>、<code>MutationObserver</code>和<code>setImmediate</code>，上述三个都不支持最后使用<code>setTimeout</code>。</p><p>通过四个判断可以确保，无论在何种浏览器条件下，都能定义出最合适<code>timerFunc</code>。而且四种情况下定义的<code>timerFunc</code>，<strong>效果都是，将<code>flushCallbacks</code>放入<code>微任务</code>（或者<code>宏任务</code>）队列</strong>。</p><p><code>timerFunc</code>不顾一切的要把<code>flushCallbacks</code>放入<code>微任务</code>或者<code>宏任务中</code>去执行，它究竟是何方神圣呢？让我们来一睹它的真容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//释放pending，确保下次事件循环同步调用nextTick的时候，能触发timerFunc</span></span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来以为有多复杂的<code>flushCallbacks</code>，居然不过短短的几行。它所做的事情也非常的简单，把callbacks数组复制一份，然后把callbacks置为空，最后把复制出来的数组中的每个函数依次执行一遍；<strong>所以它的作用仅仅是用来执行callbacks中的所有回调函数，</strong>也就是说，<strong>callbacks中的任务，会在微任务阶段（或者宏任务）被执行。</strong></p><h3 id="如何确保此时DOM是最新的？"><a href="#如何确保此时DOM是最新的？" class="headerlink" title="如何确保此时DOM是最新的？"></a>如何确保此时DOM是最新的？</h3><p>经过上面的介绍我们知道，传入nextTick的回调函数，通常会在<strong>微任务阶段</strong>被依次执行，那又是如何确保nextTick中的回调函数访问到的DOM是最新的DOM呢？</p><p>就如同<code>nextTick</code>中存在<code>callbacks</code>队列一样，在vue中修改数据，会触发对应的setter，然后将对应的更新操作，push到一个异步更新队列中（不同于callbacks），然后<code>负责清空这个异步更新队列的任务</code>，也会被放入微任务队列中，就如同清空<code>callbacks</code>的任务：<code>flushCallbacks</code>，会被<code>timeFunc</code>放入微任务队列中，不过由于清空这个异步更新队列的任务，先于<code>flushCallbacks</code>被执行，所以nextTick中的回调函数访问到的DOM是最新的DOM。下面用例子说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;我是测试文字&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">childName</span> = <span class="string">&#x27;我是子组件名字&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>同步调用，<code>this.msg = &#39;我是测试文字&#39;</code>，触发msg属性的setter，然后会开启一个异步更新队列，将依赖msg的所有<code>Watcher</code>放入异步更新队列，并将<code>清空异步更新队列的任务</code>，放入微任务队列中</p></li><li><p>同步调用，<code>this.$nextTick( ()=&gt;&#123; console.log(1) &#125; )</code>，将<code>()=&gt;&#123; console.log(1) &#125;</code>放入callbacks中，并且将flushCallbacks放入微任务中</p></li><li><p>同步调用，<code>this.childName = &#39;我是子组件名字&#39;</code>，触发childName属性的setter，将依赖childName的所有<code>Watcher</code>放入异步更新队列</p></li><li><p>同步调用<code>this.$nextTick(()=&gt;&#123; console.log(2) &#125;)</code>，将<code>()=&gt;&#123; console.log(2) &#125;</code>放入callbacks中。</p></li><li><p>同步任务执行完毕，开始执行微任务，执行清空异步更新队列的任务，更新DOM</p></li><li><p>从微任务中取出flushCallbacks执行，清空callbacks队列</p></li><li><p>为了确保<code>清空异步更新队列的任务</code>，先于<code>flushCallbacks</code>被放入微任务队列，需要先同步执行修改数据的操作</p></li></ul><h2 id="什么是虚拟DOM？有什么作用？如何实现？"><a href="#什么是虚拟DOM？有什么作用？如何实现？" class="headerlink" title="什么是虚拟DOM？有什么作用？如何实现？"></a><strong>什么是虚拟DOM？有什么作用？</strong>如何实现？</h2><h3 id="在js中的情况"><a href="#在js中的情况" class="headerlink" title="在js中的情况"></a>在js中的情况</h3><blockquote><p>这部分内容主要参考js中的事件循环，可参考本博客内的《javascript》一文</p></blockquote><p>在原生 JavaScript 的事件循环中，多次 DOM 操作会 <strong>立即修改内存中的 DOM 树</strong>，但浏览器通过 <strong>批量更新，合并机制，</strong> 延迟视图渲染至事件循环末尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一事件循环中多次修改同一元素的样式</span></span><br><span class="line">element.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;100px&quot;</span>;</span><br><span class="line">element.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;200px&quot;</span>;</span><br><span class="line">element.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>;</span><br></pre></td></tr></table></figure><p>浏览器会将这三次样式修改，合并为一次渲染流程，而非逐次触发三次重排，所以不会看到样式闪烁，因为只渲染了一次。</p><p>虽然减少了渲染次数，但每次 DOM 操作仍会 <strong>立即修改内存中的 DOM 树</strong>，频繁操作可能导致主线程阻塞（如复杂布局计算），因为操作DOM是费时的（比如一个DOM对象身上有很多属性，创建一个DOM是费时间的），所以在Vue等框架中，使用虚拟DOM和diff算法，来<strong>减少操作真实DOM的次数</strong>。</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>虚拟DOM（虚拟DOM树）本质就是一个用来<strong>描述真实DOM（真实DOM树）的js对象</strong>，是对真实DOM（真实DOM树）的<strong>高度抽象</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>hello world!!!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将上面的HTML模版抽象成虚拟DOM树：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">chidren</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">className</span>: <span class="string">&#x27;text&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">chidren</span>: [</span><br><span class="line">        <span class="string">&#x27;hello world!!!&#x27;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作虚拟 DOM 的速度，比直接操作真实 DOM <strong>快 10-100 倍</strong>。</p><h4 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a><strong>VNode</strong></h4><p>虚拟DOM树本身是一个js对象，是对真实DOM树的高度抽象，而VNode是虚拟DOM树上的结点，是对<code>真实DOM结点</code>的抽象，它描述了应该怎样去创建真实的DOM结点。</p><h4 id="创建虚拟DOM"><a href="#创建虚拟DOM" class="headerlink" title="创建虚拟DOM"></a><strong>创建虚拟DOM</strong></h4><p>在Vue 通过 <code>createElement</code> 函数（简写为 <code>h</code>，即 “hyperscript”）生成 <code>VNode</code> 树，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构。</p><p>一个典型的 <code>vnode</code> 对象可能包含以下字段：</p><ul><li><code>tag</code>: 元素类型（例如 <code>&#39;div&#39;</code>、<code>&#39;span&#39;</code> 等）</li><li><code>data</code>: 包含元素的属性、样式、事件处理器等元数据</li><li><code>children</code>: 子节点数组，可以是其他 <code>vnode</code> 或文本字符串</li><li><code>text</code>: 如果是文本节点，则包含文本内容</li><li><code>el</code>: 引用对应的真实DOM节点（仅在某些实现中存在）</li></ul><p>举例说明：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span></span><br><span class="line">  Hello Vue!</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>子节点<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Vue 的 render 函数和 createElement</span></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>, <span class="comment">// tag</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;container&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Div clicked&quot;</span>), <span class="comment">// 事件处理器</span></span><br><span class="line">  &#125;, <span class="comment">// data</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;Hello Vue! &quot;</span>, <span class="comment">// 文本节点</span></span><br><span class="line">    <span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;子节点&quot;</span>), <span class="comment">// 子 VNode</span></span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价的简化写法（Vue 2.5+ 使用 h 函数）：</span></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">h</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;container&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Div clicked&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="string">&quot;Hello Vue! &quot;</span>, <span class="title function_">h</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;子节点&quot;</span>)]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>生成的 <code>VNode</code> 结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;container&quot;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Div clicked&quot;</span>) &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    <span class="string">&quot;Hello Vue! &quot;</span>, <span class="comment">// 文本节点（类型为字符串）</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">&quot;span&quot;</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">children</span>: [<span class="string">&quot;子节点&quot;</span>],</span><br><span class="line">      <span class="attr">text</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="attr">el</span>: <span class="literal">undefined</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">text</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">el</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="在Vue中的情况"><a href="#在Vue中的情况" class="headerlink" title="在Vue中的情况"></a>在Vue中的情况</h3><ul><li>在vue中，虽然是数据驱动视图更新的，当数据被修改时，会触发对应的 <code>setter</code>，但不会立即修改dom，而是通知依赖更新，调用所有依赖（Watcher）的update方法：将Watcher自身放入<strong>异步更新队列中</strong>。</li><li>然后在微任务阶段，清空异步更新队列：<ul><li>调用每个Watcher的<code>run</code>方法，要注意的是，虽然每个Key都可以有多个Watcher，但并不是所有Watcher都是<strong>渲染Watcher</strong>（负责组件的视图更新，每个组件对应一个渲染 Watcher），只有渲染 Watcher 的 <code>run</code> 方法触发 <code>render</code>，生成新虚拟 DOM → Diff → DOM 更新。</li><li>如果完全按照新的虚拟dom树，来创建新的dom树，就会有许多不必要的dom操作，所以我们会使用<strong>diff算法</strong>，进行新旧虚拟DOM树的比较，得出最小的变更，应用到对真实dom树的修改。</li></ul></li><li>综上所述，在vue中对真实DOM的修改，是在微任务阶段发生的，然后就到了事件循环的末尾，因为对DOM进行了修改，所以会进行一次渲染。</li></ul><h2 id="说说diff算法"><a href="#说说diff算法" class="headerlink" title="说说diff算法"></a>说说diff算法</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p><code>diff</code> 算法是一种在同层的树节点，进行比较的高效算法</p><p>其有两个特点：</p><ul><li>比较只会在同层级进行, 不会跨层级比较</li><li>在diff比较的过程中，从两边向中间循环比较</li></ul><p>在vue中，我们使用<code>diff算法</code>来进行新旧虚拟dom的比较。</p><p>简化后的虚拟节点（vnode）大致包含以下属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,       <span class="comment">// 标签名</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,         <span class="comment">// 属性数据，包括class、style、event、props、attrs等</span></span><br><span class="line">  <span class="attr">children</span>: [],     <span class="comment">// 子节点数组，也是vnode结构</span></span><br><span class="line">  <span class="attr">text</span>: <span class="literal">undefined</span>,  <span class="comment">// 文本</span></span><br><span class="line">  <span class="attr">elm</span>: <span class="literal">undefined</span>,   <span class="comment">// 真实dom</span></span><br><span class="line">  <span class="attr">key</span>: <span class="literal">undefined</span>    <span class="comment">// 节点标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文本结点的tag为<code>undefined</code>，children也是空数组，text的值是文本内容</p><h3 id="diff过程"><a href="#diff过程" class="headerlink" title="diff过程"></a>diff过程</h3><img src="..\images\前端面试-vue\diff算法.png" style="zoom:50%"><p>具体过程：当在模板中使用过的响应式数据改变-&gt;触发setter-&gt;触发dep.notify-&gt;通知所有订阅者更新，其中就包括渲染Watcher-&gt;调用渲染Watcher的update方法，将渲染Watcher放到异步更新队列-&gt;清空异步更新队列，调用渲染Watcher的run方法-&gt;调用render方法产生新的VNode-&gt;调用<code>patch</code>方法-&gt;调用<code>isSameVnode</code>判断是否可以复用dom-&gt;如果可以则调用<code>patchVnode</code>方法-&gt;给DOM打补丁。</p><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><ul><li><p>调用<code>patch</code>方法，传入新旧虚拟结点（oldVnode, vnode）</p></li><li><p>没有新节点(vnode&#x3D;undefined)，说明旧的结点该被删除了，直接触发旧节点的<code>destory</code>钩子，移除旧的dom；</p></li><li><p>没有旧节点（oldVnode&#x3D;undefined），说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接使用新的vnode来创建dom，所以要只调用 <code>createElm</code>，将新的vnode转化成真实dom。</p></li><li><p>如果oldVnode, vnode都存在，则调用<code>sameVNode</code>方法，从<code>key，tag</code>等方面判断是否属于同一结点，<strong>如果返回true，表明结点可复用</strong>，则进一步调用<code>patchVNode</code>方法，给dom打补丁；</p></li><li><p>如果<code>sameVNode</code>返回false，说明旧的结点不可复用，则删除旧的dom，直接使用新的vnode创建新的dom。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化后的patch</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span> (<span class="params">oldVnode, vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> elm, parent;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">    <span class="comment">// 相似就去打补丁（增删改）</span></span><br><span class="line">    <span class="title function_">patchVnode</span>(oldVnode, vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相似就整个覆盖，创建新的dom，移除旧的dom</span></span><br><span class="line">    elm = oldVnode.<span class="property">elm</span>;<span class="comment">//获取旧的dom</span></span><br><span class="line">    parent = api.<span class="title function_">parentNode</span>(elm);<span class="comment">//找到旧的dom的父元素</span></span><br><span class="line">    <span class="title function_">createElm</span>(vnode);<span class="comment">//使用新的vnode创建dom，创建的dom可通过vnode.elm拿到</span></span><br><span class="line">    <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">      api.<span class="title function_">insertBefore</span>(parent, vnode.<span class="property">elm</span>, api.<span class="title function_">nextSibling</span>(elm));<span class="comment">//插入新的dom</span></span><br><span class="line">      <span class="title function_">removeVnodes</span>(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//移除旧的dom</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode.<span class="property">elm</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp; a.<span class="property">tag</span> === b.<span class="property">tag</span>;</span><br></pre></td></tr></table></figure><h4 id="patchVNode"><a href="#patchVNode" class="headerlink" title="patchVNode"></a>patchVNode</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (<span class="params">oldVnode, vnode</span>) &#123;</span><br><span class="line">  <span class="comment">//如果新旧虚拟结点完全一样直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(oldVnode === vnode)&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是组件 VNode</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRealComponent</span>(vnode)) &#123;</span><br><span class="line">    <span class="comment">// 组件 VNode 有自己的一套 prepatch 流程</span></span><br><span class="line">    <span class="keyword">const</span> prevComponent = oldVnode.<span class="property">componentInstance</span>;</span><br><span class="line">    <span class="keyword">const</span> hook = vnode.<span class="property">data</span>?.<span class="property">hook</span>;</span><br><span class="line">    <span class="keyword">if</span> (hook &amp;&amp; hook.<span class="property">prepatch</span>) &#123;</span><br><span class="line">      <span class="comment">//这是 Vue 内部定义的一个钩子函数，用于处理组件更新逻辑</span></span><br><span class="line">      hook.<span class="title function_">prepatch</span>(oldVnode, vnode); <span class="comment">// 在这里调用 updateChildComponent</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新节点引用旧节点的dom，此时新的虚拟结点也有自己的dom了，不过还需要打补丁</span></span><br><span class="line">  <span class="keyword">let</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span>;</span><br><span class="line">  <span class="comment">// 获取新结点的子元素</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line">  <span class="comment">// 获取旧结点的子元素</span></span><br><span class="line">  <span class="keyword">const</span> ch = vnode.<span class="property">children</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用update钩子，更新dom的class，style，props</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="title function_">updateAttrs</span>(oldVnode, vnode);</span><br><span class="line">    <span class="title function_">updateClass</span>(oldVnode, vnode);</span><br><span class="line">    <span class="title function_">updateEventListeners</span>(oldVnode, vnode);</span><br><span class="line">    <span class="title function_">updateProps</span>(oldVnode, vnode);</span><br><span class="line">    <span class="title function_">updateStyle</span>(oldVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开始给子元素打补丁</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">text</span> == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="comment">//if (isDef(oldVnode.text)) api.setTextContent(elm, &#x27;&#x27;)</span></span><br><span class="line">      <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) &#123;</span><br><span class="line">      <span class="title function_">removeVnodes</span>(elm, oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) &#123;</span><br><span class="line">      api.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) &#123;</span><br><span class="line">    api.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进一步比较oldVnode, vnode，如果<code>oldVnode === vnode</code>，也就是说新旧虚拟结点完全相同，则直接return，什么也不做。</p></li><li><p>如果新旧虚拟结点不同，拿到对应的真实<code>dom</code>（旧的dom），称为<code>elm</code>，其实就是oldVnode的elm属性，并将<code>oldVnode.elm</code>属性赋值给<code>vnode.elm</code></p></li><li><p><strong>先对dom的属性打补丁</strong>，对属性打补丁其实就是调用各种<code>updateXXX()</code>函数，更新真实dom的各个属性。每个的update函数都类似，就拿<code>updateAttrs()</code>举例看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateAttrs</span> (<span class="params">oldVnode, vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> key, cur, old</span><br><span class="line">  <span class="keyword">const</span> elm = vnode.<span class="property">elm</span></span><br><span class="line">  <span class="keyword">const</span> oldAttrs = oldVnode.<span class="property">data</span>.<span class="property">attrs</span> || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> attrs = vnode.<span class="property">data</span>.<span class="property">attrs</span> || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新/添加属性</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> attrs) &#123;</span><br><span class="line">    cur = attrs[key]</span><br><span class="line">    old = oldAttrs[key]</span><br><span class="line">    <span class="keyword">if</span> (old !== cur) &#123;</span><br><span class="line">      <span class="keyword">if</span> (booleanAttrsDict[key] &amp;&amp; cur == <span class="literal">null</span>) &#123;</span><br><span class="line">        elm.<span class="title function_">removeAttribute</span>(key)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elm.<span class="title function_">setAttribute</span>(key, cur)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除新节点不存在的属性</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> oldAttrs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> attrs)) &#123;</span><br><span class="line">      elm.<span class="title function_">removeAttribute</span>(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下上述代码主要流程：遍历vnode（新的vnode）属性，如果和oldVnode不一样，就调用<code>setAttribute()</code>修改；遍历oldVnode属性，如果不在vnode属性中，就调用<code>removeAttribute()</code>删除，<strong>确保新的dom属性和vnode属性相同</strong>。</p></li><li><p><strong>再对子元素打补丁</strong>：新节点是否是文本节点（文本结点没有子节点），如果是（那么旧结点也是文本结点，否则<code>sameVNode</code>不会返回true，不会执行<code>patchVNode</code>），则直接更新旧的<code>dom</code>的文本内容为新节点的文本内容</p></li><li><p>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新<code>DOM</code>，并且添加进父节点</p></li><li><p>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点的子节点全部都不见了，那么要做的，就是把所有的旧节点的所有子节点删除，也就是直接把<code>DOM</code> 删除。</p></li><li><p>如果oldVnode, vnode都有子节点，且不完全一致，则调用<code>updateChildren</code>，进行子节点之间的比较，<strong>这涉及到diff算法的核心部分。</strong></p></li></ul><h4 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h4><p>在diff比较子节点的过程中，从两边向中间循环比较，在这个循环比较过程中，又会调用<code>sameVNode</code>，<code>patchNode</code>方法，然后<code>patchNode</code>又会调用<code>updateChildren</code>方法。</p><img src="..\images\前端面试-vue\diff算法2.png" style="zoom:50%"><ul><li>只在<strong>同级别对比</strong>，减少比较次数，提高比对性能（sameVnode方法就是同级别比较）</li><li><strong>首尾指针法</strong>：给新旧虚拟结点的子元素数组，都添加首尾指针<ul><li>进行头头，尾尾，头尾，尾头结点比较，判断是否是<code>sameVNode</code></li><li>当任意一个头指针大于它的尾指针，退出循环</li><li>循环结束时，删除&#x2F;添加多余dom</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params">parentElm, oldCh, newCh</span>) &#123;<span class="comment">//传入的参数是新旧虚拟子节点数组</span></span><br><span class="line">  <span class="comment">//首尾指针</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, before</span><br><span class="line">  <span class="comment">//当任意一个头指针大于它的尾指针，退出循环</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// 未定义表示被移动过</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123; <span class="comment">// 头头相似</span></span><br><span class="line">      <span class="comment">//进行一次patch，然后newStartVnode就能拿到对应的dom了，虽然是旧的，还需要打补丁</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode)</span><br><span class="line">      <span class="comment">//指针移动，修改oldStartVnode，newStartVnode</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123; <span class="comment">// 尾尾相似</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode)<span class="comment">//同理，newEndVnode就能拿到对应的dom了，虽然是旧的，还需要打补丁</span></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">// 头尾相似</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode)</span><br><span class="line">      api.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, api.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">// 尾头相似</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode)</span><br><span class="line">      api.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 根据旧子节点的key，生成map映射</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">// 在旧子节点数组中，找到和newStartVnode相似节点的下标</span></span><br><span class="line">      idxInOld = oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123; </span><br><span class="line">        <span class="comment">// 没有key，创建并插入dom</span></span><br><span class="line">        api.<span class="title function_">insertBefore</span>(parentElm, <span class="title function_">createElm</span>(newStartVnode), oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有key，找到对应dom ，移动该dom并在oldCh中置为undefined</span></span><br><span class="line">        elmToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="title function_">patchVnode</span>(elmToMove, newStartVnode)</span><br><span class="line">        oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">        api.<span class="title function_">insertBefore</span>(parentElm, elmToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环结束时，删除/添加多余dom</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    before = <span class="title function_">isUndef</span>(newCh[newEndIdx+<span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].<span class="property">elm</span></span><br><span class="line">    <span class="title function_">addVnodes</span>(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    <span class="title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><ul><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/diff.html#%E4%B8%89%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">面试官：你了解vue的diff算法吗？说说看 | web前端面试 - 面试官系列</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/a/1190000018211084">javascript - Vue源码解析：虚拟dom比较原理 - 个人文章 - SegmentFault 思否</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.337.search-card.all.click&vd_source=00483a04a5a69136669373a8ea522a9b">6分钟彻底掌握vue的diff算法，前端面试不再怕！_哔哩哔哩_bilibili</a></li></ul><h3 id="具体复用方式"><a href="#具体复用方式" class="headerlink" title="具体复用方式"></a>具体复用方式</h3><ul><li><p>在大多数情况下，一个 HTML 标签对应一个 DOM（Document Object Model）元素。DOM元素本身也是一个js对象，不过身上的属性要多得多。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>&lt;div&gt;</code> 标签会被解析为一个 <code>HTMLElement</code> 对象，并且可以通过 JavaScript 访问它，例如使用 <code>document.getElementById(&#39;example&#39;)</code>。</p></li><li><p>如果父元素的虚拟 DOM 发生了变化，但其子元素的虚拟 DOM 没有变化，在大多数情况下，框架会尝试复用子元素的真实 DOM</p></li><li><p>当父元素保持不变，而其子元素发生了变化时，框架会对子树执行 diff 操作来确定哪些部分需要更新。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Initial Message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们修改子元素的内部文本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Updated Message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父元素 <code>&lt;div class=&quot;parent&quot;&gt;</code> 及其属性没有变化，子元素<code>&lt;div class=&quot;child&quot;&gt;</code> 的文本内容从 <code>&#39;Initial Message&#39;</code> 变为 <code>&#39;Updated Message&#39;</code>。由于父组件的虚拟 DOM 没有变化，父元素 <code>&lt;div class=&quot;parent&quot;&gt;</code> 不会被重新创建或替换，而是继续使用现有的真实 DOM 元素。</p></li><li><p>简单的来说，新旧虚拟dom的比较是结点级别的，只要某个结点的新旧虚拟dom未改变，就会复用这个dom结点</p></li></ul><h2 id="说说你对vue中key的理解"><a href="#说说你对vue中key的理解" class="headerlink" title="说说你对vue中key的理解"></a>说说你对vue中key的理解</h2><p>key是给每一个虚拟dom（或者说vnode）的唯一id。在diff过程中，根据key值，可以更<strong>准确</strong>， 更快的找到待比较的虚拟dom，从而优化diff算法，提高dom的复用率。</p><p>如果不设置key，那key值默认就都是undefined，将会按顺序进行<strong>新旧虚拟dom</strong>的比较。</p><p>详细可参考禹神的vue视频：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=00483a04a5a69136669373a8ea522a9b&p=30">030_尚硅谷Vue技术_key作用与原理_哔哩哔哩_bilibili</a></p><h2 id="说说你对keep-alive的理解"><a href="#说说你对keep-alive的理解" class="headerlink" title="说说你对keep-alive的理解"></a>说说你对keep-alive的理解</h2><p>keep-alive是<strong>vue中的内置组件</strong>，包裹动态组件（router-view）时，会缓存不活动的<strong>组件实例</strong>，而不是销毁它们，<strong>防止重复渲染DOM</strong>。</p><p>被缓存的组件会额外多出两个生命周期<code>activated</code>和<code>deactivated</code></p><p>keep-alive可以使用一些<code>属性</code>，来更精细的控制组件缓存。</p><ul><li><code>include</code> - 字符串或正则表达式或者一个数组。只有名称匹配的组件<strong>会</strong>被缓存</li><li><code>exclude</code> - 字符串或正则表达式或者一个数组。任何名称匹配的组件都<strong>不会</strong>被缓存</li><li><code>max</code> - 数字：最多可以缓存多少个组件实例，超出这个数字之后，则<strong>删除第一个</strong>被缓存的组件，由此可以推测存在一个缓存队列，先入先出。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 `v-bind`,动态绑定，表示传入的是正则表达式，而不是字符串) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 (使用 `v-bind，动态绑定，表示传入的是表达式`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>组件名称匹配，组件名称指的到底是什么呢？</strong></p><p>匹配首先检查<strong>组件自身的</strong> <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的<strong>局部注册名称</strong> (父组件 <code>components</code> 选项的<strong>键值</strong>)，匿名组件不能被匹配。</p><p><strong>组件被缓存了，如何获取数据呢？</strong></p><p>借助<code>beforeRouteEnter</code>这个<code>组件内的导航守卫</code>，或者<code>activated</code>生命周期函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">vm</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(vm)</span><br><span class="line">        <span class="comment">// 每次进入路由执行</span></span><br><span class="line">        vm.<span class="title function_">getData</span>()  <span class="comment">// 获取数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">activated</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getData</span>() <span class="comment">// 获取数据</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/keepalive.html#%E4%B8%80%E3%80%81keep-alive-%E6%98%AF%E4%BB%80%E4%B9%88">面试官：说说你对keep-alive的理解是什么？ | web前端面试 - 面试官系列</a>这篇文章中还讲解了keep-alive的实现原理，看起来还是挺复杂的</p></blockquote><p><strong>vue3中的keep-alive的语法不同于vue2</strong></p><p>基础用法，默认缓存所有页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span>//Component可以理解为用来替代router-view的组件,或者说当前活跃的组件</span><br><span class="line">  //keep-alive包裹的不再是router-view而是具体的组件</span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span>//会缓存传入的组件</span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>精确控制具体哪些组件缓存，因为再vue3中使用组件已经不再需要注册，也不需要给组件命名，所以我们控制组件（页面）缓存的依据变成了<strong>页面的路由对象</strong>，而不是组件的名称。同时，我们不再通过给keep-alive标签添加属性来控制哪些组件该被缓存，缓存多少组件，转变为借助<code>v-if</code>，如果某个组件因该被缓存，那么他就会被<code>keep-alive</code>标签包裹。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span>//Component是当前活跃的组件，或者说当前展示的组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span>  <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>/&gt;</span>//获取当前组件对应的路由信息</span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在路由对象中添加meta属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&quot;/keepAliveTest&quot;</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;keepAliveTest&quot;</span>,</span><br><span class="line">   <span class="attr">meta</span>: &#123;</span><br><span class="line">       <span class="attr">keepAlive</span>: <span class="literal">true</span> <span class="comment">//设置页面是否需要使用缓存</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/keepAliveTest/index.vue&quot;</span>)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是就到此位置的话，切换页面的时候会报错：<code>vue3 TypeError: parentComponent.ctx.deactivate is not a function 报错</code></p><p>网上提供的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/zhouning7879/article/details/130639409">解决方案</a>就是给每个component提供一个key。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;route.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;route.meta.isKeepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;route.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.isKeepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>详细可参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6978772143748153381">vue3中使用keep-alive目的：掘金</a></p><h2 id="说说vue中的Mixin"><a href="#说说vue中的Mixin" class="headerlink" title="说说vue中的Mixin"></a>说说vue中的Mixin</h2><p>mixin本质就是一个<strong>js对象</strong>，包含了vue组件<strong>任意功能选项</strong>，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等</p><p>，被用来<strong>分发</strong> <code>Vue</code> 组件中的<strong>可复用功能</strong>。</p><p>可分<strong>为全局混入和局部混入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全局混入&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)<span class="comment">//全局混入</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">mixins</span>:[&#123;<span class="attr">created</span>:<span class="function">()=&gt;</span>&#123;&#125;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果混入组件的时候出现了<strong>功能选项冲突</strong>，一般以组件功能选项为准。</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/mixin.html#%E4%B8%80%E3%80%81mixin%E6%98%AF%E4%BB%80%E4%B9%88">面试官：说说你对vue的mixin的理解，有什么应用场景？ | web前端面试 - 面试官系列</a></p><p>在<strong>vue3</strong>的组合式api中，混入（mixin）显然就没有用武之地了，转而被<code>composable</code>替代，下面就是一个例子，介绍了在vue3中是如何复用代码的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//useCountDown.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&#x27;dayjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">countDown</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Time</span> = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> formatTime = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> dayjs.<span class="title function_">unix</span>(<span class="title class_">Time</span>.<span class="property">value</span>).<span class="title function_">format</span>(<span class="string">&#x27;mm分ss秒&#x27;</span>))</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params">time</span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">Time</span>.<span class="property">value</span> = time</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Time</span>.<span class="property">value</span>--</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Time</span>.<span class="property">value</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(n)</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;订单超时&#x27;</span>)</span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">&#x27;/cartList&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; formatTime, start &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好理解啊，就像大多数编程语言一样，把能实现部分功能的代码<strong>封装成一个函数</strong>，需要的时候再导入这个函数，调用这个函数，和把这些代码直接写在组件中相比，区别只于私有化了变量，需要通过return导出。</p><h2 id="跨域是什么？Vue项目中你是如何解决跨域的呢？"><a href="#跨域是什么？Vue项目中你是如何解决跨域的呢？" class="headerlink" title="跨域是什么？Vue项目中你是如何解决跨域的呢？"></a>跨域是什么？Vue项目中你是如何解决跨域的呢？</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p><strong>跨域</strong>本质是<code>浏览器</code>基于<strong>同源策略</strong>的一种<code>安全手段</code>，它是<strong>浏览器</strong>最核心也最基本的安全功能，服务器间通信不会有跨域的问题。</p><p>所谓同源（即指在同一个域）具有以下三个相同点</p><ul><li>协议相同（protocol）</li><li>主机相同（host）</li><li>端口相同（port）</li></ul><p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域(非同源产生跨域)</p><p>举个例子，我们直接打开 HTML 文件使用的是<code>file:///</code>协议加载，如果文档内部请求了其他<code>网络资源</code>，因为HTTP 请求使用的是 <code>http://</code> 或 <code>https://</code> 协议，协议不同，就发生了跨域。</p><p>和<strong>跨站</strong>有什么区别呢？跨站不涉及协议和端口号，<strong>一般情况下，跨站指的就是主域名不同</strong>，比如<code>www.bilibili.com</code>和<code>game.bilibili.com</code>属于同站。</p><h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li>JSONP</li><li>CORS</li><li>Proxy</li></ul><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><strong>JSONP</strong></h4><ul><li><p>利用了<code>script</code>标签可以<strong>跨域加载脚本</strong></p></li><li><p>动态创建一个script标签，并自定它的src属性为目标服务器的url</p></li><li><p>这个url通常包含一个查询参数，用于指定<strong>客户端上的回调函数名</strong></p></li><li><p>服务端接收到请求后，返回<strong>包含函数调用的js代码</strong>，其中传入函数的参数，就是服务器传递的参数。</p></li><li><p>但jsonp请求有个明显的缺点：只能发送<code>get</code>请求</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">      script.<span class="property">src</span> = <span class="string">&quot;http://127.0.0.1:8081/api/callback?callback=hello&quot;</span></span><br><span class="line">      <span class="comment">//给script标签对象添加监听事件</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">      <span class="comment">//比addEventListener写法简单</span></span><br><span class="line">      <span class="comment">//原始事件监听模型</span></span><br><span class="line">      script.<span class="property">onload</span> = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        script.<span class="title function_">remove</span>()<span class="comment">//调用remove方法删除这个标签</span></span><br><span class="line">      &#125;<span class="comment">//脚本加载后立马删除，监听*onload*事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;onClick()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实还有其他标签可以跨域加载资源，貌似大部分标签都可以跨域加载资源…</p><p><strong>媒体资源</strong></p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>img标签</td><td>可以跨域加载图像资源，但是如果给img标签加上crossorigin属性，那么就会以跨域的方式请求图片资源</td></tr><tr><td>audio和video标签</td><td>可以跨域加载视频，音频</td></tr></tbody></table><p><strong>前端基础三大文件</strong></p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>link标签</td><td>可以跨域加载CSS文件</td></tr><tr><td>iframe标签</td><td>可以跨域加载HTML页面。</td></tr><tr><td>script标签</td><td>可以跨域加载脚本</td></tr></tbody></table><p><strong>crossorigin属性</strong></p><p>虽然上述三大标签默认可以跨域加载资源，但是如果添加了<code>crossorigin</code>属性，情况就不同了，<strong>此时加载资源同样受同源策略限制</strong>，请求这这些资源的时候，会携带<code>Origin</code>头，并且要求响应头中包含<code>Access-Control-Allow-Origin</code>字段。</p><p>尽管 <code>&lt;script&gt;</code> 默认允许跨域加载，但 <code>crossorigin</code> 属性的<strong>核心意义</strong>在于：</p><ol><li><p><strong>调试需求</strong>：前端可以获取跨域脚本的详细错误日志（开发阶段尤其关键）</p></li><li><p><strong>安全增强</strong>：强制验证服务器是否明确允许当前来源（避免滥用第三方资源）。</p></li><li><p>特殊资源要求，例如：</p><ul><li><p><strong>字体文件</strong>：通过 <code>&lt;link&gt;</code> 加载的跨域字体必须使用 <code>crossorigin</code>。</p></li><li><p><strong>ES6 模块</strong>：<code>&lt;script type=&quot;module&quot;&gt;</code> 加载的模块必须启用 CORS，所以说vue3项目打包后，引入js文件的方式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;/assets/index-RPTkaswq.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认添加了<code>crossorigin</code>头。</p></li></ul></li></ol><table><thead><tr><th align="center"><strong>行为</strong></th><th align="center">不加 <code>crossorigin</code></th><th align="center">加 <code>crossorigin</code></th></tr></thead><tbody><tr><td align="center">是否允许跨域加载</td><td align="center">✅ 允许</td><td align="center">✅ 允许（需服务器支持 CORS）</td></tr><tr><td align="center">是否验证 CORS 头</td><td align="center">❌ 不验证</td><td align="center">✅ 必须验证</td></tr><tr><td align="center">错误信息详情</td><td align="center">❌ 仅 <code>Script error.</code>跨域脚本可能包含敏感逻辑或数据，因此浏览器不会将详细的错误信息暴露给非同源页面</td><td align="center">✅ 完整错误信息（需 CORS 允许）</td></tr><tr><td align="center">适用场景</td><td align="center">不关心错误细节的公共库</td><td align="center">需调试或加载字体&#x2F;模块等特殊资源</td></tr></tbody></table><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><strong>Proxy</strong></h4><p>代理（Proxy）也称<code>网络代理</code>，是一种特殊的<code>网络服务</code>，允许一个（一般为客户端）通过<code>代理</code>与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p><p>代理的方式也可以有多种：</p><ul><li><p><strong>在脚手架中配置</strong></p><p>在开发过程中，我们可以在<code>脚手架</code>中配置代理。我们可以通过<code>webpack（或者vite）</code>为我们开起一个**本地服务器(**devServer，域名一般是<code>localhost:8080</code>)，作为请求的<code>代理服务器</code>，所以说，这个本地服务器不仅能<code>部署</code>我们<code>开发打包</code>的资源，还能起到<code>代理</code>作用。</p><p>通过该服务器<code>转发</code>请求至目标服务器，本地代理服务器得到结果再转发给前端，<strong>因为服务器之间通信不存在跨域问题，所以能解决跨域问题。</strong></p><p>打包之后的项目文件，因为脱离了代理服务器，所以说这种方式只能在<code>开发环境</code>使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue.config.js 即vue-cli脚手架（基于webpack）开发的vue项目</span></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">   <span class="comment">//感觉这些信息都是在告诉代理服务器该怎么做</span></span><br><span class="line">   <span class="attr">proxy</span>: &#123;</span><br><span class="line">     <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以/api开头的请求路径</span></span><br><span class="line">       <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 告诉代理服务器 请求的目标服务器地址</span></span><br><span class="line">       <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//告诉代理服务器，请求目标服务器时要修改host(比如localhost:8080-&gt;localhost:3000)</span></span><br><span class="line">       <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 告诉代理服务器，重写路径，移除前缀</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vite.config.js 即vue-create脚手架（基于vite）开发的vue项目</span></span><br><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以/api开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 目标服务器地址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//改变代理服务器请求目标服务器时的host，代理服务器修改host为目标服务器的域名</span></span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>), <span class="comment">// 重写路径，移除前缀</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\跨域.png" style="zoom:85%"><ul><li>可以看到，我们要使用代理，在编写接口时，就不能书写完整的路径，比如就不能直接把请求url写成<code>https://www.sanye.blog/books</code>，这样必然跨域</li><li>我们应该把请求写为<code>/books</code>，部署到本地服务器后加载网页，发起这个请求前，会先自动与<code>域名</code>拼接，实际的请求就变为<code>http://localhost:8080/books</code>，这样就没跨域</li><li>不过确实，这么操作的话，就是在请求本地服务器中的<code>books</code>资源，而不是目标服务器中的，如果我们本地服务器中有这个资源（vue-cli中是public目录下有books文件，无后缀），<strong>那么本地服务器就会把这个资源返回给浏览器，无论我们是否开启了代理</strong></li><li>所以我们实际还要添加<code>/api</code>类似的多余的前缀，来控制我们访问的是本地服务器资源，还是其他服务器上的资源。如果我们请求的的资源在本地服务器不存在，本地服务器会帮我们按照配置的规则进行<code>路径重写</code>，得到正确的请求URL，再向目标服务器请求资源。</li></ul></li><li><p><strong>在服务端开启代理</strong></p><p>其实也不是打包后，就不能通过代理来解决跨域问题，如果我们把<code>打包后的前端资源</code>部署到<code>本地的服务器</code>，比如使用基于<code>node.js</code>的<code>express</code>框架搭建的<code>本地服务器</code>，我们也可以通过配置代理来解决跨域问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>( <span class="string">&#x27;express &#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//其实webpack-dev-server开启代理功能的核心也是这个中间件</span></span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>( <span class="string">&#x27;http-proxy-middleware &#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>( . /public)）<span class="comment">//引入静态资源</span></span><br><span class="line">app.<span class="title function_">use</span>( <span class="string">&#x27;/api&#x27;</span> ,<span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line">	<span class="attr">target</span>: <span class="string">&#x27; https:// www.toutiao.com&#x27;</span>,</span><br><span class="line">	<span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">	<span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">		<span class="string">&#x27;^/api &#x27;</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li><li><p>总之想要配置代理，就离不开一台允许你配置代理的<code>服务器</code>，把打包后的前端资源托管到<code>其他平台</code>，我们也无法来配置代理，也就无法解决跨域问题。</p></li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>CORS （Cross-Origin Resource Sharing），即跨域资源共享，意思就是虽然你在跨域请求我的资源，但是我还是<code>选择性的</code>共享资源给你，浏览器根据<code>响应头</code>中的<code>特定字段</code>，来决定是否拦截<code>跨域请求</code>返回的数据。</p><p>因为需要在<code>响应头</code>上做文章，所以这个工作主要是前后端协调后，由后端负责，至于前后端如何协调，参考<code>简单请求</code>和<code>复杂请求</code>部分。</p><h2 id="如何理解简单请求和复杂请求"><a href="#如何理解简单请求和复杂请求" class="headerlink" title="如何理解简单请求和复杂请求"></a>如何理解简单请求和复杂请求</h2><p>区别二者的关键，就在于<code>请求方法</code>和<code>请求头</code>，简单请求是在请求方法和请求头上，都有严格要求的请求，违背任何一条要求，都将变为复杂请求。</p><table><thead><tr><th></th><th>简单请求</th><th>复杂请求</th></tr></thead><tbody><tr><td>请求方法(携带在请求行中)</td><td>get，post，head</td><td>除get，post，head外的请求方法</td></tr><tr><td>请求头</td><td>满足cors安全规范（一般不修改请求头就是安全的）<code>Content-Type</code> 的值仅限于以下三种之一： <code>application/x-www-form-urlencoded</code> <code>multipart/form-data</code> <code>text/plain</code>，且未自定义其他请求头</td><td>设置了自定义的请求头，或者 <code>Content-Type</code> 的值不是上述三种之一</td></tr></tbody></table><p>在非跨域情况下，区分二者并没有什么意义，但是在跨域情况下，发送复杂请求前，会先发送一次<code>预检请求</code>，请求方法为<code>options</code>，</p><p>在请求头中携带<code>Origin</code>，<code>Access-Control-Request-Method</code>，<code>Access-Control-Request-Headers</code>字段，询问服务器是否接受来自xxx源，请求方法为xxx，请求头为xxx的<code>跨域复杂请求</code>，如果接受，才发送这样的<code>复杂请求</code>。</p><img src="..\images\前端面试-vue\options.jpg" style="zoom:80%"><p>服务端处理代码（以express框架为例）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">options</span>( <span class="string">&#x27;/students &#x27;</span>,<span class="function">(<span class="params"> req,res</span>)=&gt;</span>&#123;</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> , <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>)</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods &#x27;</span> , <span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers &#x27;</span> ,<span class="string">&#x27;school&#x27;</span>）</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Max-Age &#x27;</span> , <span class="number">7200</span>)<span class="comment">//告诉浏览器在7200s内不要再发送预检请求询问</span></span><br><span class="line">	res.<span class="title function_">send</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样处理起来明显比较繁琐，实际上我们借助<code>CORS中间件</code>就能统一处理<code>简单请求和复杂请求（包括预检请求）</code>的跨域问题。</p><p><strong>head请求</strong></p><p>HTTP请求方法 <code>HEAD</code> ，是一种用于请求<strong>资源元信息</strong>的请求方法，它与 <code>GET</code> 请求类似，但有一个关键的区别：服务器在响应中不会返回消息体（即实际的内容），只返回头部信息（Headers）。这意味着当你发送一个 <code>HEAD</code> 请求时，你只会收到关于该资源的元数据，例如内容类型、大小、最后修改时间等，而不会收到文档的实际内容。</p><p>使用场景</p><ul><li><strong>检查资源的状态</strong>：可以用来检查资源是否存在、获取资源的最新修改时间或其他头部信息，而不必下载整个资源。</li><li><strong>测试链接的有效性</strong>：在不加载整个页面或资源的情况下，验证URL的有效性和可访问性。</li><li><strong>性能优化</strong>：在需要了解文件大小以准备接收之前，可以通过 <code>HEAD</code> 请求先获取文件的大小信息。这在处理大文件下载前特别有用，因为它允许客户端决定是否继续下载。</li><li><strong>缓存验证</strong>：可以用来检查本地缓存的副本是否仍然有效，通过比较缓存中的头部信息和服务器返回的头部信息。</li></ul><h2 id="vue项目如何部署？有遇到布署服务器后刷新404问题吗"><a href="#vue项目如何部署？有遇到布署服务器后刷新404问题吗" class="headerlink" title="vue项目如何部署？有遇到布署服务器后刷新404问题吗"></a>vue项目如何部署？有遇到布署服务器后刷新404问题吗</h2><h3 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h3><p>前后端分离开发模式下，前后端是<strong>独立布署</strong>的，前端只需要将最后的构建物，上传至目标服务器的<code>web</code>容器指定的<code>静态目录</code>下即可，我们知道<code>vue</code>项目在构建打包后，是生成一系列的静态文件。</p><h3 id="404问题"><a href="#404问题" class="headerlink" title="404问题"></a>404问题</h3><p>HTTP 404 错误意味着链接指向的资源不存在，问题在于为什么不存在？且为什么只有<code>history</code>模式下会出现这个问题，而hash模式下不会有?</p><p>history模式，刷新页面，<code>前端路由部分</code>会被当作<code>请求URL</code>的一部分发送给服务器，然而服务器<code>并没有相关配置</code>，所以<code>响应404</code>。</p><p>而hash模式，前端路由在URL的<code>#</code>后面，不会被当作请求URL的一部分。</p><p>要解决使用history路由的项目，刷新页面出现的404问题，必须和<code>后端</code>沟通，当请求的页面不存在时，返回<code>index.html</code>，把页面控制权全交给<code>前端路由</code>。</p><p>但是这样有个问题，就是后端服务器不会再响应<code>404</code>错误了，当找不到请求的资源总是会返回index.html，即便请求的资源在前后端中都不存在（即把页面控制权交给前端路由，也没有对应的页面），所以为了避免这种情况，应该在 Vue应用里面<code>覆盖所有的路由情况</code>，最后给出一个 <code>404 页面</code>(虽然说是404页面，但是响应状态码是200，因为返回了<code>index.html</code>)，<strong>简单的来说404页面需要前端来设计</strong></p><h3 id="直接打开页面空白问题"><a href="#直接打开页面空白问题" class="headerlink" title="直接打开页面空白问题"></a>直接打开页面空白问题</h3><p>直接打开页面，页面空白本质就是因为<strong>js文件加载失败</strong></p><p>因为我们开发的是单页面应用程序，需要借助js操作dom来更新页面，而本身的html文件中并没有任何结构，所以如果js文件加载失败，页面就不会有任何结构，所以显示空白。</p><p>那为什么js文件会加载失败呢，原因分为两种，<strong>一种是加载js文件的路径错误</strong>，这通常出现在使用绝对资源路径的情况（使用history路由），为了得到最终的路径还会和盘符（C:或者D:）拼接，所以找不到资源。</p><p>还有一种是请求资源的时候<strong>跨域</strong>了，为什么会跨域了，我们加载的不是本地的js文件文件吗？确实，加载本地资源出现跨域，导致资源加载失败的问题，只会出现在vue3项目中，而vue2项目中不会有这个问题，为什么呢？vue3默认使用<code>vite</code>构建工具，打包后会生成基于<code>esm</code>的代码，<strong>浏览器在<code>file://</code>协议下加载<code>esm</code>时，会触更严格的跨域安全策略</strong>，导致本地的css，js文件也被视为<code>跨域资源</code>，所以资源加载失败</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以观察到这个模块的type=&#x27;module&#x27;，这意味着这个js文件内使用了esm语法（比如import），这个js文件成为了esm--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;/assets/index-RPTkaswq.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而vue2项目通常使用<code>webpack</code>打包，生成的代码通常以<code>传统脚本</code>的形式加载，此时浏览器对<code>file://</code>协议的跨域闲置比较宽松。</p><h2 id="Vue2与Vue3有什么不同"><a href="#Vue2与Vue3有什么不同" class="headerlink" title="Vue2与Vue3有什么不同"></a>Vue2与Vue3有什么不同</h2><h3 id="响应式实现方法不同"><a href="#响应式实现方法不同" class="headerlink" title="响应式实现方法不同"></a>响应式实现方法不同</h3><ul><li><p>vue2的响应式是基于<code>Object.defineProperty</code>实现的，只能监听已有属性的getter和setter，当删除一个属性或者添加一个属性的时候，vue无法监听到。为了解决这个问题，vue2中提供了<code>this.$set()，this.$delete</code> 这2个API。<code>this.$set(obj,key,value)</code>的本质就是使用<code>Object.defineProperty</code>响应式地为<code>obj</code>添加一个属性key，并通知这个对象(obj)的订阅者更新（因为vue为每一个对象都创建了一个dep）。<code>this.$delete</code>本质应该就是删除一个属性，然后通知这个对象(obj)的订阅者更新。除此之外还重写了数组的原型方法，如<code>push</code>、<code>pop</code>、<code>splice</code>等，使得这些方法在被调用时能够触发视图的更新。</p></li><li><p>而在vue3中，响应式是基于Proxy实现的。new Proxy并传入一个源对象，返回一个代理对象，修改这个代理对象会映射到源对象。使用Proxy监听的是整个对象，而不是对象的属性，所以能监听到对对象的增删改查。</p></li><li><p>Vue2通过<code>Object.defineProperty()</code>进行数据劫持，<strong>需要遍历所有属性</strong>，有一定性能开销。Vue3使用Proxy代理数据，直接监听对象，减少遍历属性时间，而且是按需添加响应式的，性能更好。</p></li></ul><h3 id="API风格不同"><a href="#API风格不同" class="headerlink" title="API风格不同"></a>API风格不同</h3><p>在vue2使用的是选项式api，在vue3中既可以使用组合式api，又可以使用选项式api。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p><strong>组件注册方式不同</strong>：Vue3导入组件后，也不需要在components里注册</p></li><li><p><strong>模板语法不同</strong>：Vue2中模板里只能有一个根标签，而在Vue3里可以有多个，因为这些根标签都会被<code>fragment</code>标签包裹</p></li></ul><h2 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h2><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改对象的现有属性，并返回此对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个对象，将这个对象转变成响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用Object.keys可比使用for in 然后再使用hasOwnProperty判断方便多了</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="comment">//如果存在嵌套对象的情况，则递归添加响应式。</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> val == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">observe</span>(val) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                <span class="comment">//当给key赋值为对象的时候，还需要在set方法中给这个对象也添加响应式。</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                    <span class="title function_">observe</span>(newVal)</span><br><span class="line">                &#125;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="comment">//调用update方法，做一些更新视图的工作，依赖这个属性的视图，计算属性，watch都会更新或执行一些逻辑</span></span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="title function_">observe</span>(arrData)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">//无响应</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">//无响应</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">//ok，有响应</span></span><br></pre></td></tr></table></figure><p><strong>缺点小结</strong></p><ul><li><code>Object.defineProperty</code>无法监听到数组方法对数组元素的修改</li><li>需要遍历对象每个属性<code>逐个添加监听</code>，而且无法监听到<code>对象属性</code>的<code>添加</code>与<code>删除</code>，如果属性值是嵌套对象，还深层监听，造成性能问题。</li></ul><h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a>Proxy</h3><p><code>Proxy</code>的监听是<code>整个对象</code>，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p><p>定义一个响应式方法<code>reactive</code>，这个<code>reactive</code>方法，就是vue3中的<code>reactive</code>方法的<strong>简化版</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下简单数据的操作，发现都能劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">//输出：&quot;获取foo:foo&quot;</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">//输出：&quot;设置foo:fooooooo&quot;</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// 输出：&quot;设置dong:dong&quot;</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// 输出：&quot;删除dong:true&quot;</span></span><br></pre></td></tr></table></figure><p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终结果- 输出：&quot;获取bar:[object Object]&quot;</span></span><br><span class="line"><span class="comment">//因为 state.bar 就是在访问bar属性，触发getter，所以输出：&quot;获取bar:[object Object]&quot;，并且返回&#123;a:1&#125;</span></span><br><span class="line"><span class="comment">//然后访问&#123;a:1&#125;的a属性，由于&#123;a:1&#125;是个普通对象，所以不会触发对应的getter</span></span><br><span class="line"><span class="comment">//简单的来说，这个操作进行了两次属性访问，但是只触发了一次getter</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> </span><br></pre></td></tr></table></figure><p>如果要解决，需要在<code>get</code>之上再进行一层代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="comment">//如果返回的对象是一个object，则给这个对象添加响应式</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> res===<span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改后输出的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取<span class="attr">bar</span>:[object <span class="title class_">Object</span>]</span><br><span class="line">设置<span class="attr">a</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure><p>由此可以看出，Proxy是<strong>按需添加响应式</strong>的，只有当我们取出的值是一个对象的时候，Proxy才会递归给这个对象添加响应式。而在<code>Object.defineProperty</code>中是直接递归添加响应式的。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>Object.defineProperty</code>这个方法存在许多缺点，比如必须<code>遍历对象</code>的所有属性<code>逐个添加监听</code>，而且无法监听对象属性的增加与删除，如果属性的值是<code>引用类型</code>还需要<code>深度监听</code>，造成<code>性能问题</code>。</p><p>对于数组，<code>Object.defineProperty</code>方法无法监听到数组方法，对数组元素的修改，需要重写数组方法。</p><p>而Proxy能监听整个对象的变化，也能监听到数组方法对数组元素的修改。</p><h2 id="说说Vue-3-0中Treeshaking特性？"><a href="#说说Vue-3-0中Treeshaking特性？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？"></a>说说Vue 3.0中Treeshaking特性？</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p><code>Tree shaking</code> 是一种通过<strong>清除多余js代码</strong>方式，来<code>优化项目打包体积</code>的技术。Vue3源码实现了<strong>高度的ESM模块化</strong>，更好的支持Tree-shaking。</p><h3 id="如何做-2"><a href="#如何做-2" class="headerlink" title="如何做"></a>如何做</h3><p><code>Tree shaking</code>是基于<code>ES6</code>模块语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的<code>静态编译</code>思想，<strong>在<code>编译时</code>就能确定模块的依赖关系</strong>，以及输入和输出的变量。</p><p><code>Tree shaking</code>无非就是做了两件事：</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些函数和变量未被使用或者引用，进而删除对应代码</li></ul><p>那么为什么使用 CommonJs、AMD 等模块化方案无法支持 Tree Shaking 呢？</p><p>因为在 CommonJs、AMD、CMD 等旧版本的 js 模块化方案中，导入导出行为是<strong>高度动态</strong>，难以预测的，只能在<code>代码运行的时候</code>确定所有模块的依赖关系，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句，只能出现在<strong>模块顶层</strong>，可以理解为全局作用域；且导入导出的模块名必须为字符串常量，这意味着下述代码在 ESM 方案下是非法的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，ESM 模块之间的依赖关系是<code>高度确定</code>的，与运行状态无关，编译工具只需要对 ESM 模块做<code>静态语法分析</code>，就可以从代码字面量中，推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。</p><p>关于<code>tree-shaking</code>更多内容参考：<a href="https://www.sanye.blog/posts/762e27cc.html">前端面试—webpack | 三叶的博客</a></p><p>关于<code>cjs和esm</code>的更多内容参考：<a href="http://www.sanye.blog/posts/3418e521.html">nodejs | 三叶的博客</a></p><h2 id="Composition-Api-与-Options-Api-有什么不同？"><a href="#Composition-Api-与-Options-Api-有什么不同？" class="headerlink" title="Composition Api 与  Options Api 有什么不同？"></a>Composition Api 与 Options Api 有什么不同？</h2><ul><li><p>代码组织方式：选项式api按照<code>代码的类型</code>来组织代码；而组合式api按照<code>代码的逻辑</code>来组织代码，逻辑紧密关联的代码会被放到一起。</p></li><li><p>代码复用方式：在选项式api这，我们使用<code>mixin</code>来实现代码复用，使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候，就存在两个非常明显的问题：<code>命名冲突</code>和<code>数据来源不清晰</code></p><p>而在组合式api中，我们可以将一些可复用的代码抽离出来作为<code>一个函数</code>并导出，在需要在使用的地方导入后直接调用即可。这个种<code>模块化</code>的方式，既解决了<code>命名冲突</code>的问题，也解决了<code>数据来源不清晰</code>的问题。更多内容参考前文《Vue3做了哪些优化？》</p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog">三叶sanye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog/posts/f33bd2b9.html">https://www.sanye.blog/posts/f33bd2b9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.sanye.blog" target="_blank">三叶的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/%E5%B0%8F%E9%95%87.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/aef189c3.html" title="js"><img class="cover" src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">js</div></div><div class="info-2"><div class="info-item-1">js学习笔记</div></div></div></a><a class="pagination-related" href="/posts/c0add594.html" title="前端面试---网络"><img class="cover" src="/images/cover/%E4%BA%91%E6%B9%96%E5%B0%91%E5%A5%B3.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">前端面试---网络</div></div><div class="info-2"><div class="info-item-1">前端网络学习笔记</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8b27fabc.html" title="vue"><img class="cover" src="/images/cover/yourname.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="info-item-2">vue</div></div><div class="info-2"><div class="info-item-1">vue2，vue3学习笔记</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/%E4%B8%89%E5%8F%B6.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">三叶sanye</div><div class="author-info-description">记录学习，分享知识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a><a href="/gallery/"><div class="headline">图库</div><div class="length-num">∞</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="Bilibli"><i class="fa-brands fa-bilibili" style="color:#74c0fc"></i></a><a class="social-icon" href="https://github.com/syhy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:3519450570@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2"><span class="toc-number">1.</span> <span class="toc-text">Vue2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">说说你对vue的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">前端发展背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">Vue是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">Vue核心特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="toc-number">1.2.</span> <span class="toc-text">Vue的学习路线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">原生开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">非单文件组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">非单文件组件使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">单文件组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#render"><span class="toc-number">1.3.</span> <span class="toc-text">render</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateElement"><span class="toc-number">1.3.2.</span> <span class="toc-text">CreateElement</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Vue-extend"><span class="toc-number">1.3.2.0.1.</span> <span class="toc-text">Vue.extend()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.</span> <span class="toc-text">说说Vue实例挂载过程中发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">vue构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init"><span class="toc-number">1.4.2.</span> <span class="toc-text">_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initInjections%E5%92%8CinitProvide"><span class="toc-number">1.4.3.</span> <span class="toc-text">initInjections和initProvide</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initState"><span class="toc-number">1.4.4.</span> <span class="toc-text">initState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initProps"><span class="toc-number">1.4.5.</span> <span class="toc-text">initProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initMethods"><span class="toc-number">1.4.6.</span> <span class="toc-text">initMethods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initData"><span class="toc-number">1.4.7.</span> <span class="toc-text">initData</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#proxy"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#observe"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">observe</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Observer"><span class="toc-number">1.4.7.2.1.</span> <span class="toc-text">Observer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defineReactive"><span class="toc-number">1.4.7.2.2.</span> <span class="toc-text">defineReactive</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dep"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">Dep</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dep-target"><span class="toc-number">1.4.7.3.1.</span> <span class="toc-text">Dep.target</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#subs"><span class="toc-number">1.4.7.3.2.</span> <span class="toc-text">subs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dep-depend"><span class="toc-number">1.4.7.3.3.</span> <span class="toc-text">dep.depend</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dep-notify"><span class="toc-number">1.4.7.3.4.</span> <span class="toc-text">dep.notify</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Watcher"><span class="toc-number">1.4.7.4.</span> <span class="toc-text">Watcher</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.7.4.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getter"><span class="toc-number">1.4.7.4.2.</span> <span class="toc-text">getter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get"><span class="toc-number">1.4.7.4.3.</span> <span class="toc-text">get</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#update"><span class="toc-number">1.4.7.4.4.</span> <span class="toc-text">update</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#run"><span class="toc-number">1.4.7.4.5.</span> <span class="toc-text">run</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93Watcher"><span class="toc-number">1.4.7.4.6.</span> <span class="toc-text">渲染Watcher</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#mountComponent"><span class="toc-number">1.4.7.4.6.1.</span> <span class="toc-text">mountComponent</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#render-1"><span class="toc-number">1.4.7.4.6.2.</span> <span class="toc-text">_render</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#update-1"><span class="toc-number">1.4.7.4.6.3.</span> <span class="toc-text">_update</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.7.4.6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7Watcher"><span class="toc-number">1.4.7.4.7.</span> <span class="toc-text">计算属性Watcher</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.7.4.7.1.</span> <span class="toc-text">配置方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#initComputed"><span class="toc-number">1.4.7.4.7.2.</span> <span class="toc-text">initComputed</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#defineComputed"><span class="toc-number">1.4.7.4.7.3.</span> <span class="toc-text">defineComputed</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#createComputedGetter"><span class="toc-number">1.4.7.4.7.4.</span> <span class="toc-text">createComputedGetter</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89Watcher"><span class="toc-number">1.4.7.4.8.</span> <span class="toc-text">用户自定义Watcher</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F-1"><span class="toc-number">1.4.7.4.8.1.</span> <span class="toc-text">配置方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#initWatcher"><span class="toc-number">1.4.7.4.8.2.</span> <span class="toc-text">initWatcher</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.7.4.9.</span> <span class="toc-text">对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vm-mount"><span class="toc-number">1.4.8.</span> <span class="toc-text">vm.$mount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mountComponent-1"><span class="toc-number">1.4.9.</span> <span class="toc-text">mountComponent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.5.</span> <span class="toc-text">Vue组件通信的方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">组件间通信的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.5.2.</span> <span class="toc-text">组件间通信的方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#props%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">props传递数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">深入理解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emit-%E8%A7%A6%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">$emit 触发自定义事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">EventBus(事件总线)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#provide-%E4%B8%8E-inject"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">provide 与 inject</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">1.5.2.5.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-1"><span class="toc-number">1.5.2.5.2.</span> <span class="toc-text">深入理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8Eprops%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.2.5.3.</span> <span class="toc-text">与props的比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vuex"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">Vuex</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9el%E5%92%8Ctemplate%E5%B1%9E%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">谈谈对el和template属性的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.7.</span> <span class="toc-text">说说Vue的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue2%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">Vue2中的生命周期函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-2"><span class="toc-number">1.7.3.</span> <span class="toc-text">深入理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.8.</span> <span class="toc-text">说说你对vue双向绑定的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.8.2.</span> <span class="toc-text">双向绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-observable%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%9C%8B"><span class="toc-number">1.9.</span> <span class="toc-text">Vue.observable你有了解过吗？说说看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BB%99%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E8%A7%86%E5%9B%BE%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text">如何解决给对象添加属性视图不刷新的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.10.1.</span> <span class="toc-text">为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.10.2.</span> <span class="toc-text">如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9slot%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9Fslot%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">说说你对slot的理解？slot使用场景有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD"><span class="toc-number">1.11.1.</span> <span class="toc-text">默认插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="toc-number">1.11.2.</span> <span class="toc-text">具名插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="toc-number">1.11.3.</span> <span class="toc-text">作用域插槽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%9C%89%E5%86%99%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%90%97%EF%BC%9F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">你有写过自定义指令吗？自定义指令的应用场景有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">1.12.1.</span> <span class="toc-text">什么是指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.2.</span> <span class="toc-text">如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">注册自定义指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">定义自定义指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.12.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.13.</span> <span class="toc-text">Vue常用的修饰符有哪些有什么应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.13.1.</span> <span class="toc-text">修饰符是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8"><span class="toc-number">1.13.2.</span> <span class="toc-text">修饰符的具体作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">表单修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">事件修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">Vue中组件和插件有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.14.1.</span> <span class="toc-text">组件是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.14.2.</span> <span class="toc-text">插件是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.3.</span> <span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">编写形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">注册形式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA"><span class="toc-number">1.15.</span> <span class="toc-text">SPA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSPA%EF%BC%8C%E5%92%8CMPA%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.15.1.</span> <span class="toc-text">什么是SPA，和MPA有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0SPA"><span class="toc-number">1.15.2.</span> <span class="toc-text">如何实现SPA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-number">1.15.3.</span> <span class="toc-text">如何提高首屏加载速度？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">使用路由懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">缓存静态资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99script%E6%A0%87%E7%AD%BE%E6%B7%BB%E5%8A%A0defer%E6%88%96%E8%80%85async%E5%B1%9E%E6%80%A7"><span class="toc-number">1.15.3.3.</span> <span class="toc-text">给script标签添加defer或者async属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E7%AD%89js%EF%BC%8Ccss%EF%BC%8Chtml%E7%AD%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.15.3.4.</span> <span class="toc-text">压缩等js，css，html等静态资源的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E9%A6%96%E5%B1%8F%E5%85%B3%E9%94%AEjs%EF%BC%8Ccss"><span class="toc-number">1.15.3.5.</span> <span class="toc-text">内联首屏关键js，css</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Ehttp%E8%AF%B7%E6%B1%82%E4%BC%98%E5%8C%96"><span class="toc-number">1.15.3.6.</span> <span class="toc-text">从http请求优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR"><span class="toc-number">1.15.3.7.</span> <span class="toc-text">使用服务端渲染SSR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98SPA%E7%9A%84SEO"><span class="toc-number">1.15.4.</span> <span class="toc-text">如何提高SPA的SEO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E8%B7%AF%E7%94%B1%E5%92%8Chistory%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">hash路由和history路由的实现原理，二者有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E8%B7%AF%E7%94%B1"><span class="toc-number">1.16.1.</span> <span class="toc-text">hash路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.16.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.16.1.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A"><span class="toc-number">1.16.1.3.</span> <span class="toc-text">如何做</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history%E8%B7%AF%E7%94%B1"><span class="toc-number">1.16.2.</span> <span class="toc-text">history路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">1.16.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.16.2.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-1"><span class="toc-number">1.16.2.3.</span> <span class="toc-text">如何做</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%A6%82%E4%BD%95%E5%81%9A%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.</span> <span class="toc-text">vue如何做前端性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.1.</span> <span class="toc-text">编码优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E8%B5%84%E6%BA%90%E4%BD%93%E7%A7%AF"><span class="toc-number">1.17.2.</span> <span class="toc-text">减少资源体积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.3.</span> <span class="toc-text">加载优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.4.</span> <span class="toc-text">http请求优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">1.17.4.1.</span> <span class="toc-text">减少http请求的次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.17.4.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.18.</span> <span class="toc-text">v-if和v-for的优先级是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">1.19.</span> <span class="toc-text">v-if和v-show如何理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">1.19.1.</span> <span class="toc-text">共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">1.19.2.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9nextTick%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.20.</span> <span class="toc-text">说说你对nextTick的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.20.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.20.2.</span> <span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%AD%A4%E6%97%B6DOM%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.20.3.</span> <span class="toc-text">如何确保此时DOM是最新的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">什么是虚拟DOM？有什么作用？如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8js%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.21.1.</span> <span class="toc-text">在js中的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.21.2.</span> <span class="toc-text">虚拟DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VNode"><span class="toc-number">1.21.2.1.</span> <span class="toc-text">VNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.21.2.2.</span> <span class="toc-text">创建虚拟DOM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Vue%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.21.3.</span> <span class="toc-text">在Vue中的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4diff%E7%AE%97%E6%B3%95"><span class="toc-number">1.22.</span> <span class="toc-text">说说diff算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">1.22.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff%E8%BF%87%E7%A8%8B"><span class="toc-number">1.22.2.</span> <span class="toc-text">diff过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#patch"><span class="toc-number">1.22.2.1.</span> <span class="toc-text">patch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#patchVNode"><span class="toc-number">1.22.2.2.</span> <span class="toc-text">patchVNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateChildren"><span class="toc-number">1.22.2.3.</span> <span class="toc-text">updateChildren</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.22.3.</span> <span class="toc-text">具体复用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E4%B8%ADkey%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.23.</span> <span class="toc-text">说说你对vue中key的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.24.</span> <span class="toc-text">说说你对keep-alive的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4vue%E4%B8%AD%E7%9A%84Mixin"><span class="toc-number">1.25.</span> <span class="toc-text">说说vue中的Mixin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FVue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">跨域是什么？Vue项目中你是如何解决跨域的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">1.26.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-1"><span class="toc-number">1.26.2.</span> <span class="toc-text">如何解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-number">1.26.2.1.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy"><span class="toc-number">1.26.2.2.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-number">1.26.2.3.</span> <span class="toc-text">CORS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82"><span class="toc-number">1.27.</span> <span class="toc-text">如何理解简单请求和复杂请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%EF%BC%9F%E6%9C%89%E9%81%87%E5%88%B0%E5%B8%83%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%88%B7%E6%96%B0404%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">1.28.</span> <span class="toc-text">vue项目如何部署？有遇到布署服务器后刷新404问题吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2"><span class="toc-number">1.28.1.</span> <span class="toc-text">如何部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#404%E9%97%AE%E9%A2%98"><span class="toc-number">1.28.2.</span> <span class="toc-text">404问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%E7%A9%BA%E7%99%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.28.3.</span> <span class="toc-text">直接打开页面空白问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2%E4%B8%8EVue3%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">1.29.</span> <span class="toc-text">Vue2与Vue3有什么不同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-number">1.29.1.</span> <span class="toc-text">响应式实现方法不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E9%A3%8E%E6%A0%BC%E4%B8%8D%E5%90%8C"><span class="toc-number">1.29.2.</span> <span class="toc-text">API风格不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.29.3.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Proxy-API-%E6%9B%BF%E4%BB%A3-defineProperty-API-%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defineProperty"><span class="toc-number">1.30.1.</span> <span class="toc-text">defineProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-1"><span class="toc-number">1.30.2.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.30.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue-3-0%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">说说Vue 3.0中Treeshaking特性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-number">1.31.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-2"><span class="toc-number">1.31.2.</span> <span class="toc-text">如何做</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Composition-Api-%E4%B8%8E-Options-Api-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.32.</span> <span class="toc-text">Composition Api 与 Options Api 有什么不同？</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image:url(/images/cover/云湖少女.png)"><div id="footer-wrap"><div class="footer_custom_text"><div id="sanye"><svg class="icon" aria-hidden="true"><use href="#icon-banquan"></use></svg><span>2024 - 2025 By 三叶sanye</span><svg class="icon" aria-hidden="true"><use href="#icon-sanyecao"></use></svg></div><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/time.js" defer></script><script src="/iconfont/iconfont.js"></script><script src="/bilibiliBanner/banner.js" defer></script><script src="/gallery/background.js" defer></script><script src="/animeClips/play/index.js" defer></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="/js/busuanzi.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?82b9a7c4e8fee04e39b57c7d4ffd9832"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,display:{position:"left",width:132,height:264},mobile:{show:!0},react:{opacity:.7},dialog:{enable:!1,hitokoto:!1},model:{jsonPath:"/live2d/live2d.json"}})</script></body></html>