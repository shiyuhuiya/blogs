<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>js | 三叶的博客</title><meta name="author" content="三叶sanye"><meta name="copyright" content="三叶sanye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="js学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="js"><meta property="og:url" content="https://www.sanye.blog/posts/aef189c3.html"><meta property="og:site_name" content="三叶的博客"><meta property="og:description" content="js学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.sanye.blog/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg"><meta property="article:published_time" content="2024-12-13T11:39:03.000Z"><meta property="article:modified_time" content="2025-09-01T04:20:12.554Z"><meta property="article:author" content="三叶sanye"><meta property="article:tag" content="js"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.sanye.blog/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.sanye.blog/posts/aef189c3.html"><link rel="preconnect"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",(()=>{void 0===t.get("theme")&&(e.matches?o():a())}))}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-center"},infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"js",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/iconfont/iconfont.css"><link rel="stylesheet" href="/bilibiliBanner/banner.css"><link rel="stylesheet" href="/gallery/background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i:0"></div><div class="iron-coil" style="--i:1"></div><div class="iron-coil" style="--i:2"></div><div class="iron-coil" style="--i:3"></div><div class="iron-coil" style="--i:4"></div><div class="iron-coil" style="--i:5"></div><div class="iron-coil" style="--i:6"></div><div class="iron-coil" style="--i:7"></div></div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/%E4%B8%89%E5%8F%B6.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-location-dot"></i> <span>分站</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://www.sanye.blog"><i class="fa-fw fa-solid fa-location-dot"></i> <span>vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.sanye.space"><i class="fa-fw fa-solid fa-location-dot"></i> <span>阿里云</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i> <span>图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/cover/秘密风景.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name iconfont icon-sanyecao">三叶的博客</span></a><a class="nav-page-title" href="/"><span class="site-name iconfont icon-sanyecao">js</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-location-dot"></i> <span>分站</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://www.sanye.blog"><i class="fa-fw fa-solid fa-location-dot"></i> <span>vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.sanye.space"><i class="fa-fw fa-solid fa-location-dot"></i> <span>阿里云</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i> <span>图库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">js<a class="post-edit-link" href="https://github.com/shiyuhuiya/shiyuhuiya.github.io/issues_posts/javascript.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-13T11:39:03.000Z" title="发表于 2024-12-13 19:39:03">2024-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-01T04:20:12.554Z" title="更新于 2025-09-01 12:20:12">2025-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/js/">js</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">48.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>173分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-09-01 12:20:12&quot;}" hidden></div><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>参考文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/a/1190000012925872#item-3">javascript - 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 - 程序生涯 - SegmentFault 思否</a></p><ul><li>浏览器是多进程的，操作系统给它的每个进程都分配了资源（cpu、内存）</li><li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上（一个Tab页面就是一个进程）</li></ul><h3 id="浏览器都包含哪些进程？"><a href="#浏览器都包含哪些进程？" class="headerlink" title="浏览器都包含哪些进程？"></a><strong>浏览器都包含哪些进程？</strong></h3><h4 id="Browser进程"><a href="#Browser进程" class="headerlink" title="Browser进程"></a><strong>Browser进程</strong></h4><p>也叫做浏览器的<strong>主控进程</strong>，只有一个。如果自己打开任务管理器，然后打开一个浏览器，就可以看到：<strong>任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）</strong>，</p><p>作用包括</p><ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul><h4 id="其他进程"><a href="#其他进程" class="headerlink" title="其他进程"></a>其他进程</h4><ul><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制等</li></ul><h4 id="浏览器渲染进程"><a href="#浏览器渲染进程" class="headerlink" title="浏览器渲染进程"></a>浏览器渲染进程</h4><p>Renderer进程，<strong>是我们最关心的进程</strong>，内部是<strong>多线程</strong>的：默认每个Tab页面就是一个渲染进程，互不影响。可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行，<strong>也就是说这个渲染进程是多线程的</strong>。那么接下来看看它都包含了哪些<strong>线程</strong>（列举一些主要常驻线程）：</p><ol><li><p>GUI渲染线程：负责渲染浏览器界面，<strong>解析HTML，CSS，构建DOM树和CSSOM树，最终得到渲染树，然后进行布局和绘制</strong>。</p></li><li><p>事件触发线程</p></li><li><p>定时触发器线程：注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p></li><li><p>异步http请求线程</p></li></ol><p>然而，一个渲染进程中的实际线程，真的是这些吗？非也！就拿<code>渲染线程</code>和<code>JS线程</code>来说，它们并不是独立的线程<strong>，而是同一个线程（主线程）的不同名称或职责描述</strong></p><h5 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h5><p>参考文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/a/1190000041729574">javascript - JS阻塞渲染，这么多年我理解错啦？ - 个人文章 - SegmentFault 思否</a></p><p>在浏览器的<strong>渲染进程中</strong>：</p><ul><li><p><strong>主线程（Main Thread）</strong> 是唯一负责<code>执行JavaScript代码</code>和<code>处理渲染任务</code>的线程。</p><p>职责：</p><ul><li>执行JavaScript：解析并运行所有同步JS代码。</li><li>处理渲染任务：解析HTML&#x2F;CSS、构建DOM&#x2F;CSSOM树、布局、绘制等。</li><li>事件循环：管理宏任务、微任务队列，处理异步事件（如定时器、网络请求回调）。</li></ul><p>特点：</p><ul><li><p>主线程是<strong>单线程</strong>，所以同一时间只能执行<strong>JS代码或渲染任务中的一项</strong>。这就是为什么我们常说，**”js线程”和”渲染线程”是互斥的**。</p></li><li><p>如果JS代码长时间运行（如复杂循环），会<strong>完全阻塞渲染任务</strong>，导致页面无响应或渲染停滞。</p></li></ul></li><li><p><strong>渲染线程</strong> 和 <strong>JS线程</strong> 是对主线程不同职责的描述，而非独立线程。</p></li></ul><p>关于”js线程”和”渲染线程”是互斥的更多原因，参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/openmind-ink/articles/18648441">浏览器中的JS引擎和渲染线程在主线程上互斥机制 - Felix_Openmind - 博客园</a></p><h5 id="事件循环与渲染机制"><a href="#事件循环与渲染机制" class="headerlink" title="事件循环与渲染机制"></a>事件循环与渲染机制</h5><p>既然浏览器的<code>渲染线程</code>和<code>js线程</code>并不是单独存在的线程，所以就<strong>不存在所谓的渲染线程和js线程切换</strong>，本质是主线程内任务交替执行，</p><p>浏览器通过<strong>事件循环（Event Loop）</strong> 实现任务调度：</p><ul><li><p><strong>在每次事件循环的末尾 ，都会检查距离上次渲染，是否超过了一帧的时间</strong>（如果是60hz刷新率，就是16.6ms），如果没有，则继续执行下一个宏任务；</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  banner.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translateX(<span class="subst">$&#123;e.clientX&#125;</span>px)`</span>; <span class="comment">// 同步修改</span></span><br><span class="line">&#125;);<span class="comment">//事件监听触发的回调属于宏任务</span></span><br></pre></td></tr></table></figure><ul><li><p>当鼠标快速移动，在一帧内触发多次<code>mousemove</code>事件，然后在一帧内产生多个宏任务（其内部有同步修改样式的任务）</p></li><li><p>当其中一个宏任务执行完毕，修改了样式后，由于没有微任务，到达一次事件循环的末尾，于是检查是否需要渲染</p></li><li><p>由于这次宏任务所花的时间远小于一帧的时间（如果是60hz刷新率，就是16.6ms），且开始执行的较早，此时距离上次渲染，还没有一帧的时间，<strong>即便有样式修改操作，且处于一次事件循环的末尾，也并不会进行渲染</strong>，而是开始执行下一个宏任务（都是在修改banner样式），所以其实后面的宏任务的样式修改会覆盖前面的样式修改。</p></li></ul></li><li><p>如果主线程被宏任务阻塞超过 16.7ms，则跳过当前帧的渲染：假如宏任务执行时间是1.5个帧的时间（假设没有微任务），则会跳过第一帧，在第二帧开始渲染，也就是说宏任务在 25ms 结束，但下一帧边界是 33.4ms，浏览器会<strong>等待到 33.4ms</strong> 才渲染，<strong>而非立即渲染</strong></p></li></ul><h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height:100px;background: red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 触发渲染的修改</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>).<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;200px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - start &lt; <span class="number">3000</span>) &#123; &#125; <span class="comment">// 阻塞3s的同步任务</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;长任务完成&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 监听渲染完成</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;渲染完成时元素宽度:&#x27;</span>, box.<span class="property">style</span>.<span class="property">width</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>执行同步任务： <code>document.getElementById(&#39;box&#39;).style.width = &#39;200px&#39;;</code>，同步修改样式</p></li><li><p>执行阻塞3s的同步任务</p></li><li><p>同步开启定时器，1s后将对应的回调函数纳入宏任务队列</p></li><li><p>同步调用<code>requestAnimationFrame</code>。<code>requestAnimationFrame</code>的回调 <strong>不属于宏任务，也不属于微任务</strong>，这个回调会在浏览器下次渲染前，具体就是Recalculate Style，得到渲染树前执行。</p></li><li><p>无需要执行的微任务</p></li><li><p>一次事件循环结束，检查距离上次渲染是否超过一帧的时间，发现确实如此于是开始执行渲染任务：</p><ul><li><code>requestAnimationFrame</code>传入的回调函数会在<strong>下次重绘前</strong>执行，具体时间点是进行<code>样式计算</code>前，所以输出<code>渲染完成时元素宽度: 200</code>。</li><li>进行样式计算（Recalculate Style）： 是指浏览器根据当前的 <strong>DOM 树</strong> 和 <strong>CSSOM 树</strong>，重新计算所有元素的最终样式（如颜色、边距、字体等）。计算结果会生成一个 <strong>渲染树（Render Tree）</strong>，其中包含所有可见元素及其最终样式</li><li>进行回流，重绘</li></ul></li><li><p>查找宏任务队列，开启下一个宏任务</p></li><li><p>输出<code>长任务完成</code></p></li></ul><p>可以看到上述例子中，由于同步任务持续了3s，此次事件循环也被延长了3s，所以对样式的修改被延迟到3s后才体现到页面。</p><p>为了更好的体现js执行对渲染的阻塞，可以打开开发者工具，在控制台输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>).<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - s &lt; <span class="number">3000</span>) &#123; &#125; <span class="comment">// 阻塞3s的同步任务</span></span><br></pre></td></tr></table></figure><p>并执行，发现3s后样式才发生变化</p><h3 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h3><p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？</p><p>所以，后来HTML5中支持了<code>Web Worker</code>。</p><ul><li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，<strong>而且不能操作DOM</strong>）</li><li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li></ul><p>所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!</p><p>而且注意下，<strong>JS引擎是单线程的</strong>，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><p><strong>dom树和渲染树</strong></p><p>dom树上的结点包含<code>不可视结点</code>，而渲染树上不包含；渲染树上包含<code>伪元素结点</code>，但是dom树上不包括，因为伪元素不是html结构的一部分。简单来说，区别在于<code>不可视结点</code>和<code>伪元素</code>。</p><h2 id="说说你对js引擎的理解，什么是V8引擎？"><a href="#说说你对js引擎的理解，什么是V8引擎？" class="headerlink" title="说说你对js引擎的理解，什么是V8引擎？"></a>说说你对js引擎的理解，什么是V8引擎？</h2><blockquote><p>参考文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/441313455">解 Chrome 「V8 」引擎，让你更懂JavaScript - 知乎</a></p></blockquote><h3 id="js引擎"><a href="#js引擎" class="headerlink" title="js引擎"></a>js引擎</h3><p>JavaScript 引擎可以将 <strong>JS 代码</strong>编译为不同 CPU(Intel, ARM 以及 MIPS 等)对应的<strong>汇编代码</strong>，这样我们就不需要去翻阅每个 CPU 的指令集手册来编写汇编代码了。当然，<strong>JavaScript 引擎的工作也不只是编译代码，它还要负责执行代码、分配内存以及垃圾回收</strong>。</p><p>（总结：js引擎的工作就是<strong>编译，执行代码，分配，回收内存</strong>）</p><p>热门的 JavaScript 的引擎有哪些？</p><ul><li>V8 (Google)，用 C++编写，开放源代码，由 Google 丹麦开发，是 Google Chrome 的一部分，也用于 Node.js。</li><li>JavaScriptCore (Apple)，开放源代码，用于 webkit 型浏览器，如 Safari ，2008 年实现了编译器和字节码解释器，升级为了 SquirrelFish。</li></ul><p>我们这里主要介绍V8引擎</p><h3 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h3><ul><li><p>V8 是由 Google 开发的开源<strong>JavaScript 引擎，</strong>是 JavaScript <strong>虚拟机</strong>的一种，模拟实际计算机各种功能来<strong>实现代码的编译和执行</strong>。</p></li><li><p>我们可以简单地把 JavaScript 虚拟机理解成是一个<strong>翻译程序</strong>，将人类能够理解的 <strong>编程语言 JavaScript</strong>，翻译成机器能够理解的<strong>机器语言。</strong>目前主要用在 Chrome 浏览器和 Node.js 中。</p></li></ul><h3 id="V8-引擎的内部结构"><a href="#V8-引擎的内部结构" class="headerlink" title="V8 引擎的内部结构"></a><strong>V8 引擎的内部结构</strong></h3><h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h4><p>负责将 JavaScript 源码，转换为 Abstract Syntax Tree (AST)，即<strong>抽象语法树</strong></p><h4 id="Ignition"><a href="#Ignition" class="headerlink" title="Ignition"></a>Ignition</h4><p>即<strong>解释器</strong>，负责将 AST 转换为 Bytecode（字节码），<strong>解释执行 Bytecode</strong>；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型</p><h4 id="TurboFan"><a href="#TurboFan" class="headerlink" title="TurboFan"></a>TurboFan</h4><p>compiler，即<strong>编译器</strong>，利用 Ignition 所收集的类型信息，将 Bytecode 转换为优化的<strong>汇编代码</strong>；</p><h3 id="V8-是怎么执行一段-JavaScript-代码的？"><a href="#V8-是怎么执行一段-JavaScript-代码的？" class="headerlink" title="V8 是怎么执行一段 JavaScript 代码的？"></a>V8 是怎么执行一段 JavaScript 代码的？</h3><h4 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h4><img src="..\images\前端面试-js\v8.png" style="zoom:67%"><p>简单地说，**Parser 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，并解释执行，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)**。</p><ul><li>如果函数没有被调用，则 V8 不会去编译它（不会编译成字节码）。</li><li>如果函数只被调用 一 次，则 Ignition 将其编译为Bytecode 后，就直接<strong>解释执行</strong>了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。<strong>这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。</strong></li><li>如果函数被调用多次，则它有可能会被识别为<strong>热点函数</strong>，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（已优化的机器码），以提高代码的执行性能。</li><li>TurboFan 使用多种高级优化技术，如内联、死代码消除、寄存器分配等，来提高执行效率。</li><li>图片中的红色虚线是逆向的，这个过程叫做<strong>Deoptimization（去优化）</strong>。因为Ignition 收集的信息可能是错误的，比如 add 函数的参数之前是整数，后来又变成了字符串，<strong>V8 可以“撤销”优化版本的代码，回退到原始的字节码执行状态</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//生成的 Optimized Machine Code 已经假定 add 函数的参数是整数，那当然是错误的，于是需要进行 Deoptimization。</span></span><br><span class="line"><span class="title function_">add</span>(<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;5&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>从上述分析中可以看出，在v8中执行js代码时，即包含解释执行，又包含编译执行</strong></p><h4 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h4><p>需要先将输入的<code>源代码</code>通过<strong>解析器</strong>编译成<strong>中间代码</strong>，之后直接<strong>使用解释器解释执行中间代码</strong>，然后直接输出结果。</p><p>在v8引擎中具体流程如下图所示：</p><img src="..\images\前端面试-js\解释执行.png" style="zoom:60%"><ul><li><p>其中的解析器就是<strong>Parse</strong>，中间代码指的是<strong>字节码</strong>，解释器就是<strong>Ignition</strong>。其实这种说法不够准确，因为Parse生成的是AST（抽象语法树），中间代码是解释器根据抽象语法树生成的。</p></li><li><p>在 V8 中，字节码，是介于源代码和机器码之间的一种<strong>中间表示形式</strong>，它是 Ignition 解释器的操作指令集，专门设计用于高效地<strong>解释执行</strong>。每个字节码指令对应一个简单的操作，如加载变量、调用函数等。</p></li></ul><h4 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h4><p>在v8引擎中具体流程如下图所示：</p><img src="..\images\前端面试-js\编译执行.png" style="zoom:67%"><p>将中间代码，即字节码，交给编译器即TurboFan处理，生成优化后的机器代码。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>解释执行和编译执行都有各自的优缺点。<strong>解释执行启动速度快，但是执行时速度慢，而编译执行启动速度慢，但是执行速度快</strong>。</p></li><li><p>为了充分地利用解释执行和编译执行的优点，规避其缺点，V8 采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用<strong>优化编译器TurboFan</strong>将其编译成执行效率更加高效的机器代码。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是<strong>解释执行</strong>的方式，因为每次执行时都需要<strong>实时解析和执行代码</strong>，导致效率低于预编译的代码。而 V8 率先引入了<strong>即时编译（JIT）</strong>的双轮驱动的设计，这是一种权衡策略，混合<strong>编译执行和解释执行</strong>这两种手段，给 JavaScript 的执行速度带来了极大的提升。</p><p>如何理解<strong>即时编译，混合编译（编译执行和解释执行）</strong>，这三个概念？</p><ul><li>v8引擎启动的时候使用的是解释执行的：ignition解释器，解释执行字节码</li><li>如果某段代码被执行多次，成为<strong>热点代码</strong>的时候，V8 会通过 <code>TurboFan</code> 编译器将其<strong>编译为高效的本地机器码</strong>；</li><li>v8引擎在程序运行时，动态地将字节码（或中间表示）编译为机器码的过程，就是<strong>即时编译</strong></li></ul><h3 id="对比其他编程语言"><a href="#对比其他编程语言" class="headerlink" title="对比其他编程语言"></a>对比其他编程语言</h3><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><blockquote><p>C语言的编译过程：源代码 → (编译)→汇编代码→ (汇编)→机器码：目标文件→ (链接)→完整的可执行程序（01代码）</p></blockquote><p>C 语言编写的代码，需要将其<strong>编译</strong>为二进制代码的文件，然后再直接执行二进制代码。生成的二进制文件，是针对特定操作系统和硬件架构的。例如，在 Windows 上编译的程序不能直接在 Linux 上运行，<strong>所以使用编译执行的语言，编写的程序，可移植性较差</strong>。</p><p><strong>为什么C语言编译器，编译的程序不能在不同的操作系统上运行，js中也有编译器，比如TurboFan编译器，就没有这个问题？</strong></p><p>因为C 编译器是<strong>静态编译</strong>的，在写完代码后，通过 gcc 或 clang 把 .c 文件一次性编译成可执行文件（.exe, .out, .elf 等）。</p><table><thead><tr><th>原因</th><th>说明</th></tr></thead><tbody><tr><td><strong>编译时不知道目标平台</strong></td><td>开发者必须提前指定目标架构和操作系统（比如用 <code>-m32</code>、<code>-target arm-linux-gnueabi</code>），<strong>否则默认就是本机平台。</strong></td></tr><tr><td><strong>输出的是原生机器码</strong></td><td>C 编译器输出的是 CPU 直接能执行的机器码，绑定死了 CPU 架构和操作系统。</td></tr><tr><td><strong>无法在运行时改变策略</strong></td><td>可执行文件一旦生成，就不能再适配不同平台了。</td></tr></tbody></table><p><strong>那为什么不把c语言编译器分发到目标平台呢，就像谷歌v8引擎做的那样（谷歌v8引擎中包含了TurboFan编译器）</strong></p><p>原因有如下几点：</p><table><thead><tr><th><strong>编译器太大</strong></th><th><code>gcc</code>&#x2F;<code>clang</code> 编译器本身就有几十 MB 到几百 MB，不是一个轻量级组件。</th></tr></thead><tbody><tr><td><strong>依赖太多</strong></td><td>它们依赖操作系统提供的头文件、标准库、链接器、调试工具等。</td></tr><tr><td><strong>安装配置复杂</strong></td><td>在不同系统上安装 C 编译器需要管理员权限、包管理器支持等。</td></tr><tr><td><strong>性能开销大</strong></td><td><strong>即使你成功运行了编译器，编译过程也会带来显著延迟。</strong></td></tr></tbody></table><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">java</span> 源代码</span><br><span class="line">     │ javac 编译</span><br><span class="line">     ▼</span><br><span class="line">.<span class="property">class</span> 字节码（平台无关）</span><br><span class="line">     │ <span class="variable constant_">JVM</span> 执行</span><br><span class="line">     ▼</span><br><span class="line">程序运行</span><br></pre></td></tr></table></figure><ul><li><code>javac</code> 是<strong>开发阶段</strong>使用的工具，用于将 <code>.java</code> 文件编译成 <code>.class</code> <strong>字节码</strong></li><li><code>.class</code> 文件是二进制格式的字节码，不是机器码，也不是源代码，这些字节码<strong>是平台无关的</strong>，这样它们就可以在任何安装了 Java 虚拟机（JVM） 的设备上运行。<strong>JVM 只需要 <code>.class</code> 文件就可以运行程序</strong>，它不需要原始的 <code>.java</code> 文件和 <code>javac</code></li><li>Java 程序可以在任何安装了相应版本 JVM 的平台上运行，<strong>其中Java 程序是指已经编译好的<code>.class</code>文件</strong>，而不是<code>.java</code>源文件。因此，其他平台只需安装 JVM（或 JRE），而无需安装 <code>javac</code> 编译器。</li><li><code>.class</code> 文件在JVM中也是<strong>解释执行和即时编译执行</strong>的</li></ul><p>在 Google V8 引擎中，也有类似的“源代码 → 字节码”转换过程（由 Ignition 解释器完成），但这个过程发生在运行时，并且是在目标平台上已经安装好 V8 引擎的前提下进行的。因此，JavaScript 的字节码不需要像 Java 那样强调“平台无关性”，因为 V8 本身就已经适配了当前平台，并负责后续的执行与优化（如通过 TurboFan 编译为本地机器码）。</p><h2 id="在script标签中添加async和defer有什么作用和区别"><a href="#在script标签中添加async和defer有什么作用和区别" class="headerlink" title="在script标签中添加async和defer有什么作用和区别"></a>在script标签中添加async和defer有什么作用和区别</h2><p>默认情况下，当<code>HTML解析器</code>遇到一个<code>&lt;script&gt;</code>标签（无论是内联脚本还是外部脚本），它会暂停HTML文档的解析，转而去<code>加载</code>和<code>执行</code>这个脚本，也就是说默认情况下，scrpt标签的<strong>加载和执行</strong>都会阻塞html的解析，也就是dom树的构建。</p><p>为什么要等到js执行完毕后，才继续构建dom呢？</p><ul><li>我们知道dom树的构建和js执行，都在主线程上运行，主线程是单线程的，所以这2个工作不能同时执行，执行js的时候，就不能继续构建dom的工作。</li><li>除此之外，如果js执行和dom树的构建是并行的，可能js执行捕获，修改dom元素的操作的时候，可能出现对应的dom元素并没有被创建的情况。</li></ul><p>好的，既然js代码执行和dom树的构建不能同时执行，那为什么默认选择先执行js代码呢？</p><ul><li><p>其实怎么选择执行顺序不重要，反正都是串行执行，顺序反过来也不会快点，只不过默认情况下，选择执行先执行js，这样的目的是防止下面的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;div&gt;新内容&lt;/div&gt;&#x27;</span>); <span class="comment">// 必须暂停DOM解析，否则后续HTML会被覆盖。</span></span><br></pre></td></tr></table></figure></li><li><p>如果想要先构建DOM树，在script标签上添加defer属性即可。</p></li></ul><p>我们再思考一下，js执行阻塞dom构建，是不是就是我们常说的”阻塞渲染”呢？严格来说，并不是，DOM树的构建是<strong>解析HTML的直接结果</strong>，属于浏览器处理HTML的<strong>输入阶段</strong>，它仅负责将HTML文本转换为结构化的对象模型，但此时还不涉及样式或可视化信息，渲染任务需要DOM和CSSOM都完成后才能开始。</p><p><strong>案例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，浏览器首先会尝试加载并执行 <code>script1.js</code>。只有当 <code>script1.js</code> 被成功加载并执行完毕后，才会开始加载 <code>script2.js</code>。同样地，直到 <code>script2.js</code> 也被加载和执行完毕，浏览器才会继续解析剩下的 HTML 并渲染 <code>&lt;p&gt;</code> 标签中的文本“Hello, world!”。</p><p>然而对于添加了async，defer属性的script标签，它们加载脚本是<strong>异步</strong>的且是<strong>并行</strong>的，也就是说此时加载js文件，不会阻塞html文档的解析，也就是不会阻塞dom树的构建；</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async 属性用于告诉浏览器脚本是异步，并行下载的，即这个加载过程不会阻塞html的解析。</p><p>脚本下载完成后<code>立即执行</code>，不保证脚本的执行顺序，如果html标签未解析完毕，可能阻塞html解析</p><p>适用于独立的脚本，如第三方分析脚本，这些脚本不需要等待其他脚本执行完毕。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer 属性用于告诉浏览器脚本应该<code>延迟</code>到整个html解析完成后再执行，也是异步下载，不阻塞html解析，所有脚本在html解析完成，即DOM树构建完毕后，但<code>DOMContentLoaded</code>事件触发前（没错就是在这个事件前），按引入顺序执行。适用于依赖于 DOM 的脚本，如需要操作 DOM 的脚本，这些脚本需要确保 DOM 已经完全加载。举例：vue2项目打包后，也是通过defer的方式加载js文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>heima-shopping<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/chunk-vendors.f3f3a489.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/app.04cc1747.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不使用defer属性会出现什么问题？</p><p>如果不使用defer属性，浏览器首先会尝试加载并执行第一个脚本。只有当 第一个脚本被成功加载并执行完毕后，才会开始加载第二个脚本。同样地，直到第二个脚本也被加载和执行完毕，浏览器才会继续解析剩下的 HTML 并渲染 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code></p><p>Vue的挂载逻辑需要等待dom解析完，否则捕获不到根元素（<code>document.getElementById(&#39;app&#39;)</code>返回null）导致错误。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li>图片等资源的加载和解析不会阻塞主线程</li><li>css文件的加载是异步的，不会阻塞主线程</li><li>css 文件的解析（构建 CSSOM）和 HTML 的解析（构建 DOM）二者在主线程上互斥执行。</li><li>由于得到渲染树后才能进行渲染，而得到渲染树需要先构建好dom树和cssom树，所以页面会等待首屏关键css加载并解析完，才会开始渲染。</li></ul><h2 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h2><h3 id="为什么js是一门单线程语言"><a href="#为什么js是一门单线程语言" class="headerlink" title="为什么js是一门单线程语言"></a>为什么js是一门单线程语言</h3><ul><li><strong>设计为多线程存在问题</strong>：如果被设计为多线程，当2个线程对同一个dom进行不同的操作，浏览器不知道该以谁为主。</li><li><strong>为了解决多线程存在的问题，会让代码变得复杂</strong>：js语言设计的初衷就是“轻量级”，如果被设计为多线程，就必须引入<code>线程的同步与互斥机制</code>，这就意味着会增大代码的复杂度，违背了js设计的初衷。</li><li><strong>硬件条件</strong>：js诞生的时候（1995年），多核cpu尚未普及，单线程更符合当时的硬件条件。</li></ul><p><strong>拓展</strong></p><p>我们已经知道js是单线程的，那我们再思考一下，js是一门<code>解释型语言（比如python）</code>还是<code>编译型语言（比如java，c/c++）</code>?</p><p>解释执行：</p><ul><li>在早期，JavaScript 主要通过解释方式执行。浏览器加载网页上的 JavaScript 代码后，JavaScript 引擎会读取并解释这些代码，然后一行一行地执行。</li></ul><p>即时编译（JIT）：</p><ul><li><p>现代JavaScript引擎（如V8、SpiderMonkey）采用<strong>即时编译技术</strong>，将JavaScript代码编译为机器码后再执行，以提升性能。</p></li><li><p>流程：</p><ul><li><p><strong>解析</strong>：将源代码解析为抽象语法树（AST）。</p></li><li><p><strong>编译</strong>：将AST编译为<strong>字节码</strong>（如V8的Ignition解释器处理字节码）。</p></li><li><p><strong>优化</strong>：对频繁执行的代码（如循环）进行<strong>即时编译</strong>，生成更高效的机器码（如V8的TurboFan编译器）。</p></li></ul></li></ul><p>结论：JavaScript<strong>既非纯解释型，也非纯编译型</strong>，而是<strong>两者的结合</strong>。</p><h3 id="同步与异步任务"><a href="#同步与异步任务" class="headerlink" title="同步与异步任务"></a>同步与异步任务</h3><p>首先，<code>JavaScript</code>是一门<strong>单线程的语言</strong>，意味着同一时间内只能做一件事，这样就存在<strong>线程阻塞</strong>的问题，</p><p>而解决阻塞的方法就是将任务划分为<code>同步任务</code>和<code>异步任务</code></p><ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到<code>主线程</code>中执行</li><li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等，交给<code>宿主环境</code>去执行，时机成熟后放入<code>任务队列</code>中</li></ul><h3 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h3><p><code>异步任务</code>又可以<strong>细分</strong>为<code>微任务</code>和<code>宏任务</code>，任务队列也被划分为微任务队列和宏任务队列。</p><p>什么是微任务，什么是宏任务？</p><p><strong>宏任务</strong>是指<code>时间粒度</code>比较大的任务（就是js操作比较多，需要更多的时间来执行，无法迅速完成的任务），<strong>微任务</strong>则反之。常见的宏任务有<code>setTimeout()</code>，常见的微任务有<code>Promise.then()</code></p><p>在执行下一个宏任务之前，会先查看<code>微任务队列中</code>是否有需要执行的<code>微任务</code>，如果有则先把微任务执行完，再开启新的宏任务。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><code>宏任务</code>是事件循环的基本单位，一个宏任务中可以同时包含<code>同步任务</code>，<code>宏任务</code>，<code>微任务</code>；</p><p><code>事件循环</code>指的是，js引擎先执行<code>宏任务</code>中包含的<code>同步任务</code>，再查找并执行微任务队列中的所有微任务，再查找宏任务队列，开启新的宏任务，如此循环往复的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);<span class="comment">//虽然是立即触发回调，但是并不是立即输出setTimeout，而是加入宏任务队列</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);<span class="comment">//虽然第一个then方法中的回调函数是立即触发，但是不是立即执行，而是加入微任务队列</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);<span class="comment">//因为then方法会立即返回一个promise对象，所以第二个then方法中的回调函数也会加入微任务队列</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li><p>宏任务：执行整体代码（相当于<code>&lt;script&gt;</code>中的代码，整体是一个宏任务）：</p><ol><li>输出: <code>script start</code></li><li>遇到 setTimeout，立即开启延时器，时机成熟后，将传入的回调函数加入宏任务队列</li><li>遇到第一个then，同步调用它，将<code>console.log(&quot;promise1&quot;)</code>加入微任务队列</li><li>遇到第二个then，因为then方法会立即返回一个promise对象，所以第二个then方法也会同步调用，对应的回调函数，也会加入微任务队列。</li><li>输出：<code>script end</code></li></ol></li><li><p>微任务：清空微任务队列</p><ol><li>输出：<code>promise1</code>(该微任务调用时机是”立即调用”)</li><li>输出：<code>promise2</code>（该微任务调用时机是等到第一个回调函数，也就是第一个微任务，调用后，也就是产生返回值后，也就是第一个then方法返回的promise实例状态确定后，再调用）</li><li>微任务队列清空</li></ol></li><li><p><strong>执行渲染操作，更新界面（敲黑板划重点）。</strong></p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.container&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;你好啊&#x27;</span></span><br></pre></td></tr></table></figure><p>当执行上述代码，修改了DOM元素的<code>innerHTML</code>后，DOM本身确实是被修改了，但是浏览器不会立刻进行重绘，将对DOM的修改更新到视图。相反，它会将这些更改记录下来，放入渲染队列，在下一个事件循环开始之前，检查是否有渲染任务，有则执行相应的渲染操作。</p></li><li><p>执行下一个宏任务：运行<code>console.log(&quot;setTimeout&quot;)</code></p></li></ol><p>参考文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/a/1190000044769124">程序员 - 一次搞懂-JS事件循环之宏任务和微任务 - 个人文章 - SegmentFault 思否</a></p><h3 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h3><p><code>async</code> 是异步的意思，<code>await</code> 则可以理解为等待</p><p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code> 是用来等待异步方法执行</p><p><strong>async</strong></p><p>无论如何，<code>async</code>函数返回的总是一个<code>promise</code>对象，下面两种方法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会自动包装成resolved类型的promise对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncF</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的来说async函数的返回值会被<code>Promise.resolve</code>包装。</p><p><strong>await</strong></p><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code> 对象，返回该对象的结果。如果不是 <code>Promise</code> 对象，就<code>直接返回</code>对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 等同于return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// 立即输出123</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//return语句不会被阻塞，直接返回，不等待promise状态改变</span></span><br><span class="line">    <span class="comment">//立即返回创建的promise对象</span></span><br><span class="line">    <span class="comment">//不过真有真么写的吗？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="number">123</span>) &#125;, <span class="number">3000</span>) &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">f</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)<span class="comment">//输出状态为pending的promise对象</span></span><br><span class="line">res.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// 3s后输出123</span></span><br></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码，后面的代码成为异步任务，如果阻塞的是是同步代码就成为<code>微任务</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>() <span class="comment">// fn2函数的执行不会被阻塞</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 被阻塞，成为微任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p><h3 id="综合例题"><a href="#综合例题" class="headerlink" title="综合例题"></a>综合例题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">s2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">s1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>最终输出 <code>7 9 3 6 5 8 4 1</code></p><ul><li>先同步开启定时器（执行setTimeout），并立即将<code>console.log(1)</code>这个任务放入宏任务队列</li><li>调用async函数，会立即执行其中的同步代码（我还以为调用async函数，会被视为一个宏任务呢，就像定时器回调函数一样），所以调用s1立即输出7，然后调用s2，同样的立即输出9</li><li><code>console.log(8)</code>会等待s2函数返回值的状态改变后再执行，属于<code>微任务</code>，放入微任务队列</li><li>然后创建promise实例，传入其中的回调函数会被立即执行，所以立即输出3和6</li><li><code>console.log(4)</code>需要等待promise实例的状态改变，属于微任务，放入微任务队列</li><li>同步执行<code>console.log(5)</code>输出5</li><li>清空微任务队列，依次输出8和4</li><li>然后再执行下一个宏任务，输出1</li></ul><h2 id="说说js资源加载事件"><a href="#说说js资源加载事件" class="headerlink" title="说说js资源加载事件"></a>说说js资源加载事件</h2><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a><strong>DOMContentLoaded</strong></h3><p><code>DOMContentLoaded</code>事件是在HTML文档被完全加载和解析之后触发的，也就是说，当浏览器已经解析完整个HTML文档，<strong>DOM树构建完毕</strong>，这时候才会触发这个事件。不过，可能需要注意的是，虽然DOM树已经构建完成，但像图片和样式表，这些外部资源可能还没有加载完毕。这时候页面已经可以交互了，因为DOM已经就绪。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTML 文档已加载并解析完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="load"><a href="#load" class="headerlink" title="load"></a><strong>load</strong></h3><p>则是在所有资源（包括图片、样式表等）都<strong>加载完毕</strong>后才触发（只等待资源加载，不等待<code>资源解析</code>），要注意的是，<code>load</code> 事件并<strong>不等待所有的异步请求完成</strong>，比如通过 JavaScript 发起的 AJAX 请求或 Fetch API 请求，甚至不等待动态加载的内容（如通过 JavaScript 动态插入的图片或其他资源），为什么要等待呢？，load事件怎么知道你什么时候插入图片或者其他资源，如果你始终不这么操作，load难不成还一直等待你？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面及所有资源已完全加载&#x27;</span>);</span><br><span class="line">    <span class="comment">//此时可以确认所有资源，包括图片，样式表等，都已经加载完毕</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要值得注意的是，首屏渲染，只需要等待html标签解析完毕，构建好dom树，等待ss文件加载并解析完，生成cssom树之后，就可以进行，换句话说，首屏渲染不等待图片资源。</p><h3 id="unload和beforeunload"><a href="#unload和beforeunload" class="headerlink" title="unload和beforeunload"></a>unload和beforeunload</h3><p>当用户导航至其他页面(新页面在<strong>本窗口</strong>打开)、关闭当前标签页或窗口、或者<strong>刷新页面</strong>时，都会触发 <code>unload</code> 事件，但是我们常用的其实是<code>beforeunload</code>，即在页面卸载前做些什么，因为<code>unload</code>事件触发的时候页面已经被卸载了，我们做任何操作都没用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">   <span class="comment">//阻止事件默认行为，一定要添加，光注册beforeunload事件监听没用</span></span><br><span class="line">   <span class="comment">//这样就能阻止unload事件触发，页面就不会被卸载</span></span><br><span class="line">   e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当用户刷新页面的时候，浏览器会提示是否刷新站点；当用户跳转到其他页面的时候，提示是否进行页面跳转。</p><h2 id="说说js的数据类型"><a href="#说说js的数据类型" class="headerlink" title="说说js的数据类型"></a>说说js的数据类型</h2><p>js的数据类型可以分为两类，<strong>基本数据类型</strong>和<strong>引用数据类型</strong></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型主要有6种：<code>Number，String，Boolean，Symbol，Null，Undefined</code>，后来又添加了一种叫做<code>BigInt</code>，<strong>所以说基本数据类型就有7种。</strong></p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>最常见的<code>整数</code>类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span> <span class="comment">// 10进制的55</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">070</span> <span class="comment">// 8进制的56</span></span><br><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span> <span class="comment">//16进制的10</span></span><br><span class="line"><span class="comment">// 十六进制的 1A 转换为十进制是26</span></span><br><span class="line"><span class="comment">// A代表10，再乘以权重16^0，等于10，1乘以权重16^1等于16，相加得到26</span></span><br><span class="line"><span class="keyword">let</span> hexNumber = <span class="number">0x1A</span>; </span><br></pre></td></tr></table></figure><p><code>浮点类型</code>则在数值中必须包含<code>小数点</code>，还可通过<strong>科学计数法</strong>表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000</span></span><br></pre></td></tr></table></figure><p><strong>格式化</strong></p><p>关于浮点数有一个重要的知识点就是格式化</p><ul><li><p>使用 <code>toFixed()</code> 方法</p><p>表示保留几位小数，要注意的是不是<code>format</code>方法，在js中不是使用这种方法格式化浮点数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123.456</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 输出 &quot;123.46&quot; - 四舍五入到两位小数</span></span><br></pre></td></tr></table></figure><p><code>toFixed()</code> 返回的是一个<strong>字符串</strong>，而不是数字。如果需要进行进一步的数值计算，你可能需要将其转换回<code>数字类型</code>。</p></li><li><p>使用 <code>toPrecision()</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123.456</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toPrecision</span>(<span class="number">3</span>)); <span class="comment">// 输出 &quot;123&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toPrecision</span>(<span class="number">5</span>)); <span class="comment">// 输出 &quot;123.46&quot;</span></span><br></pre></td></tr></table></figure><p><strong>这个方法表示保留几位有效数字</strong>，并且会根据需要，自动调整数字的表示形式（科学记数法或固定点表示法）</p></li><li><p><code>Number.prototype.toLocaleString()</code></p><p><code>toLocaleString()</code> 可以用于获取特定地区的数字格式，包括货币、百分比和日期格式等。对于浮点数格式化，它可以用来设置小数位数和使用逗号作为千位分隔符等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1123.456</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toLocaleString</span>())<span class="comment">//输出1,123.456</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>NaN</strong></p><p>在数值类型中，存在一个特殊数值<code>NaN</code>，意为“不是数值”，用于表示数值运算操作失败了，<strong>而不是抛出错误</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/+<span class="number">0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><strong>存储空间</strong></p><p>在 JavaScript 中，变量的声明方式（<code>var</code>、<code>let</code> 或 <code>const</code>）<strong>不会影响其占用的内存大小</strong>。内存占用主要取决于变量存储的数据类型，而不是声明关键字本身。</p><ul><li><p><code>Number</code></p><p>8 字节（64 位），因为所有数字都以双精度浮点数形式存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num = 123; // 占用 8 字节</span><br><span class="line">const pi = 3.14; // 占用 8 字节</span><br></pre></td></tr></table></figure></li><li><p><code>BigInt</code>：内存占用随整数大小动态变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bigIntValue = 1234567890123456789012345678901234567890n; // 内存占用随值增大而增加</span><br></pre></td></tr></table></figure></li><li><p><code>String</code>：内存占用与字符串长度成正比，每个字符通常占用2 字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const str = &quot;Hello&quot;; // 长度为 5 的字符串，占用约 10 字节</span><br></pre></td></tr></table></figure></li><li><p><code>Boolean</code>通常占用4 字节或更少（具体实现因引擎而异）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag = true; // 占用少量固定内存</span><br></pre></td></tr></table></figure></li><li><p><code>undefined</code> 和 <code>null</code>：通常占用4 字节或更少。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x; // undefined，占用少量固定内存</span><br><span class="line">const y = null; // 占用少量固定内存</span><br></pre></td></tr></table></figure></li></ul><p>存储一个ip地址，如何实现存储空间最小？在c语言中，一个字符char，占用一个字节，用字符串存储一个ip地址，最多占用<code>3*4</code>+3（3个分隔符）&#x3D;15个字节，但是因为ip地址每位的范围是<code>0-255</code>，用一个字节就能存储，所以最多大概只需要占用4字节，而如果使用int类型的存储，则需要<code>4*4</code>&#x3D;16字节，反而比使用字符串存储占用更多的空间。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串使用双引号（”）、单引号（’）或反引号（&#96;）表示都可以，反引号表示的是模板字符串，模板字符串和普通字符串有什么区别呢？</p><p>在模板字符串中可以嵌入变量，这是模板字符串最常见的用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>)<span class="comment">//输出&#x27;my name is tom&#x27;</span></span><br></pre></td></tr></table></figure><p>在 模板字符串中，会保留字符串中的所有空白字符，包括空格、制表符（<code>\t</code>）和换行符（<code>\n</code>）。</p><p>这种特性，使得模板字符串非常适合用于生成多行文本或格式化的字符串内容。这与普通字符串（使用单引号 <code>&#39;</code> 或双引号 <code>&quot;</code>）不同，普通字符串不会自动保留换行和缩进，必须手动添加换行符（<code>\n</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello\nWorld&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1);</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">`</span></span><br><span class="line"><span class="string">  Hello</span></span><br><span class="line"><span class="string">    World</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2);</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">//   Hello</span></span><br><span class="line"><span class="comment">//     World</span></span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">&#x27;Hello</span></span><br><span class="line"><span class="string">  World&#x27;</span>; <span class="comment">//报错，不能在普通字符串中直接使用换行，必须使用换行符</span></span><br></pre></td></tr></table></figure><p>在js中，字符串是<code>不可变</code>的，意思是一旦创建，它们的值就<strong>不能变了</strong>。因为虽然字符串是基本数据类型，但实际存储在堆中，栈中保存的是引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;<span class="comment">//这行代码会在内存中创建一个包含 &quot;Java&quot; 的字符串对象，并将引用赋值给变量 lang。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从内存中读取 lang 当前所指向的字符串 &quot;Java&quot;。</span></span><br><span class="line"><span class="comment">//将 &quot;Java&quot; 和 &quot;Script&quot; 拼接成新的字符串 &quot;JavaScript&quot;，并在内存中创建一个新的字符串对象。</span></span><br><span class="line"><span class="comment">//将 lang 变量存储的引用，更新为新创建的字符串 &quot;JavaScript&quot;的引用</span></span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lang)</span><br></pre></td></tr></table></figure><p><strong>字符串比较</strong></p><table><thead><tr><th><strong>场景</strong></th><th><strong><code>==</code> 结果</strong></th><th><strong><code>===</code> 结果</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>2个原始字符串：let a &#x3D; ‘123’, b&#x3D;’123’</td><td><code>true</code></td><td><code>true</code></td><td>a，b都是基本数据类型中的字符串，又因为引擎会将相同的字符串字面量（如 <code>&#39;123&#39;</code>）存储为同一个堆内存地址，而非创建多个实例。这样可以节省内存并提高性能。因此，<code>a</code> 和 <code>b</code> 实际上指向了<strong>同一个堆内存地址</strong>，所以a，b的值也是相同的，因此 <code>a === b</code> 返回 <code>true</code></td></tr><tr><td>原始字符串 vs String 对象：let a &#x3D; ‘123’, b&#x3D;new String(‘123’)</td><td><code>true</code></td><td><code>false</code></td><td><code>===</code>比较的结果为false，因为a,b不是同一数据类型；<code>==</code>比较的结果是true，是因为<code>b.valueof</code>的值就是字面量字符串<code>123</code>的引用。</td></tr><tr><td>两个 String 对象：let a &#x3D; new String(‘123’), b&#x3D;new String(‘123’)</td><td><code>false</code></td><td><code>false</code></td><td>a,b的数据类型虽然相同，但是由于a，b是2个不同的对象，所以a，b存储的引用并不相同，严格比较和非严格比较的值都是false</td></tr></tbody></table><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>Boolean（布尔值）类型有两个字面值： <code>true</code>和<code>false</code></p><p>通过<code>Boolean</code>可以将其他类型的数据转化成布尔值</p><table><thead><tr><th>数据类型</th><th>转换为 true 的值</th><th>转换为 false 的值</th></tr></thead><tbody><tr><td>String</td><td>非空字符串</td><td>“”</td></tr><tr><td>Number</td><td>非零数值（包括负数）</td><td>0 、 NaN</td></tr><tr><td>Object</td><td>任意对象</td><td>null</td></tr><tr><td>Undefined</td><td>N&#x2F;A （不存在）</td><td>undefined</td></tr></tbody></table><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p><code>Symbol</code>关键字的主要用途，是用来创造一个<code>唯一</code>的标识符，用作对象属性，确保不会产生<code>属性冲突</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>传入符号主要为了标识，符号相同并不代表值也相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>可枚举性</strong></p><p>Symbol类型的键默认是可枚举的，通过<code>对象字面量</code>或<code>常规赋值</code>添加的属性，默认都是可枚举的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123; [sym]: <span class="string">&#x27;value&#x27;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, sym).<span class="property">enumerable</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>通过<code>Object.defineProperty</code>定义的属性，其可枚举性才默认为false，无论是字符串键还是 Symbol 键，均可通过 <code>Object.defineProperty()</code> 显式设置 <code>enumerable: true/false</code>，顾名思义，这个方法就是用来定义，修改属性的，而且每次只能修改一个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数指明要修改哪个对象，第二个参数指明要修改这个对象的哪个属性，第三个参数指明如何修改这个属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;hidden&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;秘密&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span> <span class="comment">//是否可以被修改</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span> <span class="comment">//是否可以被删除</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>在某些方法中不被考虑</strong></p><p>Symbol 类型的键，并且不会出现在<code>for...in</code> 循环中，也不会被<code>Object.keys()</code>方法返回，因为这两种方法只考虑<strong>字符串类型的键</strong>，并不是因为使用Symbol 类型做为键的属性就是不可枚举的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">normalKey</span>: <span class="string">&#x27;value for normal key&#x27;</span>,</span><br><span class="line">  [sym]: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 遍历对象属性，Symbol 键不会出现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 输出: normalKey</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));<span class="comment">//输出[&#x27;normalKey&#x27;]</span></span><br></pre></td></tr></table></figure><p>Symbol 类型的<strong>键和值</strong>，都不会包含在<code>序列化</code>的结果中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">normalKey</span>: sym</span><br><span class="line">  [sym]: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))<span class="comment">//&#123;&quot;name&quot;:&quot;tom&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Object.assign</strong></p><p><code>Object.assign</code>会把<code>Symbol</code> 类型的键也拷贝进，因为Symbol类型的键默认也是可枚举的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">normalKey</span>: <span class="string">&#x27;value for normal key&#x27;</span>,</span><br><span class="line">  [sym]: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)<span class="comment">//&#123;normalKey: &#x27;value for normal key&#x27;, Symbol(description): &#x27;123&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>Null类型同样只有一个值，即特殊值 <code>null</code></p><p>逻辑上讲， null 值表示一个空对象，这也是给<code>typeof</code>传一个 <code>null</code> 会返回 <code>&quot;object&quot;</code> 的原因。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span>  <span class="title class_">Object</span>;<span class="comment">// 输出false，因为null是一个特殊的基本数据类型，不代表任何对象。</span></span><br></pre></td></tr></table></figure><h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p><code>Undefined</code> 类型只有一个值，就是特殊值 <code>undefined</code>，如果一个变量声明了但是未被赋值，那么这个变量的值就是undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 没有声明过这个变量，报错</span></span><br></pre></td></tr></table></figure><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>引用数据类型有多种，引用数据类型统称为<code>Object</code>，所以一般不会问有几种 ，一般只问基本类型有几种。</p><p>引用数据类型主要包括以下三种：</p><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>js数组是一组<code>有序</code>的数据，但跟其他语言不同的是，数组中每个槽位可以存储<code>任意类型</code>的数据。并且，数组也是<code>动态大小</code>的，会随着数据添加而自动增长。</p><p>通常通过<code>字面量表示法</code>创建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="number">2</span>, &#123;<span class="attr">age</span>: <span class="number">20</span> &#125;]</span><br><span class="line">colors.<span class="title function_">push</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>或者通过<code>Array</code>来创建数组，给数组分配大小固定，连续的空间，<strong>内部默认没有元素</strong>；可以调用数组的<code>fill</code>方法填充数组，比如<code>arr.fill(0)</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>)</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i) &#125;)<span class="comment">//不会输出任何内容，因为数组中一个元素都没有</span></span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i) &#125;)<span class="comment">//输出四个0</span></span><br></pre></td></tr></table></figure><p>虽然说数组大小是<code>固定的</code>，但是还是可以往数组中加入元素，改变数组的大小，不过新加入的元素放在<code>已分配空间之后</code>。</p><p><strong>创建二维数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>)<span class="comment">//创建一个长度为4的数组，虽然创建的时候指定了长度，但是长度还是可以变化的</span></span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">// 初始化/填充 数组</span></span><br><span class="line">arr.<span class="title function_">map</span>(<span class="function"><span class="params">i</span>=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>).<span class="title function_">fill</span>(<span class="number">0</span>))<span class="comment">//每次迭代都会创建一个新的数组并返回，确保二维数组中的每个数组存储空间互不干扰</span></span><br></pre></td></tr></table></figure><p>上述代码可简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const arr = new Array(4).fill(0).map( ele =&gt; new Array(4).fill(0))</span><br></pre></td></tr></table></figure><p>可以看出在js中创建二维数组还是挺麻烦的。</p><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>函数实际上是<code>对象</code>，每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code>也有属性和方法，跟其他引用类型一样，其中最常见的属性比如<code>prototype</code>。</p><h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><p>除了上述说的2种之外，还包括<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code>等，他们都是<code>Object</code>类型的<code>子类</code>。</p><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><img src="..\images\前端面试-js\数据区别.png" style="zoom:67%"><ul><li><p>基本类型变量的值，直接存储在<strong>栈内存</strong>中，引用类型变量的值，存储在<strong>堆内存</strong>中，但是栈内存中存储了它们的引用。</p></li><li><p>在上图中，貌似取b的值拿到的是地址，其实拿到的还是对象数据，因为直接使用的时候（非赋值情况）会默认根据地址取值。</p></li><li><p>当基本数据类型的值，被作为参数，传递给函数或者变量时，实际上是将该值的一个<strong>副本</strong>传给了它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数内部对参数所做的任何修改都不会影响到原始变量。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeValue</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="title function_">changeValue</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//输出5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// 复制 a 的值给 b，b 是独立的新值</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10（a 未受影响）</span></span><br></pre></td></tr></table></figure></li><li><p>当引用类型的值，被作为参数传递给函数或者变量时，实际上是将该值的一个<strong>引用</strong>传给了它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1; <span class="comment">// 复制引用地址，obj2 与 obj1 指向同一个对象</span></span><br><span class="line">obj2.<span class="property">value</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">value</span>); <span class="comment">// 20（原始对象被修改）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">value</span>); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">modifyObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj.<span class="property">value</span> = <span class="number">100</span>; <span class="comment">// 修改共享对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="title function_">modifyObject</span>(myObj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObj.<span class="property">value</span>); <span class="comment">// 100（原始对象被修改）</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h2><p>我们可以从<strong>增删查改</strong>，是否会修改原数组这几个角度，来给数组的常用方法归类</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a><strong>增</strong></h3><ul><li><p><code>push()</code>：可以传入任意个数的元素，这些元素会被添加到数组的末尾，返回<code>新数组的长度</code>，会修改原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = []; <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>unshift()</code>：也是可以传入任意个数的元素，这些元素会被添加到数组的首部，返回<code>新数组的长度</code>，会修改原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors)<span class="comment">//[&#x27;red&#x27;, &#x27;green&#x27;]，说明不是先推入red，后推入green，而是保持参数的传入顺序与原数组拼接</span></span><br></pre></td></tr></table></figure><p>这个方法很容易和数组另一个方法<code>shift</code>混用，后者用来删除数组首部元素。</p></li><li><p><code>splice()</code>：第一个参数传入开始位置，第二个参数（表示删除元素的个数）传入0，表示不删除元素，后续参数传入插入的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// red,yellow,orange,green,blue(插入的元素从开始下标开始排序)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed) <span class="comment">// []，返回包含被删除元素的数组，因为没有元素被删除所以是空数组</span></span><br></pre></td></tr></table></figure></li><li><p><code>concat()</code>：首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个<strong>新构建的数组，不会影响原始数组</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]，可以看到原数组并没有改变</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a><strong>删</strong></h3><ul><li><p><code>pop()</code>：方法用于删除数组的最后一项，同时减少数组的<code>length</code> 值，返回<code>被删除的项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// green</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>shift()</code>：法用于删除数组的第一项，同时减少数组的<code>length</code> 值，返回<code>被删除的项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>(); <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// red</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>splice()</code>：第一个参数传入开始位置，第二个参数传入要删除元素的个数，返回包含被删除元素的数组，如果，没有任何元素被删除，则返回空数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// [&quot;red&quot;]，只有一个元素的数组</span></span><br></pre></td></tr></table></figure></li><li><p><code>slice()</code>：本质是返回一个数组切片，<strong>并不会修改原数组</strong>，截取区间遵循<code>左闭右开</code>原则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors)   <span class="comment">// red,green,blue,yellow,purple</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>一般通过下标修改数组元素的值，也可以使用splice先删除元素再添加元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [red,red,purple,blue]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// [green]，只有一个元素的数组</span></span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>一般也是通过下标来查找数组元素。</p><ul><li><p><code>indexOf()</code>：传入一个元素，返回数组中<code>第一个</code>与该元素相等的元素的<code>下标</code>，使用的是<code>严格比较</code>，如果数组中没有该元素，则返回<code>-1</code>，因为<code>NaN</code>不与任何数相等，所以<code>indexOf(NaN)</code>返回值必定为<code>-1</code>。其实这个方法特别语义化，<code>indexOf(元素)</code>意思不就是某个元素的下标吗。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,<span class="title class_">NaN</span>];</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p><code>includes()</code>：判断某个元素是否在数组中存在，也是严格比较，存在返回<code>true</code>，否则返回<code>false</code>。对<code>NaN</code>做了特殊处理，能判断是它否存在于数组中，就这一点而言，是比indexOf要强大的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,<span class="title class_">NaN</span>];</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">//true</span></span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></li><li><p><code>find()</code>：传入一个返回值是 <code>布尔类型</code>的回调函数，用于判断满足某个条件的元素是否存在，<strong>存在则返回第一个符合条件的元素</strong>，不存在则返回<code>undefined</code>，通常用于判断<code>对象数组</code>中是否存在某个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)<span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><code>findIndex()</code>：语法和用途和find相同，不过返回的是元素的<code>下标</code>，未找到返回<code>-1</code>。</li></ul><h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><ul><li><p><code>reverse()</code>：反转数组，会修改原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure></li><li><p><code>sort()</code>：给数组排序，<code>sort()</code>方法接受一个比较函数，用于判断哪个值应该排在前面，用的是非常多，特别在算法题里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="comment">//return value1-value2 升序排序</span></span><br><span class="line">    <span class="comment">//return value2-value1 降序排序</span></span><br><span class="line">    <span class="comment">//value1[key]-value2[key] 根据某个属性升序排序，反之降序排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values); </span><br></pre></td></tr></table></figure></li></ul><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p><code>join()</code>：把数组中的元素拼<code>接成</code>一个字符串，用传入的符号连接，如果传入的符号是<code>&#39;&#39;</code>，那么就是一个类似将<code>字符数组</code>转化成<code>字符串</code>的过程。显然这个方法也不会修改原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>)); <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;||&quot;</span>)); <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul><li><p><code>some()</code>：传入一个返回值为布尔值的回调函数，作为判断条件，如果数组中<code>存在</code>满足条件的元素，则该方法返回true，否则返回false。要注意千万不要把这个方法写成<code>any</code>，数组并没有<code>any</code>方法，这是Promise的静态方法。</p></li><li><p><code>every()</code>：传入一个返回值为布尔值的回调函数，作为判断条件，如果数组中<code>每个</code>元素都满足条件，则该方法返回true，否则返回false。注意千万不要把这个方法写成<code>all</code>，数组中并没有<code>all</code>方法，这是Promise的静态方法。</p></li><li><p><code>forEach()</code>：遍历数组中的每个元素，并执行一定操作，可以<code>修改</code>原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>filter()</code>：传入一个返回值为布尔值的回调函数，作为判断条件，返回一个数组，这个数组包含所有满足这个判断条件的元素。无论原数组是否包含满足条件的元素，<code>filter</code> 总是会返回一个新的数组。如果没有找到任何满足条件的元素，则返回的是一个空数组 <code>[]</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br></pre></td></tr></table></figure></li><li><p><code>map()</code>：根据传入的回调函数和数组中的每一个元素，并返回一个新的数组。要注意的是，传入的回调函数虽然也是需要有返回值的，就如同filter，some，every，但是不同的是，<strong>传入map方法的回调函数的返回值并不是一个布尔值，而是通过每个数组元素计算得到的新的值。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a><strong>concat</strong></h4><p>用于将一个或多个字符串拼接成一个新字符串，返回一个新的字符串，不会修改原来的字符串，js中的字符串是不可变的。</p><p>在数组中也有这个方法哦，效果也非常相似，其实数组和字符串有很多同名的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>);<span class="comment">//创建一个新的字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h4 id="slice-substr-substring"><a href="#slice-substr-substring" class="headerlink" title="slice() substr() substring()"></a><strong>slice() substr() substring()</strong></h4><p>作用是返回字符串的切片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>数组中也有<code>slice()</code>方法</p></li><li><p>可以看出<code>slice()</code>和<code>substring()</code>的用法是一致的，当传入两个参数的时候，分别表示的是截取的左右区间（左闭右开，目前就没见到过左闭右闭的情况，除了正则表达式中）</p></li><li><p>而<code>substr()</code>传入两个参数时，第一个表示参数起始位置，第二个参数表示的是要截取的元素的<code>个数</code>。</p></li><li><p>当只传入一个参数，三者的效果是相同的。</p></li></ul><h4 id="indexOf-startWith-includes"><a href="#indexOf-startWith-includes" class="headerlink" title="indexOf() startWith() includes()"></a><strong>indexOf() startWith() includes()</strong></h4><p><code>indexOf</code>：从字符串<code>开头</code>去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ），数组中也有这个方法，也许因为字符串本来就可以看成字符数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><code>startWith()</code>：判断字符串是否以某个字符串开头，返回值为布尔类型。</p><p><code>includes()</code>：判断字符串中是否包含某个字符串，返回值是布尔类型，数组中也有这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>由此可见，无论是数组还是字符串中，都有indexOf，includes，slice，concat方法</p></blockquote><h3 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h3><p>把字符串按照指定的分割符，拆分成字符数组，特别是当传入<code>&#39;&#39;</code>，即空字符的时候，<strong>是真正意义上的把字符串拆分成字符数组</strong>，不会包含空字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;12+23+34&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;+&quot;</span>) <span class="comment">// [12,23,34]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>) <span class="comment">//[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;+&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;+&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3><p>提及字符串，就不得不提到模板匹配，提起模板匹配就不得不提起<code>正则表达式</code>，会在后面介绍。</p><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象（正则表达式对象），如果你传递一个非正则表达式对象，它会被隐式转换为正则表达式；返回值是数组。</p><p><strong>非全局匹配</strong>（传入的正则表达未加修饰符<code>g</code>）：只会匹配第一个符合条件的字符串片段，下面给出一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches); </span><br></pre></td></tr></table></figure><p>匹配成功的返回结果，是一个数组，但是这个数组并不是传统意义上的数组，因为它的键不全是数字，包含<code>第一个匹配的字符串片段</code>和<code>更多信息</code>。不得不说，在js中，有的数组是真像对象，但它就是数组，有的对象也是真的像数组（伪数组），但就是对象。因为在js中，数组本质就是一个对象。</p><img src="..\images\前端面试-js\match.png" style="zoom:80%"><ul><li><code>index</code> 属性：匹配结果在字符串中的开始位置</li><li><code>input</code> 属性：原始字符串</li></ul><p>如果匹配失败则返回<code>null</code></p><p><strong>全局匹配</strong></p><p>返回所有符合条件的字符串片段，并以数组的形式给出，例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches); </span><br></pre></td></tr></table></figure><p><strong>匹配成功的返回结果，只包含<code>符合条件的字符串片段</code>。</strong></p><img src="..\images\前端面试-js\match2.png" style="zoom:80%"><p>如果匹配失败则返回<code>null</code></p><h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">search</span>(regexp)</span><br></pre></td></tr></table></figure><ul><li><code>str</code> 是要进行搜索操作的字符串。</li><li><code>regexp</code> 是一个正则表达式对象。如果你传递一个非正则表达式对象（例如，一个字符串），它将被隐式转换为一个正则表达式对象。</li><li><strong>如果找到匹配项，<code>search()</code> 方法返回<code>第一个匹配项</code>的<code>首字符</code>的下标。</strong></li><li>如果没有找到匹配项，<code>search()</code> 方法返回 <code>-1</code>。</li><li>是否给传入的正则表达式添加修饰符<code>g</code>，对结果没有影响。</li><li>简单的来说<code>search</code>返回的就是<strong>第一个被匹配的字符串片段的下标</strong></li></ul><p>下面举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cas, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">let</span> index = text.<span class="title function_">search</span>(pattern);</span><br><span class="line"><span class="keyword">let</span> index2 = text.<span class="title function_">search</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index,index2); <span class="comment">//输出5,5</span></span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p><code>replace()</code> 方法用于在字符串中查找匹配的子字符串，并用新的子字符串替换它，这个方法不会改变原始字符串，因为JavaScript中的字符串是不可变的，它会返回一个新的字符串作为结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">replace</span>(regexp|substr, newSubstr|<span class="keyword">function</span>)</span><br></pre></td></tr></table></figure><ul><li><code>regexp</code> (正则表达式)：一个<code>RegExp</code>对象或者其字面量，标识要查找的子字符串。全局搜索需要使用<code>g</code>标志。</li><li><code>substr</code> (字符串)：将被替换的子字符串。</li><li><code>newSubstr</code> (字符串)：新子字符串，用于替换匹配项的字符串。</li><li><code>function</code> (函数)：用于<code>创建新子字符串</code>的函数，所以要有返回值，该函数将被每一个匹配项调用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello world! Welcome to the world of programming.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/world/g</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript! Welcome to the JavaScript of programming.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World! Welcome to the world of Programming.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/world/gi</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript! Welcome to the JavaScript of Programming.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;20 apples, 15 bananas, and 3 cherries&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/\d+/g</span>, <span class="keyword">function</span>(<span class="params">number</span>) &#123;<span class="comment">// \d+ 是匹配一个或多个数字的正则表达式</span></span><br><span class="line">    <span class="keyword">return</span> number * <span class="number">2</span>; <span class="comment">// number是被匹配的匹配项，在此处分别是20，15，3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;40 apples, 30 bananas, and 6 cherries&quot;</span></span><br></pre></td></tr></table></figure><h4 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h4><p>match方法返回的是一个数组（无论是否是全局匹配），search方法返回的是下标，replace方法返回的是修改后的字符串。</p><h2 id="说说js中的正则表达式"><a href="#说说js中的正则表达式" class="headerlink" title="说说js中的正则表达式"></a>说说js中的正则表达式</h2><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><h4 id="字面量语法"><a href="#字面量语法" class="headerlink" title="字面量语法"></a>字面量语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/pattern/</span>;</span><br></pre></td></tr></table></figure><p>例如：<code>/ab+c/i</code> 匹配 “abc”, “ABBC” 等。</p><h4 id="构造函数语法"><a href="#构造函数语法" class="headerlink" title="构造函数语法"></a>构造函数语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;pattern&#x27;</span>, <span class="string">&#x27;修饰符&#x27;</span>);</span><br></pre></td></tr></table></figure><p>例如：<code>new RegExp(&#39;ab+c&#39;, &#39;i&#39;)</code>，等价于<code>/ab+c/i</code>，感觉还是字面量语法方便啊</p><h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ul><li><code>\d</code>：数字（0-9），因为<code>digit</code>的意思就是<code>数字</code>的意思；</li><li><code>\D</code>：非数字</li><li><code>\w</code>：单词字符（字母、数字、下划线，在js中的标识符，就是由这三者构成的），<code>word</code>就是单词的意思；</li><li><code>\W</code>：非单词字符</li><li><code>\s</code>：空白符（空格、制表符、换行），<code>space</code>就是空格的意思，然而<code>\s</code>匹配的是<strong>所有类型的空白字符</strong>，而不仅仅是空格。</li><li><code>\S</code>：非空白符</li><li><code>.</code>：匹配除<code>换行外</code>的<strong>任意字符</strong>（若需包含换行，使用修饰符 <code>s</code>）</li><li><code>^</code>：字符串开头；<code>$</code>：字符串结尾</li></ul><h4 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h4><ul><li><code>[abc]</code>：匹配 a、b、c 中的任意一个</li><li><code>[a-z]</code>：匹配 a 到 z 的任意小写字母</li><li><code>[^abc]</code>：匹配<strong>任何一个</strong>不在 <code>a</code>、<code>b</code>、<code>c</code> 范围内的字符</li></ul><p>要注意的是，<strong>无论字符组中有多少个符号，匹配的都只是一个字符</strong>。</p><h4 id="分组-捕获组"><a href="#分组-捕获组" class="headerlink" title="分组&#x2F;捕获组"></a>分组&#x2F;<strong>捕获组</strong></h4><p>小括号可以将多个字符或子表达式组合在一起，形成一个<strong>逻辑单元</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/(ab)+/</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;ababab&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(pattern)); <span class="comment">// [&quot;ababab&quot;, &quot;ab&quot;]</span></span><br></pre></td></tr></table></figure><ul><li><code>(ab)</code> 将 <code>ab</code> 视为一个<strong>整体</strong>，而不是一个单独的字符。</li><li><code>+</code> 表示匹配这个整体一次或多次。</li><li>匹配结果是整个字符串 <code>&quot;ababab&quot;</code>，而第一个捕获组的结果是 <code>&quot;ab&quot;</code>。</li></ul><p>小括号会创建一个<strong>捕获组</strong>，用于提取匹配的部分内容。每个捕获组的内容可以通过 <code>match()</code> 方法的返回值中的数组访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;2023-10-05&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> match = str.<span class="title function_">match</span>(pattern);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">0</span>]); <span class="comment">// &quot;2023-10-05&quot;（完整匹配）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">1</span>]); <span class="comment">// &quot;2023&quot;（第一个捕获组）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">2</span>]); <span class="comment">// &quot;10&quot;（第二个捕获组）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">3</span>]); <span class="comment">// &quot;05&quot;（第三个捕获组）、</span></span><br></pre></td></tr></table></figure><p>其实上述正则表达式不使用捕获组，也能匹配到str，但如果不使用捕获组，结果数组中也就不会有捕获组。</p><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><ul><li><code>*</code>：0 次或多次</li><li><code>+</code>：1 次或多次</li><li><code>?</code>：0 次或 1 次</li><li><code>&#123;n&#125;</code>：精确匹配 n 次</li><li><code>&#123;n,&#125;</code>：<code>&gt;=n</code> 次</li><li><code>&#123;n,m&#125;</code>：n 到 m 次，<strong>左闭右闭</strong></li></ul><p><strong>总结</strong>：在js中的正则表达式中，中括号表示字符组，只匹配一个字符；大括号表示量词，表示匹配多少次，而小括号则表示一个分组或者匹配组。</p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ul><li><code>i</code>：不区分大小写</li><li><code>g</code>：全局匹配（查找所有匹配项）</li><li><code>m</code>：多行模式（<code>^</code> 和 <code>$</code> 匹配每行的开头和结尾）</li><li><code>s</code>：dotAll 模式（<code>.</code> 匹配换行符）</li><li><code>u</code>：Unicode 模式</li><li><code>y</code>：粘性匹配（从 <code>lastIndex</code> 开始匹配）</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hello/.<span class="title function_">test</span>(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>回布尔值，判断是否匹配成功</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(\d+).(\d+)/.<span class="title function_">exec</span>(<span class="string">&#x27;3.14&#x27;</span>); <span class="comment">// [&#x27;3.14&#x27;, &#x27;3&#x27;, &#x27;14&#x27;, index: 0, ...]</span></span><br></pre></td></tr></table></figure><ul><li><p>不使用全局标志的时候</p><p>调用一个正则表达式的exec方法，并传入一个字符串，效果完全等同于：调用一个字符串的match方法并传入一个正则表达式</p></li><li><p>使用全局标志</p><p>每次调用 <code>exec()</code> 都会从上一次匹配结束的位置，开始寻找下一个匹配项，这一点字符串的match方法就不同了，真难记啊。</p></li></ul><h2 id="Object的常见静态方法"><a href="#Object的常见静态方法" class="headerlink" title="Object的常见静态方法"></a>Object的常见静态方法</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p><code>Object.keys()</code> 方法，用于返回一个对象<strong>自身可枚举属性</strong>组成的数组。它只返回对象自身的属性（不包括原型链上的属性），并且这些属性必须是<strong>可枚举</strong>的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));<span class="comment">// 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hidden&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span> <span class="comment">// 设置为不可枚举</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// 输出: []</span></span><br></pre></td></tr></table></figure><p>我们还经常使用for in来获取一个对象<strong>所有的可枚举属性</strong>，但是它与<code>Object.keys()</code> 方法不同的是，<strong>还能获取原型链上的可枚举属性</strong>，所以在某些情况还需要借助<code>hasOwnProperty</code>来判断是不是自身的属性。</p><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values()</code> 方法，用于返回一个对象<strong>自身可枚举属性的值</strong>组成的<strong>数组</strong>。它只返回对象自身的属性（不包括原型链上的属性），并且这些属性必须是可枚举的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj));<span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code> 方法，用于返回一个对象<strong>自身可枚举属性</strong>的<strong>键值对数组</strong>。每个键值对是一个包含两个元素的数组：第一个元素是<strong>属性名（键）</strong>，第二个元素是对应的<strong>属性值</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj))<span class="comment">// 输出: [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(arr))<span class="comment">// 输出: [[&#x27;0&#x27;, &#x27;x&#x27;], [&#x27;1&#x27;, &#x27;y&#x27;], [&#x27;2&#x27;, &#x27;z&#x27;]]</span></span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>传入2个对象作为参数，会将第二个对象中<strong>可枚举的自有属性</strong>（不包括其继承自原型链上的属性），拷贝到第一个对象。返回值就是传入的第一个对象，传入的第一个对象会被修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">nature</span>: [<span class="string">&#x27;smart&#x27;</span>, <span class="string">&#x27;good&#x27;</span>],</span><br><span class="line">  <span class="attr">names</span>: &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>()]:<span class="string">&#x27;cindy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj)<span class="comment">//&#123;age: 18, nature: Array(2), names: &#123;…&#125;, Symbol(): &#x27;cindy&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2 == newObj) <span class="comment">//返回true，说明返回的就是原对象（传入的第一个对象）</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p><code>Object.defineProperty</code> 是 JavaScript 中用于定义或修改对象属性的底层方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor);</span><br></pre></td></tr></table></figure><ul><li><strong><code>obj</code></strong>: 要定义属性的目标对象。</li><li><strong><code>prop</code></strong>: 要定义或修改的属性名称（字符串或 Symbol）。</li><li><strong><code>descriptor</code></strong>: 属性描述符对象，用于定义属性的行为。<code>descriptor</code> 是一个对象，可以包含以下键值对：</li></ul><p><strong>数据描述符</strong></p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>value</code></td><td>属性的值，默认为 <code>undefined</code>。</td></tr><tr><td><code>writable</code></td><td>是否可以修改属性的值，默认为 <code>false</code>（即不可写）。</td></tr><tr><td><code>enumerable</code></td><td>是否可以通过 <code>for...in</code> 或 <code>Object.keys()</code> 枚举该属性，默认为 <code>false</code>。</td></tr><tr><td><code>configurable</code></td><td>是否可以删除该属性或修改其描述符，默认为 <code>false</code>。</td></tr></tbody></table><p><strong>存取器描述符</strong></p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>get</code></td><td>定义获取属性值时调用的函数，默认为 <code>undefined</code>。</td></tr><tr><td><code>set</code></td><td>定义设置属性值时调用的函数，默认为 <code>undefined</code>。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> _age = <span class="number">25</span>; <span class="comment">// 私有变量</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _age;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Age cannot be negative&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _age = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>); <span class="comment">// 输出 25</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">30</span>; <span class="comment">// 设置新值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>); <span class="comment">// 输出 30</span></span><br><span class="line">obj.<span class="property">age</span> = -<span class="number">5</span>; <span class="comment">// 触发错误提示，但不会修改值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure><h2 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 操作符返回一个字符串，表示值的数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> operand <span class="comment">//这种方式用的多</span></span><br><span class="line"><span class="title function_">typeof</span>(operand)</span><br></pre></td></tr></table></figure><p>这两种使用方法都是可以的。下面是一些例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;，返回的不是array</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，对所有引用数据类型（除了<code>function</code>，包括数组，普通对象），使用<code>typeof</code>返回的都是<code>object</code></p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>主要用来判断某个<code>构造函数</code>是否在某个<code>实例对象</code>的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure><h3 id="区别-3"><a href="#区别-3" class="headerlink" title="区别"></a>区别</h3><ul><li><p>typeof返回的是<code>字符串</code>，instanceof返回的是<code>布尔值</code></p></li><li><p>typeof只能能准确判断<code>基本数据</code>的类型，不能<code>准确</code>判断<code>引用数据</code>的类型。</p></li><li><p>intanceof只能准确判断<code>引用数据</code>的类型，不能判断<code>基本数据</code>的类型</p></li></ul><p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><p>还有一种通用的判断方式<code>Object.prototype.toString()</code>，简单来说就是<code>Object</code>原型对象上挂载的<code>toString</code>方法。这个我们常见但是用的不多的方法，真的有这么强大的功能吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>可以看到返回的结果是一个字符串，第一位都是<code>object</code>，这与js中<strong>万物皆对象</strong>的思想符合。</p></li><li><p>所有类型的数据都能调用<code>toString()</code>方法，如果是基本数据类型，会先进行数据<code>装箱</code>，转化成<code>对象</code>，再调用这个方法。</p></li><li><p>Object是所有对象的父类（Object在所有对象的原型链上），所以所有对象都能访问到这个方法，那为什么不直接让数据调用这个方法呢？因为对象的原型链上可能还存在<code>同名方法</code>。使用<code>函数.call(对象)</code>的方式，能确保对象调用的就是指定的函数&#x2F;方法。不过要这么写代码也太长了吧，要不先直接调用<code>toString</code>方法试试？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125;.<span class="title function_">toString</span>()) <span class="comment">//[object Object]</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>())<span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>.<span class="title function_">toString</span>())<span class="comment">//1，字符串能直接调用这个方法，因为它不是纯种的基本数据类型</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="title function_">toString</span>())<span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">toString</span>())<span class="comment">//function () &#123; &#125;</span></span><br></pre></td></tr></table></figure><p>结果发现，果然不行啊。</p></li></ul><h2 id="谈谈-JavaScript-中的类型转换机制"><a href="#谈谈-JavaScript-中的类型转换机制" class="headerlink" title="谈谈 JavaScript 中的类型转换机制"></a>谈谈 JavaScript 中的类型转换机制</h2><p>前面我们讲到，<code>JS</code>中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code></p><p>常见的类型转换有：</p><ul><li>强制转换（显示转换）</li><li>自动转换（隐式转换）</li></ul><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>显式转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：</p><ul><li>Number()</li><li>parseInt()</li><li>String()</li><li>Boolean()</li></ul><h4 id="Number-1"><a href="#Number-1" class="headerlink" title="Number()"></a>Number()</h4><p>将任意类型的值转化为<code>数值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 空字符串转为0，空数组也转换成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//对象：通常转换成NaN,除了只包含单个数值的数组和空数组</span></span><br><span class="line"><span class="title class_">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Number</span>([]) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li>从上面可以看到，<code>Number</code>转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code></li><li><code>null</code>转化成数字类型是0，而<code>undefined</code>转化成数字类型是<code>NaN</code>，这是二者最大的区别之一</li><li>总结一下，哪些数据转化成数字类型后的值是0：<ul><li>空字符串</li><li>false</li><li>null</li><li>空数组（空字符串是不是也能看作空字符数组呢？）</li></ul></li></ul><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p><code>parseInt</code>相比<code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来。这个方法是可以直接被调用的，不许要显式借助其他对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;32a3&#x27;</span>) <span class="comment">//32</span></span><br></pre></td></tr></table></figure><p>要注意的是，如果传入<code>parseInt</code>的值不是<strong>以数字开头的字符串</strong>，那么<code>parseInt</code>的返回值将是<code>NaN</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="literal">true</span>))<span class="comment">//输出NaN，因为传入的不是字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;a123&#x27;</span>))<span class="comment">//输出NaN</span></span><br></pre></td></tr></table></figure><p>和<code>parseInt</code>方法类似的还有<code>parseFloat</code>方法，后者和前者不同的是，是从字符串中提取出浮点数。</p><h4 id="String-1"><a href="#String-1" class="headerlink" title="String()"></a>String()</h4><p>可以将任意类型的值转化成<code>字符串</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值：转为相应的字符串</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">1</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="comment">//字符串：转换后还是原来的值</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="comment">//undefined：转为字符串&quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="comment">//null：转为字符串&quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="title class_">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot; 调用数组的toString方法就是去除左右括号</span></span><br></pre></td></tr></table></figure><p>可以看到，对于<code>基本数据类型</code>，强制转化成字符串，就是加个<code>双引号</code>就好了，而引用数据类型就不一样了，需要调用<code>toString</code>方法</p><h4 id="Boolean-1"><a href="#Boolean-1" class="headerlink" title="Boolean()"></a>Boolean()</h4><p>可以将任意类型的值转为<code>布尔值</code>，转换规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false </span></span><br><span class="line"><span class="title class_">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// 因为返回的是一个对象Boolean &#123;false&#125;，所以转化成布尔值是true</span></span><br></pre></td></tr></table></figure><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>隐式转换本质就是偷偷帮我们调用了显式转换的函数，在隐式转换中，我们可能最大的疑惑是 ：何时发生<code>隐式转换</code>？</p><p>我们这里可以归纳为两种情况发生隐式转换的场景：</p><ul><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）</li><li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li><li><code>if</code>、<code>while</code>需要布尔值地方</li></ul><p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p><ul><li><p><strong>自动转化成布尔值</strong></p><p>在需要<code>布尔值</code>的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用<code>Boolean</code>函数</p></li><li><p><strong>自动转换成字符串</strong></p><p>遇到预期为<code>字符串</code>的地方，就会将非字符串的值自动转为字符串</p><p>常发生在<code>+</code>运算中，一旦存在字符串，则会进行字符串拼接操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot; ，因为&#123;&#125;转化成字符串是[object Object]</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot; 因为[]转换成字符串是空串</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;，因为函数调用toString方法返回值是function ()&#123;&#125;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure><p>对于基本数据类型和函数，字符串拼接的时候直接参与拼接，对于其他引用数据类型，需要先调用<code>toString</code>方法。哈哈，原来字符串凭借不是所有情况都是直接拼接啊。</p></li><li><p><strong>自动转换成数值</strong></p><p>除了左右两边包含字符串的<code>+</code>号，<code>其他运算符</code>都会把参与运算的数据自动转成<code>数值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * []    <span class="comment">// 等价于5*0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 等价于0/5</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// 等价于NaN-1</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 等价于0+1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// 等价于NaN+1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a><strong>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</strong></h2><p>一个是<code>宽松比较</code>，一个是<code>严格比较</code>；<code>==</code>比较<code>值</code>是否相等，不比较<code>类型</code>是否相同，允许隐式转换。<code>===</code>比较的是<code>值</code>和<code>类型</code>是否相同，都相同才会返回true。</p><p>难点在于<code>==</code>非严格比较，比较规则如下</p><ul><li><p><code>undefined == null</code> 返回true</p><p>在非严格比较中，<code>undefined</code>和<code>null</code>，只与<code>undefined</code>或者<code>null</code>相等。</p><p>这就意味着，<code>undefined==0</code>的值是false，<code>null==0</code>的值也是false，<code>undefined==false</code>的值也是false，<code>null==false</code>的值也是false。这其实就很奇怪，为什么<code>null</code>和<code>undefined</code>在作为<code>if()</code>的判断条件的时候，可以隐式转化成<code>false</code>，但是当和<code>false</code>进行非严格比较，返回值就是false。</p></li><li><p>NaN &#x3D;&#x3D; NaN 返回false</p><p><code>NaN</code>和任何数比较，包括本身，都返回false。</p></li><li><p>两个都为<code>简单类型</code>，<strong>字符串</strong>和<strong>布尔值</strong>都会转换成<strong>数值</strong>，再比较。</p></li><li><p>如果一个操作数是<code>对象</code>，另一个操作数不是，则调用对象的 <code>valueOf()</code>方法取得其<strong>原始值</strong>，再根据前面的规则进行比较。</p></li><li><p>两个都为引用类型，则比较它们是否指向同一个对象，也就是比较<strong>地址</strong>是否相同。</p></li></ul><h2 id="Javascript-数字精度丢失的问题"><a href="#Javascript-数字精度丢失的问题" class="headerlink" title="Javascript 数字精度丢失的问题"></a>Javascript 数字精度丢失的问题</h2><h3 id="为什么会出现精度丢失"><a href="#为什么会出现精度丢失" class="headerlink" title="为什么会出现精度丢失"></a>为什么会出现精度丢失</h3><p>对于某些<strong>小数</strong>，计算机无法用<strong>有限的二进制位精确的表示</strong>，比如0.1用二进制表示思路如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>*<span class="number">2</span>=<span class="number">0.2</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.2</span>*<span class="number">2</span>=<span class="number">0</span>*<span class="number">4</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.4</span>*<span class="number">2</span>=<span class="number">0.8</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.8</span>*<span class="number">2</span>=<span class="number">1.6</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br></pre></td></tr></table></figure><p>假设<code>0.1</code>的二进制表示是<code>0.xxxx</code>，每次对<code>0.1×2</code>，都会让二进制表示中的小数点<code>右移</code>一位(就像我们给十进制小数<code>×10</code>会让小数点右移一样，每个数的权值都变大了)，即<code>x.xxxx</code>，如果<code>0.1×2&lt;1</code>，说明<strong>第一个x为0</strong>，依此类推，<code>0.1</code>的二进制表示为<code>0.0001xxxx</code>，然后我们继续计算后续的x的值。<code>0.1×16 = 1.6</code>,对应的二进制表示为<code>1.xxxx</code>，显然<code>0.xxxx</code>应该表示的是<code>0.6</code>，所以我们就把问题转化为求<code>0.6</code>的二进制表示了。</p><p>**简单的来说，如果要求我们求某个小数对应的二进制表示，我们只需要对小数不断的<code>×2</code>**，如果结果<code>小于1</code>，填入<code>0</code>，反之填入<code>1</code>，然后对乘法的结果<code>-1</code>，然后继续计算，填入的位置是从小数点的高位到低位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6</span>*<span class="number">2</span>=<span class="number">1.2</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br><span class="line"><span class="number">0.2</span>*<span class="number">2</span>=<span class="number">0.4</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.4</span>*<span class="number">2</span>=<span class="number">0.8</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.8</span>*<span class="number">2</span>=<span class="number">1.6</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br><span class="line"><span class="number">0.6</span>*<span class="number">2</span>=<span class="number">1.2</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br></pre></td></tr></table></figure><p>因此我们可以得出<code>0.1</code>的二进制表示是<code>0.000110011....</code>很明显这是一个<code>无限循环小数</code>，我们<strong>无法用有限的二进制位来精确的存储</strong>这个小数，<strong>因为存储的时候，数据就没有被准确的存储，所以下次再取出使用的时候就会有精度损失</strong>。</p><blockquote><p>后面的扩展内容涉及的主要是计组知识</p></blockquote><p>在<code>JavaScript</code>中，现在主流的数值类型是<code>Number</code>，而<code>Number</code>采用的是<code>IEEE754</code>规范中<strong>64位双精度浮点数编码</strong>。</p><p>如何理解这个<code>双</code>字呢，这个<code>双</code>表示使用2个<code>机器字</code>（word）来表示浮点数，通常现代计算机的一个<code>机器字</code>是 32 位，双精度意思就是用<code>64位</code>来表示浮点数。这样的存储结构优点是可以<strong>统一处理整数和小数</strong>，节省存储空间。</p><p>我们先来看看如何将一个浮点数用<code>IEEE754单精度浮点数编码</code>表示，单精度浮点数编码用<code>32位</code>来表示浮点数，第一位是符号位，0表示正数，1表示负数；后8位表示指数位，后23位表示尾数。</p><p>拿<code>0.75</code>这个浮点数举例子，将它转换成二进制是<code>0.11</code>，然后将二进制转换成<code>1.xxx*2^n</code>的形式，就是<code>1.1*2^-1</code>，由于这个数是正数，所以第一位是0，<strong>指数位</strong>是<code>-1</code>，我们将它与127（二进制表示是8个1<code>11111111</code>）相加得到126（<code>11111110</code>），我们把这个操作叫做<strong>偏移</strong>，然后尾数是1，这样我们就可以得到<code>单精度浮点数编码</code>表示：0111111101，然后要凑齐32位，后面补零就好。</p><p>对于双精度浮点数编码，道理其实也是一样的，不同的是，使用1位表示<code>符号位</code>，11位表示<code>指数位</code>，52位表示<code>尾数</code> 。</p><p>具体如何处理可以自行搜索或者参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/JavaScript/loss_accuracy.html#%E4%B8%80%E3%80%81%E5%9C%BA%E6%99%AF%E5%A4%8D%E7%8E%B0">面试官：说说 Javascript 数字精度丢失的问题，如何解决？ | web前端面试 - 面试官系列</a></p><h3 id="如何解决精度缺失问题"><a href="#如何解决精度缺失问题" class="headerlink" title="如何解决精度缺失问题"></a>如何解决精度缺失问题</h3><ul><li><p>先把<code>小数</code>转换成<code>整数</code>再参与运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0.2</span></span><br><span class="line"><span class="keyword">let</span> c = a + b</span><br><span class="line"><span class="keyword">let</span> d = (a * <span class="number">10</span> + b * <span class="number">10</span>) / <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c == <span class="number">0.3</span>, d == <span class="number">0.3</span>)<span class="comment">//输出false true</span></span><br></pre></td></tr></table></figure></li><li><p>借助第三方工具库，比如<code>Math.js</code>、<code>BigDecimal.js</code>，通过<code>调用相关方法</code>来模拟加减乘除运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;mathjs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> a = math.<span class="title function_">bignumber</span>(<span class="string">&#x27;0.1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = math.<span class="title function_">bignumber</span>(<span class="string">&#x27;0.2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = math.<span class="title function_">add</span>(a, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">format</span>(result, &#123;<span class="attr">notation</span>: <span class="string">&#x27;fixed&#x27;</span>&#125;)); <span class="comment">// 输出 &quot;0.3&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/bigdecimal.js/0.6.2/bigdecimal.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">bigDecimal</span>(<span class="string">&#x27;0.1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">bigDecimal</span>(<span class="string">&#x27;0.2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> result = a.<span class="title function_">add</span>(b);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">toString</span>()); <span class="comment">// 输出 &quot;0.3&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="说说-JavaScript-中内存泄漏的几种情况"><a href="#说说-JavaScript-中内存泄漏的几种情况" class="headerlink" title="说说 JavaScript 中内存泄漏的几种情况"></a>说说 JavaScript 中内存泄漏的几种情况</h2><h3 id="内存泄漏是什么"><a href="#内存泄漏是什么" class="headerlink" title="内存泄漏是什么"></a>内存泄漏是什么</h3><p>内存泄漏（Memory leak）指的是在计算机科学中，由于疏忽或错误，造成程序<strong>未能释放已经不再使用的内存</strong>。</p><p>对于<code>持续运行的进程</code>，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p>可以拿电脑游戏来举例，3a大作的体积动辄几十上百GB，但是我们的电脑并没有这么多的内存（外存一般都有几百GB，但是内存一般只有几十GB），我们玩游戏的时候，并不会将游戏的全部资源都放入内存中，而是只将需要用到的资源放入，并释放不再需要的内存。</p><h3 id="垃圾自动回收机制"><a href="#垃圾自动回收机制" class="headerlink" title="垃圾自动回收机制"></a><strong>垃圾自动回收机制</strong></h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在<code>C</code>语言中，因为是手动管理内存，内存泄露是经常出现的事情。</p><p>这很麻烦，所以大多数语言提供<code>自动内存管理</code>，减轻程序员的负担，这被称为<code>垃圾自动回收机制</code></p><p>js也有垃圾自动回收机制。</p><p><strong>原理</strong>：<code>垃圾收集器</code>会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。</p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>通常情况下有两种实现方式，用来判断哪些变量不再使用：</p><ul><li>标记清除</li><li>引用计数</li></ul><p><strong>标记清除</strong></p><p><code>清除</code>那些被<code>标记</code>的变量，释放它们的内存，是<code>JavaScript</code>最常用的垃圾收回机制，</p><p>垃圾回收程序运行的时候，会标记内存中存储的<code>所有变量</code>。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉</p><p>在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了</p><p>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">0</span>,n = <span class="number">19</span> <span class="comment">// 把 m,n,add() 标记为进入环境。</span></span><br><span class="line"><span class="title function_">add</span>(m, n) <span class="comment">// 把 a, b, c标记为进入环境。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// a,b,c标记为离开环境，等待垃圾回收。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">var</span> c = a + b</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用计数</strong></p><p>语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是<code>0</code>，就表示这个值不再用到了，因此可以将这块内存释放。</p><p>如果一个值不再需要了，引用数却不为<code>0</code>，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。变量<code>arr</code>是仅有的对这个值的引用，因此引用次数为<code>1</code>。尽管后面的代码没有用到<code>arr</code>，它还是会持续占用内存</p><p>如果需要这块内存被垃圾回收机制释放，只需要设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>通过设置<code>arr</code>为<code>null</code>，就解除了对数组<code>[1,2,3,4]</code>的引用，引用次数变为 0，就被垃圾回收了。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>在js这门语言中，不需要用户手动管理内存，所以出现内存问题的情况较少</li><li>js的内存的自动回收机制主要有两种实现方法：<ul><li>标记清除：清除被标记的<strong>变量</strong>，被标记的变量就是不再使用的变量</li><li>引用计数：如果某个数据的引用次数为0，说明这个数据不再被使用，可以被清除</li></ul></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有了垃圾自动回收机制，并不代表不用担心内存泄漏问题，对于那些占用内存很大的变量，确保它们不再被使用的时候，不存在对它们的引用。</p><h3 id="常见内存泄漏情况"><a href="#常见内存泄漏情况" class="headerlink" title="常见内存泄漏情况"></a>常见内存泄漏情况</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a><strong>意外的全局变量</strong></h4><ul><li><p><strong>给一个未声明的标识符赋值</strong>，javaScript 引擎会认为你在引用一个已经存在的全局变量；如果找不到这个变量，则会自动在全局对象（浏览器环境中为 <code>window</code>，Node.js 环境中为 <code>global</code>）上创建它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>直接调用构造函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接调用foo，this 指向了全局对象（window）</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>直接调用构造函数，也会在全局对象上挂载数据。使用严格模式，可以避免意外的全局变量。</p></li></ul><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h4><p>定时器开启后，除非显式的清除，否则将一直存在，如果定时器中引用了不再使用的变量，又未及时清除定时器，就会造成内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果<code>id</code>为Node的元素从<code>DOM</code>中移除，该定时器仍会存在，同时，因为回调函数中包含对<code>someResource</code>的引用，定时器外面的<code>someResource</code>也不会被释放。</p><p>除了定时器之外，延时器(setTimeout)和事件监听器(addEventListener)，如果不使用，都要记得清除或者解绑，否则会持续引用不再需要的回调函数，从而造成内存泄漏，因为函数也是一种类型的数据，也会占用内存。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> unused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> func = <span class="title function_">bindEvent</span>()</span><br><span class="line"><span class="comment">//解决方法，清除引用</span></span><br><span class="line">func = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>即便函数调用结束了，由于func持续引用unused函数，这个函数的空间不会被释放，又因为unused函数引用obj，obj这个变量的内存空间也不会被释放。</p><h2 id="说说你对闭包的理解？闭包使用场景"><a href="#说说你对闭包的理解？闭包使用场景" class="headerlink" title="说说你对闭包的理解？闭包使用场景"></a>说说你对闭包的理解？闭包使用场景</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>闭包由一个<code>内部函数</code>和它引用的<code>外部函数</code>的作用域组成。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>创建私有变量</li><li>延长变量的生命周期</li></ul><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立即执行函数，充当外部函数</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> a = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span></span><br><span class="line"><span class="language-javascript">  &#125;<span class="comment">//因为没有外部函数，所以没有构成闭包</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="说说你对防抖和节流的理解"><a href="#说说你对防抖和节流的理解" class="headerlink" title="说说你对防抖和节流的理解"></a>说说你对防抖和节流的理解</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>本质上是<code>优化高频率执行代码造成的性能损耗</code>的一种手段。</p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。</p><p>为了优化体验，我们需要限制这类事件的调用次数，对此我们就可以采用 <strong>防抖（debounce）</strong> 或者<strong>节流（throttle）</strong> 的方式，来减少回调函数调用频率</p><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>定义</strong></p><p>事件被触发后，且在<strong>n秒</strong>内不再触发该事件，则执行对应的回调函数，如果在<strong>n秒</strong>内再次触发该事件，则清除先前的延时器，重新开始计时；可以用操作系统中的资源被剥夺来理解，这里的资源就是<code>延时器</code>。</p><p>简单的来说，就是对于频繁触发的事件，只执行最后一次触发对应的事件回调。</p><p><strong>手写防抖函数</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>传入一个函数，返回一个实现了防抖的函数，返回的防抖函数，本质就是在执行传入的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myDebounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//形成了一个闭包，内部函数引用了外部函数的变量timer,func,wait</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      <span class="comment">//开启新的定时器</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改this指向，传入e</span></span><br><span class="line">        func.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[type=text]&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="title function_">myDebounce</span>(func, <span class="number">500</span>))</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>定义</strong></p><p>在n秒内无论触发多少次事件，只执行<code>第一次触</code>发对应的<code>回调函数</code></p><p>可以用操作系统中的<code>资源不可被剥夺来理解</code>，这里的资源就是<code>延时器</code>。</p><p>简单的来说就是，对于频繁触发的事件，每间隔一定时间才执行一次事件回调。</p><p><strong>手写节流</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">myThrottle</span>(func, <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入一个函数，返回一个实现了节流的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myThrottle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="comment">//声明一个定时器，写在外部函数是因为防止每次调用返回的节流函数都重新初始化定时器</span></span><br><span class="line">    <span class="comment">//myThrottle只会被调用一次，而返回的节流函数会被调用多次，因为充当的是回调函数</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//返回一个新的函数,这个函数引用了func,wait和timer，构成闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="comment">//如果定时器已经开启直接返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//虽然实际调用的是返回的新函数，但是在函数内部还是调用了传入的func函数，而且我们使用apply模拟了直接调用</span></span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//释放资源，因为延时器结束也不会修改timer（延时器id）的值</span></span><br><span class="line">        <span class="comment">//如果我们不这么做，节流只能触发一次</span></span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="comment">//返回的节流函数没有返回值，如果有，因该是func函数的返回值，但是我们不关心返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>相同点：</p><ul><li>都可以通过使用 <code>setTimeout</code> 实现</li><li>目的都是，降低回调函数的执行频率。节省计算资源</li></ul><p>不同点：</p><ul><li>函数防抖，在一段连续操作结束后，只执行最后一次触发对应的回调。函数节流，在一段连续操作中，每一段时间只执行一次，在频率较高的事件中被使用来提高性能。</li><li>函数防抖关注一定时间连续触发的事件，只在<strong>最后执行一次</strong>，而函数节流<strong>一段时间内只执行一次</strong>。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>防抖在连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li><li>简单的来说就2种情况，<strong>输入和调整窗口大小</strong></li></ul><p>节流在间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>搜索框，搜索联想功能</li></ul><h2 id="说说函数的apply，call，bind方法"><a href="#说说函数的apply，call，bind方法" class="headerlink" title="说说函数的apply，call，bind方法"></a>说说函数的apply，call，bind方法</h2><p>这三个方法都是函数（Function）原型（prototype）上的方法，作用是用来修改函数内部this的指向。</p><p>值得注意的是，箭头函数也可以调用这个三个方法，但是不能改变其内部this的指向。</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>传入call方法的多个参数（除了obj），会被收集为一个数组<code>args</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现自己的call函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myCall</span>(<span class="params">obj, ...args</span>) &#123;</span><br><span class="line">   <span class="comment">//总假设传入的obj是一个对象</span></span><br><span class="line">   <span class="keyword">const</span> f = <span class="title class_">Symbol</span>()</span><br><span class="line">   obj[f] = <span class="variable language_">this</span></span><br><span class="line">   <span class="keyword">const</span> res = obj[f](...args)</span><br><span class="line">   <span class="keyword">delete</span> obj[f]</span><br><span class="line">   <span class="comment">//返回被调用函数的返回值 </span></span><br><span class="line">   <span class="keyword">return</span>  res</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = myCall</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply方法和call方法不同的是，要求传入的第二个参数是一个<code>数组</code>，而不是多个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myApply</span>(<span class="params">obj, args</span>) &#123;</span><br><span class="line">   <span class="comment">//总假设传入的obj是一个对象</span></span><br><span class="line">   <span class="keyword">const</span> f = <span class="title class_">Symbol</span>()</span><br><span class="line">   obj[f] = <span class="variable language_">this</span></span><br><span class="line">   <span class="keyword">const</span> res = obj[f](...args)</span><br><span class="line">   <span class="keyword">delete</span> obj[f]</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//返回被调用函数的返回值</span></span><br><span class="line">   <span class="comment">//我们关心的不仅仅是传入的函数，被调用时内部this指向是否满足要求</span></span><br><span class="line">   <span class="comment">//还要确保还能拿到传入的函数的返回值</span></span><br><span class="line">   <span class="comment">//也就是说，使用call或者apply调用函数后的返回值，就是原来那个函数的返回值</span></span><br><span class="line">   <span class="keyword">return</span>  res</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = myApply</span><br><span class="line"><span class="keyword">let</span> func = <span class="title function_">functiom</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind方法和前2个方法不同的是，并不会立即调用目标函数，而是返回一个新的函数，在这个函数内部调用目标函数。</p><p>bind方法和call相似的是，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myBind</span>(<span class="params">obj, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">//返回的函数也能接收多个参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="comment">//合并参数</span></span><br><span class="line">    <span class="keyword">const</span> args3 = [...args, ...args2]</span><br><span class="line">    <span class="keyword">let</span> f = <span class="title class_">Symbol</span>()</span><br><span class="line">    obj[f] = context</span><br><span class="line">    <span class="comment">//调用目标函数并拿到返回值</span></span><br><span class="line">    <span class="keyword">const</span> res = obj[f](...args3)</span><br><span class="line">    <span class="keyword">delete</span> obj[f]</span><br><span class="line">    <span class="comment">//返回返回值</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，对于bind方法返回的函数，我们不关心它内部的this指向，因为我们根本不需要使用它的this，它只要确保使用了传入的目标对象，调用了指定的函数即可。</p><h2 id="说说js中的日期对象Date"><a href="#说说js中的日期对象Date" class="headerlink" title="说说js中的日期对象Date"></a>说说js中的日期对象Date</h2><p>JavaScript中的<code>Date</code>对象用于处理日期和时间。它提供了一系列方法来获取和设置日期的各个方面，如年、月、日、小时、分钟、秒和毫秒等</p><h3 id="创建日期对象"><a href="#创建日期对象" class="headerlink" title="创建日期对象"></a>创建日期对象</h3><p>我们都知道，通过<code>new Date()</code>就可以创建一个代表当前日期时间的对象，但是你有没有想过，可以给<code>Date</code>构造函数传入不同的参数呢？</p><ul><li><p>不带参数：创建一个代表<code>当前日期和时间</code>的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now); <span class="comment">// 输出类似 &quot;2025-03-07T03:48:32.123Z&quot; 的字符串（具体时间取决于执行时刻）</span></span><br></pre></td></tr></table></figure></li><li><p>带<strong>日期字符串</strong>参数：根据提供的日期字符串，创建对应的日期对象，但通常情况下，要我们手动传入一个格式规范的日期字符串，是比较难的吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateStr = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2025-03-07T00:00:00&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dateStr); <span class="comment">// 输出 &quot;2025-03-07T00:00:00.000Z&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>带时间戳参数：根据传入的时间戳，返回对应的时间日期对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timestamp = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1709756400000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(timestamp); <span class="comment">// 输出 &quot;2025-03-07T00:00:00.000Z&quot;</span></span><br><span class="line"><span class="comment">//我们只要再调用toLocaleString方法，时间格式就变得熟悉了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(timestamp.<span class="title function_">toLocaleString</span>()) <span class="comment">// 2024/3/7 04:20:00</span></span><br></pre></td></tr></table></figure></li><li><p>通过<strong>多个数值参数</strong>创建：指定年、月（从0开始计数）、日、时、分、秒和毫秒，感觉是比传入一个日期字符串好用？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> customDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2025</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 注意月份是从0开始计数的，所以2表示3月</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customDate); <span class="comment">// 输出 &quot;2025-03-07T00:00:00.000Z&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="获取日期信息"><a href="#获取日期信息" class="headerlink" title="获取日期信息"></a>获取日期信息</h3><p><code>Date</code>对象提供了多种方法来获取日期的不同部分：</p><ul><li><code>getFullYear()</code>：获取四位数的年份。</li><li><code>getMonth()</code>：获取月份（0-11）。</li><li><code>getDate()</code>：获取一个月中的某一天（1-31）。</li><li><code>getDay()</code>：获取星期几（0-6，0表示星期天）。</li><li><code>getHours()</code>：获取小时（0-23）。</li><li><code>getMinutes()</code>：获取分钟（0-59）。</li><li><code>getSeconds()</code>：获取秒（0-59）。</li><li><code>getMilliseconds()</code>：获取毫秒（0-999）。</li><li><code>getTime()</code>：获取自1970年1月1日以来的毫秒数，也就是<strong>时间戳</strong>，获取时间戳的方法还有<code>Date.now()</code></li></ul><h3 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h3><ul><li><code>toDateString()</code>：返回<code>日期部分</code>的字符串表示形式，不常用</li><li><code>toTimeString()</code>：返回<code>时间部分</code>的字符串表示形式，不常用</li><li><code>toISOString()</code>：返回ISO格式的日期字符串（UTC时间），不常用</li><li><code>toLocaleString()</code>：基于本地时间格式化日期和时间，<strong>常用</strong>，要注意的是不要把<code>locale（现场）</code>写成<code>local（本地）</code></li><li><code>toLocaleDateString()</code>：仅格式化日期部分为本地格式。</li><li><code>toLocaleTimeString()</code>：仅格式化时间部分为本地格式。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toDateString</span>())<span class="comment">//Fri Mar 07 2025</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toTimeString</span>())<span class="comment">//2:38:26 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toISOString</span>())<span class="comment">//2025-03-07T04:38:26.053Z</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleString</span>())<span class="comment">//2025/3/7 12:41:03</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocalDateString</span>())<span class="comment">//2025/3/7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleTimeString</span>())<span class="comment">//12:41:03</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p>当我们拷贝一个基本类型的数据，拷贝的就是它的<code>值</code>，此时没有深浅拷贝一说，只有当我们拷贝一个对象的时候，才有深浅拷贝的说法。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝顾名思义，就是浅层次的拷贝，只拷贝<code>一层</code>。当我们要拷贝一个对象的时候，对于这个对象的所有属性，如果属性的值是<code>基本数据类型</code>，那我们直接拷贝<code>值</code>，如果属性值为<code>引用数据类型</code>，则拷贝<code>地址</code>。示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">//只拷贝obj自身的属性</span></span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            newObj[prop] = obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出浅拷贝的手动实现也是非常简单的。</p><p><strong>浅拷贝常见方法</strong></p><p>实现浅拷贝主要有2种方法，<code>Object.assign</code>和扩展运算符</p><ul><li><p><code>Object.assign</code></p><p>只会拷贝对象中<strong>可枚举的自有属性</strong>，不会拷贝其继承自原型链上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">nature</span>: [<span class="string">&#x27;smart&#x27;</span>, <span class="string">&#x27;good&#x27;</span>],</span><br><span class="line">  <span class="attr">names</span>: &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="string">&#x27;fx&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj[f] = <span class="string">&#x27;cindy&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj)<span class="comment">//&#123;age: 18, nature: Array(2), names: &#123;…&#125;, Symbol(): &#x27;cindy&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2 == newObj) <span class="comment">//返回true，说明返回的就是原对象（传入的第一个对象）</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用<code>扩展运算符</code>实现的拷贝</p><p>使用扩展运算符不仅能拷贝对象，还能拷贝数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = [...fxArr]</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br><span class="line"></span><br><span class="line">onst obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = &#123; ...obj &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// 输出: &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>对一个对象进行深拷贝，拷贝多层。当我们要深拷贝一个对象的时候，对于这个对象的所有属性，如果属性的值是<code>基本数据类型</code>，那我们直接拷贝<code>值</code>，如果属性值为<code>引用数据类型</code>，则我们递归拷贝这个引用类型。特点是深拷贝得到的对象与原对象没有任何<strong>公共的内存空间</strong>。</p><p><strong>深拷贝常见方法</strong></p><ul><li><p>_.cloneDeep()</p><p>借助第三方库<code>lodash</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>);<span class="comment">// false,验证是深度拷贝</span></span><br></pre></td></tr></table></figure></li><li><p>手写简单深拷贝</p><p>核心在于把值为基本类型的属性，当作<strong>递归出口</strong>，实现起来也不是很难，尝试自己敲一遍。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是null或者不是object类型(基础数据类型)，则直接返回，这是一个递归出口</span></span><br><span class="line">    <span class="comment">// 注意判断一个是不是对象不要使用 !obj instanceof Object,这在运算优先级上有问题，!会先与obj运算</span></span><br><span class="line">    <span class="comment">// 正确的写法是!(obj instanceof Object)或者typeof obj !== &#x27;object&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理Array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">        <span class="comment">//创建一个新数组数组</span></span><br><span class="line">        <span class="keyword">let</span> cloneArr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; obj.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//递归进行拷贝</span></span><br><span class="line">            cloneArr[i] = <span class="title function_">deepClone</span>(obj[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回这个</span></span><br><span class="line">        <span class="keyword">return</span> cloneArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理Object</span></span><br><span class="line">    <span class="comment">// 创建一个新的空对象</span></span><br><span class="line">    <span class="keyword">let</span> cloneObj = &#123;&#125;;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">         cloneObj[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>JSON.stringify()</code></p><p>但是这种方式存在<strong>弊端</strong>，会忽略值为<code>undefined</code>，<code>symbol</code>，<code>函数</code>的属性，因为这些值都是<code>不可被序列化</code>的，不会出现在序列化的字符串中。除此之外，使用Symbol作为键的属性也不会包含在序列化的结果中，<strong>因为JSON标准不支持Symbol类型的键</strong>，并不是因为Symbol类型的键是不可枚举的（实际上是可枚举的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name1</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">name3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;,</span><br><span class="line">  <span class="attr">name4</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">  <span class="attr">name5</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[name] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;name5: &quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>关于<code>JSON.stringify()</code>还要一个问题就是，传入什么值的时候会报错？当尝试序列化一个循环引用的对象的时候，会报错。</p></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>浅拷贝和深拷贝都创建出一个新的对象，这个新的对象与原对象内容完全相同，浅拷贝新旧对象可能存在公共的空间，修改新对象属性可能会影响原对象，而深拷贝新旧对象则不存在公共的空间，修改数据不会相互影响。</p><h2 id="说说js中的事件模型"><a href="#说说js中的事件模型" class="headerlink" title="说说js中的事件模型"></a>说说js中的事件模型</h2><h3 id="事件与事件流"><a href="#事件与事件流" class="headerlink" title="事件与事件流"></a>事件与事件流</h3><p>事件就是用户与页面或者浏览器进行的<strong>交互操作</strong>；</p><p>事件流都会经历三个阶段：</p><ul><li>事件<code>捕获阶段</code>(capture phase)</li><li>处于<code>目标阶段</code>(target phase)</li><li>事件<code>冒泡阶段</code>(bubbling phase)</li></ul><p>当我们在某个元素上触发某个事件的时候（这个与我们直接交互的元素叫做<code>目标元素</code>）,然后事件流就会从顶级元素开始，通常是<code>DOM</code>元素，流向目标元素，这个向下流动的过程叫做<code>事件捕获</code>，再流回顶级元素，这个向上流动的过程叫做<code>事件冒泡</code>。事件监听通常是在冒泡阶段触发的。</p><h3 id="事件模型分类"><a href="#事件模型分类" class="headerlink" title="事件模型分类"></a>事件模型分类</h3><p>有三大类：<code>原始事件模型</code>，<code>标准事件模型</code>，ie事件模型（很少用了）</p><ul><li><p><strong>原始事件模型（DOM0级）</strong></p><p><strong>绑定方式</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;fun()&quot;</span>&gt; <span class="comment">//里面的js代码会被执行，所以不要写成函数名，而是可执行的js代码</span></span><br></pre></td></tr></table></figure><p>或者写成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[type=button]&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = fun;<span class="comment">//相当于给dom元素添加属性，传入一个函数，作为回调函数，而不是传入可执行的代码</span></span><br></pre></td></tr></table></figure><p>link标签也可以添加onload属性，link标签加载后再执行相关逻辑，比如修改media类型。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./txt.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;setTimeout(()=&gt;&#123;this.media=&#x27;all&#x27;&#125;,2000)&quot;</span>&gt;</span></span><br><span class="line">//this指向link标签，是linnk标签对应的dom对象</span><br></pre></td></tr></table></figure><p>link标签加载完毕后再参与渲染，这也会存在样式闪烁问题。</p><p><strong>解绑方式：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>绑定速度快</li><li>只支持<code>冒泡触发</code>，不支持<code>捕获触发</code></li><li><code>同一个类型</code>的事件(比如click事件)只能绑定一次，<strong>后面绑定的会覆盖前面绑定的</strong>。</li></ul></li><li><p><strong>标准事件模型（DOM2级）</strong></p><p>标准事件模型就是现在我们最常使用的事件模型</p><p><strong>绑定方式：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.addEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p>参数如下：</p><ul><li><code>eventType</code>指定事件类型(不要加on)</li><li><code>handler</code>是事件处理函数</li><li><code>useCapture</code>是一个<code>boolean</code>用于指定是否在<code>捕获阶段</code>进行处理，默认值为<code>false</code>，与IE浏览器保持一致</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;p&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#x27;span&#x27;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onClickFn</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tagName = event.<span class="property">currentTarget</span>.<span class="property">tagName</span>;</span><br><span class="line">    <span class="keyword">var</span> phase = event.<span class="property">eventPhase</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tagName, phase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>);</span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击后输出</span></span><br><span class="line">P <span class="number">3</span></span><br><span class="line"><span class="variable constant_">DIV</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>几个常见事件属性</strong></p><ul><li><code>event.currentTarget</code> ，当前事件流所在的元素，是一个<code>dom</code>对象。</li><li><code>event.eventPhase</code>，代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段。</li><li><code>event.target</code>，代表目标元素，即触发事件的元素。</li><li><code>event.stopPropagation</code>，阻止事件冒泡。</li><li><code>event.stopImmediatePropagation()</code>，这个方法不仅做了<code>stopPropagation()</code>所做的所有事情——即阻止事件冒泡到父元素，而且还会<strong>完全停止同一个事件的所有后续处理</strong>。这意味着，在当前元素上为该事件类型注册的<strong>所有其它监听器，都不会被调用</strong>。</li></ul><p><strong>解绑方式</strong>：</p><p>传入的回调函数必须是<code>具名函数</code>，<strong>内容相同的两个匿名函数不会被认为相等</strong>，就和2个内容完全相同的对象也不相等的原理是一样的。</p><p>解绑事件监听器的作用是<strong>释放内存空间</strong>，否则事件监听器将会一直存在，持续引用对应的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.<span class="title function_">removeEventListener</span>(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p><strong>特性：</strong></p><ul><li><p>可以在一个<code>DOM</code>元素上对同一事件，绑定多个事件处理器，各自并不会冲突</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage1, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage2, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage3, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果在<code>目标元素</code>上绑定了多个对<code>同一事件</code>的监听，则<code>捕获触发</code>对应的事件回调会先于<code>冒泡触发</code>对应的事件回调被执行</p></li><li><p>如果是都是在<code>同一阶段触发</code>，比如都是冒泡触发，则按<strong>声明顺序</strong>执行回调函数。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第一个添加的监听&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)<span class="comment">//冒泡触发</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第二个添加的监听&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)<span class="comment">//冒泡触发</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第三个添加的监听&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)<span class="comment">//捕获触发</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第四个添加的监听&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)<span class="comment">//捕获触发</span></span><br></pre></td></tr></table></figure><p>点击box，控制台输出的顺序是：</p><p><code>&#39;我是第三个添加的监听&#39;</code></p><p><code>&#39;我是第四个添加的监听&#39;</code></p><p><code>&#39;我是第一个添加的监听&#39;</code></p><p><code>&#39;我是第二个添加的监听&#39;</code></p><p>如果在捕获监听的回调函数中添加，<code>event.stopPropagation</code>，则冒泡监听的回调函数不会触发；</p><p>如果在第一个捕获监听的回调函数中添加<code>event.stopImmediatePropagation()</code>，则后续的所有事件回调，包括其他捕获触发的事件回调都不会触发。</p><p>我们可以利用这一点来实现一个指令，给点击事件添加防抖，因为默认添加的事件监听都是冒泡触发，我们只需对同名事件再添加一个捕获触发的监听，然后控制<code>stopPropagation</code>的频率，就能实现节流或者防抖的效果。</p></li><li><p>IE事件模型（基本不用，现在再vscode中都无法使用）</p><p>IE事件模型只有2个过程，没有事件捕获阶段:</p><ul><li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</li><li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li></ul><p><strong>绑定方式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.attachEvent(eventType, handler)</span><br></pre></td></tr></table></figure><p><strong>解绑方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.<span class="title function_">detachEvent</span>(eventType, handler)</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">attachEvent</span>(‘onclick’, showMessage);</span><br><span class="line">btn.<span class="title function_">detachEvent</span>(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure></li></ul><h2 id="讲讲事件代理"><a href="#讲讲事件代理" class="headerlink" title="讲讲事件代理"></a>讲讲事件代理</h2><p>事件代理也叫<code>事件委托</code>，当我们要监听某个元素某个事件的时候，我们可以选择不给这个元素添加事件监听，而是给这个元素的<code>父元素或者祖先元素</code>添加对该事件的监听。然后在<code>事件冒泡</code>阶段触发该事件监听对应的回调函数。<strong>我们可以说，事件委托是基于事件冒泡的</strong></p><p>当你给DOM元素绑定事件处理器时，JavaScript引擎必须保留对该函数的引用，以便在事件触发时可以调用它。这意味着只要事件处理器存在，其对应的函数就不会被垃圾回收机制回收，从而一直占用着内存。</p><p>如果事件处理器使用了闭包（例如，在定义事件处理器的函数内部访问外部变量），那么这些外部变量也不能被垃圾回收，因为闭包会持有对外部作用域的引用。这进一步增加了内存占用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">textContent</span>);</span><br><span class="line">&#125;);<span class="comment">//比如这个事件监听器中的回调函数就会一直被引用</span></span><br></pre></td></tr></table></figure><p>事件代理的优点：</p><ul><li><p>不必为每个<code>目标元素</code>绑定事件监听，<strong>减少了页面所需内存</strong>。</p></li><li><p>自动绑定，解绑事件监听，减少了重复的工作。</p></li></ul><p>事件代理的局限性:</p><ul><li><p><code>focus</code>、<code>blur</code>这些事件<code>[输入框的事件]</code><strong>没有事件冒泡机制</strong>，所以无法进行委托绑定事件。</p></li><li><p><code>mousemove</code>、<code>mouseout</code>这样的事件，虽然有事件冒泡，但触发频率很高，而且只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的，我们最好在目标元素上添加mousemove的监听事件，因为我们不需要计算，直接通过<code>event.offsetX</code> 和 <code>event.offsetY</code>，就能获取鼠标指针相对于触发事件的元素（即事件目标）的内部坐标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="说说你对BOM的理解"><a href="#说说你对BOM的理解" class="headerlink" title="说说你对BOM的理解"></a>说说你对BOM的理解</h2><p><code>BOM</code> (Browser Object Model)，浏览器对象模型，提供了独立于内容，与浏览器窗口进行交互的对象</p><p>其作用就是跟<code>浏览器</code>做一些交互效果，比如如何进行页面的<code>后退</code>，<code>前进</code>，<code>刷新</code>，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率</p><img src="..\images\前端面试-js\bom.png" style="zoom:85%"> <img src="..\images\前端面试-js\BOM2.png" style="zoom:67%"><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><code>Bom</code>的核心对象是<code>window</code>，它表示浏览器的一个实例，<code>location</code>，<code>navigator</code>等后续介绍的对象都是<code>window</code>的属性。</p><p>在浏览器中，<code>window</code>对象有双重角色，即是浏览器窗口的一个接口，又是全局对象</p><p>因此所有在<code>全局作用域</code>中声明的<code>变量</code>、<code>函数</code>都会变成<code>window</code>对象的<code>属性</code>和<code>方法</code></p><ul><li><p><code>window.scrollTo(x,y)</code>：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">500</span>);<span class="comment">//将页面垂直滚动到距离页面顶部500像素的位置，而水平滚动条不会发生变化。</span></span><br></pre></td></tr></table></figure></li><li><p><code>window.scrollBy(x,y)</code>： 如果有滚动条，将<code>横向滚动条</code>向左移动x个像素，将<code>纵向滚动条</code>向下移动y个像素</p></li></ul><ul><li><p><code>window.open()</code> ：</p><p><code>window.open()</code>既可以导航到一个特定的<code>url</code>，也可以打开一个新的浏览器窗口。</p><p><code>window.open()</code> 会返回<code>新窗口的引用</code>，也就是新窗口的 <code>window</code> 对象，当使用 <code>window.open()</code> 方法打开新窗口时，如果返回值是 <code>null</code>，<strong>这通常意味着浏览器阻止了该弹窗的创建</strong>。现代浏览器为了防止恶意网站滥用弹窗，通常会限制<code>非用户交互</code>触发的弹窗。如果你在页面加载时或没有明确的用户动作（如点击事件）的情况下调用 <code>window.open()</code>，浏览器可能会认为这是未经请求的弹窗，并阻止它。</p><p>比如直接在script标签中书写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;sanye.blog&#x27;</span>)<span class="comment">//被浏览器阻止</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    myWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://www.vue3js.cn&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>)</span><br><span class="line">&#125;)<span class="comment">//可行</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newWindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(url, target, features[, replace]);</span><br></pre></td></tr></table></figure><p><strong>url</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 新窗口要加载的 <code>URL</code> 地址。如果省略或设置为 <code>null</code>，则会打开一个空白窗口。</li></ul><p><strong>target</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 指定新窗口的<code>目标位置</code>。它可以是以下预定义值之一：<ul><li><code>_self</code>: 在<code>当前框架</code>中加载页面（默认行为）。</li><li><code>_blank</code>: 在<code>新的窗口</code>或标签页中加载页面。</li><li><code>_parent</code>: 在父框架中加载页面。如果当前页面不在框架(iframe)内，则与 <code>_self</code> 的行为相同，在当前标签页中加载新页面。</li><li><code>_top</code>: 在整个窗口中加载页面，取消所有框架。</li><li>或者是一个由开发者定义的名称，用来标识<code>特定的窗口</code>或 <code>&lt;iframe&gt;</code>。</li></ul></li></ul><p><strong>features</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 一系列用<code>逗号分隔</code>的<code>字符串</code>，用于指定新窗口的各种<code>属性</code>和<code>行为</code>。每个特征可以带有或不带参数<ul><li><code>width=600</code>: 设置窗口宽度为 600 像素。</li><li><code>height=400</code>: 设置窗口高度为 400 像素</li></ul></li></ul><p><strong>replace</strong> (可选)</p><ul><li>类型: <code>Boolean</code></li><li>描述: 如果设置为 <code>true</code>，则新加载的页面将<code>替换历史记录中的当前条目</code>；如果为 <code>false</code> 或<code>未提供</code>，则会在历史记录中添加一个<code>新条目</code>。这对于防止用户多次点击<code>后退</code>按钮返回到同一个页面非常有用。</li></ul></li><li><p><code>window.close()</code> ：仅用于关闭通过 <code>window.open()</code> 打开的窗口</p><p>如果尝试关闭一个<code>不同域名</code>下的窗口，可能会遇到<code>跨域限制</code>。在这种情况下，<code>window.close()</code> 可能不会工作，因为浏览器的安全模型会阻止你操作不属于同一源的窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWin.<span class="title function_">close</span>()<span class="comment">//关闭myWin窗口，它是使用 `window.open()` 打开的新窗口</span></span><br></pre></td></tr></table></figure></li><li><p>新创建的 <code>window</code> 对象有一个 <code>opener</code> 属性，该属性指向打开他的<code>原始窗口对象</code></p></li></ul><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>是一个<code>对象</code>，包含了许多属性，一个<code>url</code>地址例子如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</span><br></pre></td></tr></table></figure><p><code>location</code>属性描述如下：</p><table><thead><tr><th>属性名</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td>“#contents”</td><td>url中，#后面的字符，没有则返回空串</td></tr><tr><td>host</td><td><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.wrox.com/">www.wrox.com:80</a></td><td>服务器名称和端口号</td></tr><tr><td>hostname</td><td><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.wrox.com/">www.wrox.com</a></td><td>域名，不带端口号</td></tr><tr><td>href</td><td><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.wrox.com/WileyCDA/?q=javascript#contents">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</a></td><td>完整url</td></tr><tr><td>pathname</td><td>“&#x2F;WileyCDA&#x2F;“</td><td>服务器下面的文件路径</td></tr><tr><td>port</td><td>80</td><td>url的端口号，没有则为空</td></tr><tr><td>protocol</td><td>http:</td><td>使用的协议</td></tr><tr><td>search</td><td>?q&#x3D;javascript</td><td>url的查询字符串，通常为？后面的内容</td></tr></tbody></table><ul><li>除了 <code>hash</code>之外，只要修改<code>location</code>的一个属性，就会导致页面重新加载新<code>URL</code>，因为hash值不会发送给服务器，所以修改哈希值后刷新也面也没意义。</li><li><code>location.reload()</code>，此方法可以重新刷新当前页面。这个方法会根据<code>最有效的方式</code>刷新页面，如果页面自上一次请求以来没有改变过，页面就会从<code>浏览器缓存</code>中重新加载，这一点和浏览器的<code>缓存策略</code>相关。如果要<code>强制</code>从服务器中重新加载，传递一个参数<code>true</code>即可。</li></ul><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history是window对象的一个属性，它本身也是个对象，提供了许多api，主要用来操作浏览器<code>URL</code>的历史记录，允许我们<strong>编程式</strong>控制页面被在历史记录之间跳转，也允许我们<strong>修改</strong>历史记录。</p><p>检查一个页面并在控制台输入history，即可查看当前页面的<code>state</code>，<code>scrollRestoraion</code>等信息。</p><img src="..\images\前端面试-js\a.png" style="zoom:80%"><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>history.back()</td><td>跳转到前一个页面，如果没有前一个页面，则不做响应，不会改变history.length</td></tr><tr><td>history.forward()</td><td>跳转到后一个页面，如果当前就最新页面，则不做响应，不会改变history.length</td></tr><tr><td>history.go()</td><td>传入数字，<code>正数</code>表示前进几个页面，<code>负数</code>表示后退几个页面，<code>0</code>表示刷新页面，不会改变history.length</td></tr><tr><td>history.length</td><td>获取当前窗口页面历史记录跳数，它是一个只读属性，无法直接修改。</td></tr><tr><td>history.pushState()</td><td>往<strong>历史记录栈顶</strong>添加一条记录，历史记录条数加1，但是<strong>不会跳转页面</strong>。在当前页面调用这个api，你能明显的看到<strong>url改变了</strong>，但是页面没有跳转。接收三个参数，历史记录对象（state），页面标题，URL路径。</td></tr><tr><td>history.replaceState()</td><td>不会增加历史记录数目，<strong>会修改当前历史记录</strong></td></tr><tr><td>history.state</td><td>访问<strong>当前页面</strong>的状态对象。</td></tr><tr><td>history.scrollRestoraion</td><td>如果值为<strong>auto</strong>，则在前进或者后退的时候，<strong>滚动条</strong>会回到原来的位置。如果值为<strong>manual（手动的）</strong>，则不会恢复。默认值是auto即后退到历史页面的时候，滚动条会回到原来的位置。可以通过在页面（html文件）内部的js代码中使用<code>history.scrollRestoraion</code>来修改这个页面滚动条的恢复方式。</td></tr></tbody></table><p>历史记录用一个栈来维护，每添加一历史记录的操作可以叫做push（入栈），当前页面就是历史记录栈顶的页面 ；假设当前历史记录栈的大小是3，当执行<code>history.back()</code>，弹出（pop）一条历史记录，页面也随之发生变化，因为栈顶元素改变了，但是这条历史记录并不会丢失，当我们执行<code>history.forward()</code>，它又会重新成为历史记录栈的栈顶元素。</p><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p><code>navigator</code> 对象主要用来获取<code>浏览器的属性</code>，区分浏览器类型。属性较多，且兼容性比较复杂。</p><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>保存的纯粹是<code>客户端能力</code>信息，也就是浏览器窗口外面的<code>客户端显示器</code>的信息，比如像素宽度和像素高度。</p><h2 id="DOM常见的操作有哪些"><a href="#DOM常见的操作有哪些" class="headerlink" title="DOM常见的操作有哪些"></a>DOM常见的操作有哪些</h2><h3 id="DOM是什么"><a href="#DOM是什么" class="headerlink" title="DOM是什么"></a>DOM是什么</h3><p><code>浏览器</code>根据<code>html</code>标签生成的<code>js对象</code>，所有的<code>标签属性</code>都可以在上面找到（所以说node中没有dom），修改这个对象属性会<code>自动映射</code>到标签上。关键词：浏览器，html标签，js对象，属性映射。</p><h3 id="DOM常见的操作"><a href="#DOM常见的操作" class="headerlink" title="DOM常见的操作"></a>DOM常见的操作</h3><ul><li>创建节点</li><li>获取结点</li><li>更新节点</li><li>添加节点</li><li>删除节点</li></ul><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p><strong>createElement</strong></p><p>创建<code>元素结点</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divEl = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>createTextNode</strong></p><p>创建文本结点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textEl = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;content&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>createAttribute</strong></p><p>创建属性节点，可以是自定义属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个元素结点</span></span><br><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建一个属性结点</span></span><br><span class="line"><span class="keyword">var</span> attr = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置属性结点的值</span></span><br><span class="line">attr.<span class="property">value</span> = <span class="string">&#x27;http://example.com&#x27;</span>;</span><br><span class="line"><span class="comment">// 将属性结点添加到元素结点</span></span><br><span class="line">elem.<span class="title function_">setAttributeNode</span>(attr);</span><br><span class="line"><span class="comment">// 添加一些文本到元素</span></span><br><span class="line">elem.<span class="property">textContent</span> = <span class="string">&#x27;链接&#x27;</span>;</span><br></pre></td></tr></table></figure><p>虽然可以直接使用<code>elem.href = &#39;http://example.com&#39;;</code>或<code>elem.setAttribute(&#39;href&#39;, &#39;http://example.com&#39;);</code>来达到相同的效果，但是了解<code>如何创建和操作属性结点</code>可以帮助更好地理解DOM的操作机制。</p><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><p>可以通过<code>捕获</code>的方式获取dom结点，也可以通过一个<code>dom结点的属性</code>来获取另一个dom结点</p><p><strong>querySelector</strong></p><p>传入任何有效的<code>css</code> 选择器，即获得<code>首个</code>符合条件的Dom元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.element&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#element&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=username]&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div + p &gt; span&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果页面上没有指定的元素时，返回 <code>null</code></p><p><strong>querySelectorAll</strong></p><p>传入任何有效的<code>css</code> 选择器，返回一个<code>伪数组</code>，包含全部符合匹配条件的DOM元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> notLive = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>其他方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id属性值&#x27;</span>);返回拥有指定id的对象的引用</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;class属性值&#x27;</span>);返回拥有指定<span class="keyword">class</span>的对象集合</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;标签名&#x27;</span>);返回拥有指定标签名的对象集合</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;name属性值&#x27;</span>); 返回拥有指定名称的对象结合</span><br><span class="line"><span class="variable language_">document</span>/element.<span class="title function_">querySelector</span>(<span class="string">&#x27;CSS选择器&#x27;</span>);  仅返回第一个匹配的元素</span><br><span class="line"><span class="variable language_">document</span>/element.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;CSS选择器&#x27;</span>);   返回所有匹配的元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>;  获取页面中的<span class="variable constant_">HTML</span>标签</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>; 获取页面中的<span class="variable constant_">BODY</span>标签</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">all</span>; 获取页面中的所有元素节点的对象集合型,不是标准<span class="variable constant_">DOM</span>的一部分，它的行为可能在不同的浏览器中表现不同</span><br></pre></td></tr></table></figure><p>我们仅通过观察是<code>...Element...</code>还是，<code>...Elements...</code>就能判断出返回的结果是集合还是单独的元素</p><p>除此之外，每个<code>DOM</code>元素还有<code>parentNode</code>、<code>childNodes</code>、<code>firstChild</code>、<code>lastChild</code>、<code>nextSibling</code>、<code>previousSibling</code>属性，关系图如下图所示。</p><img src="..\images\前端面试-js\dom.png" style="zoom:80%"><p><strong>parentNode和parentElement</strong></p><p><code>parentNode</code> 返回指定节点的父节点，这个父节点可以是<strong>任何类型的节点</strong>，包括文档类型节点、元素节点、文本节点等。但是，在实际应用中，除了元素节点外，其他类型的节点很少作为父节点存在。</p><p><code>parentElement</code> 仅返回<strong>指定节点的父元素节点（即类型为<code>HTMLElement</code>的节点）</strong>。如果指定节点的父节点<strong>不是一个元素节点</strong>（例如，它可能是一个文本节点），则 <code>parentElement</code> 返回 <code>null</code>，即<code>先捕获再判断类型</code>。</p><p>简单的来说，就是一个对父节点的类型有要求，一个没有。</p><p><strong>childNodes和children</strong></p><p><code>childNodes</code> 返回一个实时的<code>NodeList</code>对象，包含了指定节点的所有<strong>直接子节点</strong>(一级子节点)，包括<strong>元素节点、文本节点、注释节点</strong>等所有类型的节点。</p><p><code>children</code> 返回一个实时的 <code>HTMLCollection</code> 对象，只包含指定节点的<strong>直接子元素节点</strong>（一级元素结点，即标签）。<strong>不包括文本节点、注释节点等其他类型的节点。</strong></p><p><strong>previousElementSibling和previousSibling</strong></p><p>前者用来获取<strong>上一个元素节点（即 HTML 标签）</strong>，后者用来获取上一个任意类型的结点</p><p><strong>获取页面上的所有结点</strong></p><p>一个简单的方法是从文档的根节点（<code>document</code> 或 <code>document.documentElement</code>，后者指的是 <code>&lt;html&gt;</code> 元素）开始，然后递归地访问每个节点的 <code>childNodes</code>。</p><p><strong>获取页面上的所有元素结点</strong></p><ul><li><p>使用 <code>document.getElementsByTagName(&#39;*&#39;)</code>：这将返回一个包含文档中所有元素的实时 <code>HTMLCollection</code></p></li><li><p>使用 <code>document.querySelectorAll()</code>：通过传递 <code>&#39;*&#39;</code> 选择器，你可以获得一个静态的 <code>NodeList</code>，它包含了文档中的所有元素结点。</p></li></ul><h4 id="更新结点"><a href="#更新结点" class="headerlink" title="更新结点"></a>更新结点</h4><p><strong>innerHTML</strong></p><p>不但可以修改一个<code>DOM</code>节点的<code>文本内容</code>，如果传入的是html片段，还会被解析成dom结点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p&quot;&gt;...&lt;/p &gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p&quot;&gt;ABC&lt;/p &gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>innerText、textContent</strong></p><p>自动对字符串进行<code>HTML</code>编码，就是把小于号转化成<code>&amp;lt;</code>大于号转化成<code>&amp;gt;</code>保证无法设置任何<code>HTML</code>标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.<span class="property">innerText</span> = <span class="string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p &gt;</span></span><br></pre></td></tr></table></figure><p>两者的区别在于读取属性时，<code>innerText</code>不返回<code>隐藏元素</code>的文本(即 <code>display: none</code> 或者 <code>visibility: hidden</code>)，而<code>textContent</code>返回所有文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;可见文本&lt;/p&gt;</span><br><span class="line">  &lt;p style=&quot;display: none;&quot;&gt;隐藏文本&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const element = document.getElementById(&#x27;example&#x27;);</span><br><span class="line">  console.log(element.innerText);     // 输出: &quot;可见文本&quot;</span><br><span class="line">  console.log(element.textContent);  // 输出: &quot;可见文本\n隐藏文本&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="添加结点"><a href="#添加结点" class="headerlink" title="添加结点"></a>添加结点</h4><p><strong>appendChild</strong></p><p>把一个节点添加到父节点的最后一个子节点之后，<strong>如果这个添加的结点已经在页面中存在，那么这个结点会先从原位置删除</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript&lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme&lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加一个<code>p</code>元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> js = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">js.<span class="property">innerHTML</span> = <span class="string">&quot;JavaScript&quot;</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.<span class="title function_">appendChild</span>(js);</span><br></pre></td></tr></table></figure><p>在<code>HTML</code>结构变成了下面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript&lt;/p &gt;  <span class="comment">&lt;!-- 添加元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>insertBefore</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentElement.<span class="title function_">insertBefore</span>(newElement, referenceElement)</span><br></pre></td></tr></table></figure><p>子节点会插入到<code>referenceElement</code>之前</p><ul><li><code>parentElement</code>: 这是要操作的目标元素，新的子节点将被添加到这个元素的<code>子节点列表</code>中。</li><li><code>newElement</code>: 这是你想要插入的<code>新元素节点</code>。</li><li><code>referenceElement</code>: 这是在新元素插入之前所依据的<code>参考元素</code>。新元素会被放置在这个<code>参考元素</code>之前。如果这个参数为 <code>null</code>，则新元素会被插入到父元素的最后，就像使用 <code>appendChild()</code> 一样。</li></ul><p><strong>setAttribute</strong></p><p>在指定元素中<code>添加一个属性</code>节点，如果元素中已有该属性改变属性值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;white&#x27;</span>);<span class="comment">//第一个参数属性名，第二个参数属性值。</span></span><br></pre></td></tr></table></figure><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p><strong>removeChild</strong></p><p>删除一个节点，首先要获得<code>该节点本身</code>以及它的<code>父节点</code>，然后，调用父节点的<code>removeChild</code>，把自己删掉，也就是说，一个结点是不能删除自身的，而是需要借助父节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">const</span> parent = self.<span class="property">parentNode</span>;</span><br><span class="line"><span class="comment">// 删除并返回被删除的dom元素</span></span><br><span class="line"><span class="keyword">const</span> removed = parent.<span class="title function_">removeChild</span>(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>删除后的节点虽然不在<code>文档树</code>中了，但其实它还在<code>内存中</code>，可以随时再次被添加到别的位置。</p><h3 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h3><ul><li><code>nodeType</code> 是一个只读属性，用于标识 DOM 节点的类型。</li><li>常见的nodeType值包括：<ul><li><code>1</code>：元素节点（<code>Element</code>），因为元素结点是最常见的结点，所以nodeType的值是1</li><li><code>3</code>：文本节点（<code>Text</code>）</li><li><code>8</code>：注释节点（<code>Comment</code>）</li><li><code>9</code>：文档节点（<code>Document</code>）</li></ul></li></ul><h2 id="如何实现触底加载，下拉刷新？"><a href="#如何实现触底加载，下拉刷新？" class="headerlink" title="如何实现触底加载，下拉刷新？"></a>如何实现触底加载，下拉刷新？</h2><h3 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h3><p>要明白如何实现功能，我们首先要搞清楚dom元素的一些<strong>定位属性</strong></p><h4 id="clientWidth和scrollWidth"><a href="#clientWidth和scrollWidth" class="headerlink" title="clientWidth和scrollWidth"></a>clientWidth和scrollWidth</h4><ul><li><p>client</p><p><code>clientWidth/clientHeight</code>：可视区域的宽&#x2F;高+内边距，不包含<code>border</code></p></li><li><p>scroll</p><p><code>scrollWidth/scrollHeight</code>：</p><ul><li>有滚动条元素的元素整体的宽高。</li><li>一个没有滚动条的元素，它的<code>scrollWidth/scrollHeight</code>属性的值等于它的<code>clientWidth/clientHeight</code>属性的值。</li></ul></li></ul><p>举个例子，我们在一个高度为<code>600px</code>的盒子<code>box</code>里放两个背景颜色不同，高度都是<code>400px</code>的盒子<code>box1</code>,<code>box2</code>，并给<code>box</code>添加css属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>:auto </span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">补充一下overflow属性的值</span><br><span class="line">visible（默认值）:内容不会被裁剪，而是会呈现在元素框之外。</span><br><span class="line">hidden:内容会被裁剪，并且超出的部分不会显示。浏览器不会为溢出内容提供任何滚动机制。</span><br><span class="line">scroll:即使内容并未溢出,也提供滚动条</span><br><span class="line">auto:如果内容溢出了元素框，则浏览器会根据需要提供滚动条。如果内容没有溢出，则不显示滚动条</span><br><span class="line"></span><br><span class="line">单个方向上的溢出控制</span><br><span class="line">overflow-x：控制水平方向上的溢出。</span><br><span class="line">overflow-y: 控制垂直方向上的溢出。</span><br></pre></td></tr></table></figure><p>这样<code>box</code>盒子就出现了滚条，可以实现内容的滚动，内部盒子也不会影响外部盒子的布局（开启了<code>BFC</code>，可以观察添加该条属性前后，body高度的变化，从800px变为600px）。然后我们访问box盒子（有滚动条的盒子）的<code>clientHeight</code>属性和<code>scrollHeight</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="property">clientHeight</span> <span class="comment">//600px</span></span><br><span class="line">box.<span class="property">scrollHeight</span> <span class="comment">//800px</span></span><br></pre></td></tr></table></figure><p>这样是不是就很容易理解client和scroll之间的区别呢。对于没有滚动条的元素，<code>clientWidth/clientHeight</code>与<code>scrollWidth/scrollHeight</code>的值是一一相等的。</p><p>当我们不断地给<code>body</code>添加元素，<code>body</code>的高度总有超过浏览器窗口高度的时候，此时<code>body</code>标签的父元素，<code>html</code>标签会自动开启滚动条，<code>html.clientHeight</code>就是<strong>浏览器窗口</strong>的高度。</p><h4 id="scrollLeft和scrollTop"><a href="#scrollLeft和scrollTop" class="headerlink" title="scrollLeft和scrollTop"></a>scrollLeft和scrollTop</h4><p>scroll开头的属性中，还有两个重要的属性。</p><ul><li><code>scrollLeft/scrollTop</code>表示<strong>具有滚动条的元素</strong>，顶部滚动出<code>可视区域</code>的高度，或者左部滚动出<code>可视区域</code>的宽度</li><li>对于不具有滚动条的元素，这两个属性的值都是<code>0</code>。</li><li>这两个属性是<strong>可读写</strong>的，将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，<strong>可以重置元素的滚动位置</strong>，通常用来实现一键到底，或者返回顶部。</li></ul><p>常见的属性中除了以client，scroll开头的属性，还有以<code>offset</code>开头的属性</p><h4 id="offsetWidth和clientWidth"><a href="#offsetWidth和clientWidth" class="headerlink" title="offsetWidth和clientWidth"></a>offsetWidth和clientWidth</h4><ul><li>可视区域的宽&#x2F;高+内边距+border+滚动条，这两个属性通常被拿来与<code>clientWidth/clientHeight</code>属性比较。</li><li>这2类属性的范畴都包含<strong>可视区域的宽高和padding</strong>，都不包含margin。明明和padding一样都是边距，为什么就这么不受待见呢</li><li>区别在于前者还包含border，后者不包含，范围更小。</li></ul><h4 id="offsetLeft和offsetTop"><a href="#offsetLeft和offsetTop" class="headerlink" title="offsetLeft和offsetTop"></a>offsetLeft和offsetTop</h4><ul><li>元素左部&#x2F;顶部距离<strong>最近的定位元素</strong>的距离，相对的<strong>不是视口</strong>，通常是固定的，不会随滚动条改变而改变。</li><li>offsetLeft&#x2F;offsetTop这2个属性是<strong>只读</strong>的，不能手动修改</li><li>要注意的是，没有<code>offsetRight</code>和<code>offsetBottom</code>属性。</li></ul><img src="..\images\前端面试-js\offset.png" style="zoom:80%"><h4 id="offsetX和offsetY"><a href="#offsetX和offsetY" class="headerlink" title="offsetX和offsetY"></a>offsetX和offsetY</h4><ul><li><code>offsetX</code> 和 <code>offsetY</code> 是与<strong>鼠标事件</strong>相关的属性，通常在处理用户交互时使用，注意要和<code>offsetLeft/offsetTop</code>区分开来。</li><li>这两个属性提供了鼠标指针相对于触发事件的元素（即事件<strong>目标元素</strong>，可以通过<code>event.target</code>获得）的 X 和 Y 坐标。它们是 MouseEvent 对象的一部分</li><li>我曾经尝试使用这2个属性来做放大镜的效果，发现一直实现不了，后来发现了问题所在，触发鼠标事件的目标元素始终是蒙层，而不是商品图片，可以通过给蒙层添加<code>point-events:none</code>忽略鼠标事件来解决问题。</li></ul><h3 id="如何实现触底加载"><a href="#如何实现触底加载" class="headerlink" title="如何实现触底加载"></a>如何实现触底加载</h3><p><strong>方法1</strong></p><p>如果<code>html</code>元素<strong>顶部滚出可视区域的高度</strong>+html元素的<strong>可视区域高度</strong>，大于html标签的<strong>整体高度</strong>，则判定为触底，其实这个时候就是页面已经滑到底部了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (html.<span class="property">scrollTop</span> + html.<span class="property">clientHeight</span> &gt;= html.<span class="property">scrollHeight</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触底&#x27;</span>)</span><br><span class="line">&#125;<span class="comment">//这里的html标签可以被替换为所有具有滚动条的元素</span></span><br></pre></td></tr></table></figure><p>优点：实现起来非常简单。</p><p>缺点：只能判断最后一个元素是否触底，不能判断<strong>非底部元素</strong>是否触底（如果body很长，那么非底部元素也是有触底事件的）</p><p><strong>方法2</strong></p><p>使用<code>IntersectionObserver API</code>，创建<code>observer</code>对象 ，需要传递2个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">entries, observer</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//每观察一个元素，entries的大小就会+1</span></span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素进入视口&#x27;</span>);</span><br><span class="line">      <span class="comment">//entry.target：表示被观察的元素。</span></span><br><span class="line">      observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>); <span class="comment">// 一旦进入视口，停止观察</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个参数指明元素完全出现在视口再触发回调函数，符合触底的思想</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(func,&#123;<span class="attr">threshold</span>:<span class="number">1</span>&#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(target) <span class="comment">//观察某个元素</span></span><br></pre></td></tr></table></figure><p>关于<code>IntersectionObserver</code>更详细的介绍参考下文。</p><p>优点：不仅能精确控制某个元素是否触底，令<code>threshold</code>的值为0，还能实现<strong>图片懒加载</strong>的效果，即图片一出现在视口，就发送请求获取图片。</p><p>缺点：需要调用api实现起来麻烦。</p><h3 id="如何实现下拉刷新"><a href="#如何实现下拉刷新" class="headerlink" title="如何实现下拉刷新"></a>如何实现下拉刷新</h3><ul><li>监听<code>window</code>的<code>touchstart</code>，<code>touchmove</code>，<code>touchend</code>，要注意的是不是<code>mousestart</code>，<code>mousemove</code>，<code>mouseend</code>事件，因为”下拉”是只在移动端才有的动作，所以没有鼠标，所以事件也不以<code>mouse</code>开头，而是以<code>touch</code>开头</li><li>通过<code>e.touches[0].clientY</code>获得触碰位置距离视口顶部的距离。<ul><li><code>e.touches</code>是一个 <code>TouchList</code> 对象，包含了所有当前活跃的触点（即手指接触屏幕且尚未抬起的所有触点），当用户用手指触碰设备屏幕时（比如手机或平板），会产生一个或多个触摸点。每个触摸点都由一个 <code>Touch</code> 对象表示，该对象包含了诸如位置、状态等信息。所有这些触点被包含在一个 <code>TouchList</code> 对象中。</li><li><code>e.touches[0]</code>：这表示获取 <code>TouchList</code> 列表中的第一个触点。因为 <code>TouchList</code> 是一个<code>类数组对象</code>，所以你可以通过索引来访问其中的元素。索引从 0 开始，因此 <code>e.touches[0]</code> 就是列表中的第一个触点。</li><li><code>clientY</code>：这是 <code>Touch</code> 对象的一个属性，表示触点相对于可见视口（viewport）的 Y 轴坐标。换句话说，它给出了手指在屏幕上的垂直位置，不包括任何滚动条导致的偏移。</li></ul></li><li><code>touchend</code>事件触发后，计算移动的距离，判断是否需要刷新数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> load = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> tip = <span class="literal">false</span></span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数只会执行一次</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//存储第一次触摸屏幕距离视口顶部的距离</span></span><br><span class="line">  start = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数会被执行多次，总不能一直提示正在进行下拉操作吧</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//记录下拉的距离</span></span><br><span class="line">  distance = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span> - start</span><br><span class="line">  <span class="comment">//如果下拉的距离大于0且未提示过正在下拉刷新，则提示</span></span><br><span class="line">  <span class="keyword">if</span> (distance &gt; <span class="number">0</span> &amp;&amp; !tip) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在进行下拉刷新操作&#x27;</span>)</span><br><span class="line">    <span class="comment">//本次下拉操作不再提示正在下拉刷新</span></span><br><span class="line">    tip = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果下拉距离到了设置的高度，继续下拉总不能一直提示松手释放吧</span></span><br><span class="line">  <span class="comment">//如果下拉的距离超过设定的距离且未提示过松手释放，则提示松手释放</span></span><br><span class="line">  <span class="keyword">if</span> (distance &gt; <span class="number">50</span> &amp;&amp; !load) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;松手释放&#x27;</span>)</span><br><span class="line">    <span class="comment">//本次下拉操作不再提示松手释放</span></span><br><span class="line">    load = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数只会执行一次</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//如果下拉的距离超过了指定距离，则松手后开始更新</span></span><br><span class="line">  <span class="keyword">if</span> (load) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在进行更新操作&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//一次下拉操作结束后，把这两个变量重新初始化，为下一次下拉刷新准备</span></span><br><span class="line">  load = <span class="literal">false</span></span><br><span class="line">  tip = <span class="literal">false</span></span><br><span class="line">  start = <span class="number">0</span></span><br><span class="line">  distance = <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="如何判断一个元素是否在可视区域中？"><a href="#如何判断一个元素是否在可视区域中？" class="headerlink" title="如何判断一个元素是否在可视区域中？"></a>如何判断一个元素是否在可视区域中？</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在日常开发中，我们经常需要判断目标元素是否在视窗之内，或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p><ul><li>图片的懒加载</li><li><strong>列表的无限滚动</strong></li><li>计算广告元素的曝光情况</li><li>可点击链接的预加载</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="借助dom的布局属性"><a href="#借助dom的布局属性" class="headerlink" title="借助dom的布局属性"></a><strong>借助dom的布局属性</strong></h4><p>当一个元素的<code>html</code>标签的<code>scrollTop</code>属性，加上<code>视口的高度</code>，大于等于一个元素的<code>offsetTop</code>属性，那么这个元素就出现在视口中。如何获取视口的高度呢？有三种方式：</p><ul><li><code>window.innerHeight</code></li><li><code>html.clientHeight</code>：<code>html标签</code>的高度就可以认为是<strong>视口的高度</strong>(<code>document.documentElement=html</code>)</li><li><code>document.body.clientHeight</code> ：<code>body</code>标签的高度通常等于<code>html标签</code>的<code>高度</code>，所以也可以被认为是视口的高度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">offsetTop</span> - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> &lt;= viewPortHeight</span><br></pre></td></tr></table></figure><p><strong>然而这么做有一个前提，那就是el的最近的定位元素是<code>html</code>标签。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPortOfOne</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// viewPortHeight 兼容所有浏览器写法</span></span><br><span class="line">    <span class="keyword">const</span> viewPortHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span> </span><br><span class="line">    <span class="keyword">const</span> offsetTop = el.<span class="property">offsetTop</span><span class="comment">//元素距离html标签顶部的距离，前提html确实是最近的定位元素</span></span><br><span class="line">    <span class="keyword">const</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line">    <span class="keyword">const</span> scrollTop = html.<span class="property">scrollTop</span></span><br><span class="line">    <span class="keyword">return</span> offsetTop - scrollTop &lt;= viewPortHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h4><p><code>Intersection(交叉，交集) Observer</code> 即，重叠观察者，从这个命名就可以看出它用于<code>判断两个元素是否重叠</code>，因为不用进行<code>scroll</code>事件的监听，性能方面相比<code>getBoundingClientRect</code>会好很多。</p><p>使用步骤主要分为两步：<code>创建观察者</code>和<code>传入被观察者</code></p><p><strong>创建观察者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="comment">// 表示 被观察元素 和 根元素 “重叠面积”，占被观察者的比例，从 0 - 1 取值，</span></span><br><span class="line">  <span class="comment">// 1 表示被观察者完全出现在根元素</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>, </span><br><span class="line">  <span class="attr">root</span>:<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>) <span class="comment">// 必须是目标元素的父级元素，如果省略，默认是浏览器视口</span></span><br><span class="line">  <span class="attr">rootMargin</span>: <span class="string">&#x27;0px 0px 100px 0px&#x27;</span>, <span class="comment">// 给根元素添加margin，提前 100px 触发</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entries, observer</span>) =&gt; &#123; ....&#125;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br></pre></td></tr></table></figure><p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的回调函数 <code>callback</code> <strong>，在重叠比例超过 <code>threshold</code> 时会被执行</strong>，所以我们在实现<code>图片懒加载</code>的时候令这个值为0，当图片刚刚出现在视口的时候，就是<code>重叠比例</code><strong>超过0</strong>的时候，就是回到函数被执行的时候。<code>rootMargin</code> 就像 CSS 的 <code>margin</code>，但它作用在 <strong>根元素（root）的边缘</strong>，用来<strong>扩展或收缩根元素的检测区域</strong>。</p><p>关于<code>callback</code>回调函数常用属性如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上段代码中被省略的 callback</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="keyword">function</span>(<span class="params">entries, observer</span>) &#123; </span><br><span class="line">    <span class="comment">//entries是一个数组，包含了所有被观察的对象</span></span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        entry.<span class="property">isIntersecting</span>      <span class="comment">// 布尔值，表示两元素是否重叠</span></span><br><span class="line">        entry.<span class="property">time</span>;               <span class="comment">// 触发的时间</span></span><br><span class="line">        entry.<span class="property">intersectionRatio</span>;  <span class="comment">// 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）</span></span><br><span class="line">        entry.<span class="property">target</span>;             <span class="comment">// 被观察者</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>传入被观察者</strong></p><p>通过 <code>observer.observe(target)</code> 这一行代码，即可<strong>简单的注册被观察者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);#被观察者是dom元素</span><br></pre></td></tr></table></figure><h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p>调用dom元素的<code>getBoundingClientRect</code>方法，返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性，<strong>所有布局属性（除了宽高）都是相对<code>视口</code>的。</strong></p><ul><li><code>x</code>: 元素左边缘相对于<code>视口左边界</code>的距离，通常情况下等于left</li><li><code>y</code>: 元素上边缘相对于<code>视口顶部</code>的距离，通常情况下等于top</li><li><code>top</code>: 元素上边缘相对于<code>视口顶部</code>的距离。</li><li><code>bottom</code>: 元素下边缘相对于<code>视口顶部</code>的距离。</li><li><code>left</code>: 元素左边缘相对于<code>视口左边界</code>的距离。</li><li><code>right</code>: 元素右边缘相对于<code>视口左边界</code>的距离。</li><li><code>width</code>: 元素的宽度，包括填充和边框，但不包括外边距，等于<code>offsetWidth</code></li><li><code>height</code>: 元素的高度，包括填充和边框，但不包括外边距，等于<code>offsetHeight</code></li></ul><p>如果一个元素<strong>全部在视窗之内</strong>的话，那么它一定满足下面四个条件：</p><ul><li>top 大于等于 0</li><li>left 大于等于 0</li><li><strong>bottom 小于等于视窗高度，就是元素底部距离视口顶部的距离，小于等于视口高度，这个是最常用的判断条件</strong></li><li>right 小于等于视窗宽度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个布尔值，判断元素是否在视口中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPort</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> viewWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    top,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    left,</span><br><span class="line">  &#125; = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    top &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    left &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    right &lt;= viewWidth &amp;&amp;</span><br><span class="line">    bottom &lt;= viewHeight</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获得元素的即时位置，<strong>每次页面滚动</strong>都要重新调用这个方法，来获得最新的位置信息。</p><h2 id="实现图片的懒加载"><a href="#实现图片的懒加载" class="headerlink" title="实现图片的懒加载"></a>实现图片的懒加载</h2><h3 id="IntersectionObserver-1"><a href="#IntersectionObserver-1" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><p>下面使用<code>IntersectionObserver</code>实现了一个图片懒加载指令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为自定义指令只会被导入一次，所以observer对象只会被创建一次</span></span><br><span class="line"><span class="comment">//写在外面的好处就是不用每次使用指令都创建一个observer，减少了内存占用</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">  <span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">           entry.<span class="property">target</span>.<span class="property">src</span> = entry.<span class="property">target</span>[val]<span class="comment">//不能通过entry.target.val的方式访问，val 是一个 Symbol 类型的键</span></span><br><span class="line">          <span class="comment">//图片出现在视口，就移除对图片的监听</span></span><br><span class="line">          <span class="comment">//传入的还是dom对象，对应添加监听的时候传入的是dom对象</span></span><br><span class="line">          observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">threshold</span>: <span class="number">0</span> &#125;<span class="comment">//第二个参数传入一个配置对象</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">let</span> val = <span class="title class_">Symbol</span>(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"><span class="comment">//导出一个对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> lazyLoad = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="comment">//记住img元素的src属性</span></span><br><span class="line">    el[val] = binding.<span class="property">value</span></span><br><span class="line">    observer.<span class="title function_">observe</span>(el)<span class="comment">//传入绑定的dom对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来就出现在视口中的图片，因为<code>threshold</code>一开始就超过了0，所以回调函数会被正常执行。</p><h3 id="getBoundingClientRect-1"><a href="#getBoundingClientRect-1" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h3><p>使用<code>getBoundingClientRect</code>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> lazy = &#123;</span><br><span class="line">    <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      	 <span class="keyword">if</span> (</span><br><span class="line">         <span class="comment">//每次滚动都要重新调用这个方法，获取元素即时的位置</span></span><br><span class="line">         el.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> &lt;=</span><br><span class="line">         <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">      	 ) &#123;</span><br><span class="line">        	el.<span class="property">src</span> = binding.<span class="property">value</span></span><br><span class="line">      	 &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样存在缺点：</p><ul><li>必须滚动后才能触发，对于本来就在显示在视口的图片，不滚动就不会展示，</li><li>每给一张图片添加懒加载，就会给window注册一个scroll事件的监听，造成了不必要的内存占用</li></ul><p>下面给出修改后的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = []</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  handler.<span class="title function_">forEach</span>(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">//希望图片顶部，距离出现在视口还有80px的时候，就加载图片，优化了用户体验，这一点是使用IntersectionObserver做不到的。</span></span><br><span class="line">      obj.<span class="property">el</span>.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> &lt;=</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> + <span class="number">80</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      obj.<span class="property">el</span>.<span class="property">src</span> = obj.<span class="property">val</span></span><br><span class="line">      handler.<span class="title function_">splice</span>(index, <span class="number">1</span>)<span class="comment">//这个图片加载后，就不再关心它在文档中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> lazyLoad = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="comment">//如果图片元素一开始就出现在视口</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      el.<span class="title function_">getBoundingClientRect</span>().<span class="property">bottom</span> &lt;= <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">//直接加载图片</span></span><br><span class="line">      el.<span class="property">src</span> = binding.<span class="property">value</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//否则将它纳入监听的数组</span></span><br><span class="line">      handler.<span class="title function_">push</span>(&#123; el, <span class="attr">val</span>: binding.<span class="property">value</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//图片所在的组件卸载，就删除handler中对应的img元素。</span></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    handler.<span class="title function_">splice</span>(<span class="number">0</span>, handler.<span class="property">length</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还有进一步优化的空间</p><ul><li>指令解绑后，卸载事件监听；</li><li>每次滚动，都要遍历所有添加了懒加载的img对象，调用它们的<code>getBoundingClientRect</code>方法，这比较消耗性能的，也是使用<code>getBoundingClientRect</code>方法不可避免的问题 。</li></ul><h2 id="实现列表的无限滚动"><a href="#实现列表的无限滚动" class="headerlink" title="实现列表的无限滚动"></a>实现列表的无限滚动</h2><h3 id="getBoundingClientRect-2"><a href="#getBoundingClientRect-2" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h3><p>使用<code>getBoundingClientRect</code>来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = []</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  handler.<span class="title function_">forEach</span>(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">//这里给一个80是希望元素底部距离出现在视口还有 80px 的时候就获取新的数据，用户体验更好</span></span><br><span class="line">      obj.<span class="property">el</span>.<span class="title function_">getBoundingClientRect</span>().<span class="property">bottom</span> &lt;=</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>+<span class="number">80</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      obj.<span class="title function_">func</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> infinite = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    handler.<span class="title function_">push</span>(&#123; el, <span class="attr">func</span>: binding.<span class="property">value</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>obj.el.getBoundingClientRect().bottom</code>，获取的是一个dom元素<code>底部</code>距离<code>视口顶部</code>的距离</li><li><code>document.documentElement.clientHeight+80</code>，其中<code>document.documentElement</code>就代表html元素，而<code>html.clientHeight</code>代表的就是<strong>视口的高度</strong></li><li>其中<code>binding.value</code>就是元素触底后执行的函数。</li></ul><p>infinite指令的实现思路就是：</p><ul><li>使用了<code>v-infinite</code>指令的dom元素，都会连同对应的回调函数(<code>binding.value</code>)，被push到<code>handler</code>数组中。</li><li>当页面滚动的时候，遍历所有使用了<code>v-infinite</code>指令的dom元素，调用它们的<code>getBoundingClientRect</code>方法，判断它们的底部是否将要出现在视口，如果满足条件，则调用对应的回调函数</li></ul><h3 id="IntersectionObserver-2"><a href="#IntersectionObserver-2" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><p>尝试使用<code>IntersectionObserver</code>来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">  <span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">        entry.<span class="property">target</span>.<span class="title function_">val</span>()</span><br><span class="line">        <span class="comment">// observer.unobserve(entry.target)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">threshold</span>: <span class="number">1</span> &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">let</span> val = <span class="title class_">Symbol</span>(<span class="string">&#x27;func&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> infinite = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    el[val] = binding.<span class="property">value</span></span><br><span class="line">    observer.<span class="title function_">observe</span>(el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这种方法应用到我实际开发的项目中，想要实现列表无限滚动的时候，缺发现不起效果，仔细思考后发现：</p><ul><li><p>初始商品图片未加载的时候，列表高度为0，列表完全处于视口中，此时回调函数就已经被触发，观察已被解除（unobserve）</p></li><li><p>初始图片加载完毕的时候，列表的高度就大于视口高度了(列表太长了)，所以列表和视口的重合面积，和列表的面积的比例，永远会小于1，所以传入的回调函数永远不会被触发。</p></li><li><p>即便把threshold设置为小于1的值，也会因为列表越来越长，导致后来重合面积的比例越来越小，后续滚动也不会加载新的数据。</p></li><li><p>所以说IntersectionObserver不适合用来做列表的无限滚动</p></li></ul><h2 id="new操作符到底做了什么"><a href="#new操作符到底做了什么" class="headerlink" title="new操作符到底做了什么"></a>new操作符到底做了什么</h2><ul><li>创建一个新的对象</li><li>让这个对象的<code>[[prototype]]</code>属性等于构造函数的<code>prototype</code>，即让新创建的对象的原型等于构造函数的原型对象。</li><li>调用这个对象的<code>constructor</code>方法</li></ul><p>如果构造函数的<code>返回值</code>是<strong>基本类型</strong>，那么这个返回值不起任何效果，但是如果构造函数的返回值是<strong>引用类型</strong>，new操作返回的对象就是构造函数返回的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line"> 	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Parent</span>()) <span class="comment">//Parent &#123;name: &#x27;parent&#x27;, play: Array(3)&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line"> 	this.name = &#x27;parent&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">    return [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Parent()) //输出[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>手写<code>new</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">constructor, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">//方法1</span></span><br><span class="line">  <span class="comment">// const obj = Object.create(constructor.prototype)</span></span><br><span class="line">  <span class="comment">//方法2</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">//新对象原型指向构造函数原型对象</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">//让这个对象调用constructor方法，并传入参数</span></span><br><span class="line">  <span class="keyword">const</span> res = obj.<span class="title function_">constructor</span>(<span class="params">...args</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> res == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myNew</span>(<span class="title class_">Parent</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">30</span>)) <span class="comment">//Parent &#123;name: &#x27;tom&#x27;, age: 30&#125;</span></span><br></pre></td></tr></table></figure><h2 id="在js中如何实现继承"><a href="#在js中如何实现继承" class="headerlink" title="在js中如何实现继承"></a>在js中如何实现继承</h2><p>继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码</p><p>在子类别继承父类别的同时，可以<code>重新定义</code>某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。</p><p>如果大家学过<code>java</code>，想必对继承的概念都非常熟悉了。</p><p>那在js这门语言中是如何实现继承呢?</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>让父类的一个<code>实例</code>作为子类的<code>原型对象</code>，这样子类的原型对象的原型确实是父类的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br></pre></td></tr></table></figure><p>这样就满足<code>Child.prototype._proto_ = Parent.prototype</code>，在原型链上确实是符合继承关系，但是这也<strong>只是</strong>在原型链上实现了继承，<code>Child.prototype.constructor</code>也不指向<code>Child</code>的构造函数，而是指向<code>Parent</code>的构造函数，而且这个构造函数还不是原型对象（Child.prototype）自己的属性</p><img src="..\images\前端面试-js\继承.png" style="zoom:80%"><p>正确的情况，<code>Child.prototype</code>的<code>constructor</code>应该是<code>Child.prototype</code><strong>自己的属性</strong>（ownProperty）</p><p>正确的状态，就是每个原型对象，都有一个自己的构造函数，指向正确的构造函数。比如<code>Parent.prototype</code>，就有自己的构造函数，指向Parent构造函数</p><img src="..\images\前端面试-js\继承2.png" style="zoom:80%"><p>总的来说，原型链继承的问题包括， 子类的原型对象<strong>没有自己的构造函数，还存在多余的属性</strong>。</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">    this.name = &#x27;parent1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line">    Parent1.call(this);</span><br><span class="line">    this.type = &#x27;child&#x27;</span><br><span class="line">&#125;</span><br><span class="line">let child = new Child();</span><br></pre></td></tr></table></figure><p>构造函数继承也只是实现了构造函数上的继承，比原型链继承还低智，就纯粹在<code>Child</code>的构造函数中，借助call方法调用了<code>Parent</code>的构造函数。</p><p>在这个例子中，<code>Parent1.call(this)</code>完全可以被替换为 <code>this.name = &#39;parent1&#39;;</code>这种继承方式唯一的作用，拿这个例子来讲，就是把父类<code>Parent</code>的name属性终于变成<code>子类Child实例</code>自己的属性了（对象本身就有的，而不是原型对象上的，可以通过<code>hasOwnProperty</code>方法来判断）。</p><img src="..\images\前端面试-js\构造函数继承.png" style="zoom:85%"><h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>组合式继承就是把前面两种方式，即<code>原型链继承</code>和<code>构造函数继承</code>，这两种不完美的方法结合了起来，并更正了<code>Child</code>原型对象的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 第二次调用 Parent()</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 Parent()</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数，更正指向</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child</span>())</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-js\组合继承.png" style="zoom:80%"><p>可以看到 <code>Child.prototype.constructor</code>指向是正确的，创建的<code>Child</code>实例也有自己的<code>name</code>和<code>play</code>属性，但是Child构造函数的原型对象上有多余的属性比如name和play。</p><p>再解释一下为什么这个Child实例对象前面有Child表示（如图），因为这个实例是被Child构造函数创建的；再解释一下<code>[[Prototype]]:Person</code>代表什么，代表<code>Child.prototype.__proto__ = Person.prototype</code></p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>是对组合式继承的<strong>优化</strong>，不再使用父类(<code>Parent</code>)的<code>实例</code>作为子类(<code>Child</code>)的原型对象(<code>Prototype</code>)，而是使用**Object.create()**方法单独为子类创造一个原型对象。</p><p><code>Object.create()</code>能以传入的对象为<code>对象原型</code>，创造一个新的对象。</p><p>示例：<code>Object.create(Parent.prototype)</code></p><p>以Parent的原型对象为对象原型，创造一个新的对象，意思就是<strong>创造的对象</strong>的<code>_proto_</code>属性&#x3D;<code>Parent.prototype</code> ，<strong>就好像创建了一个Parent实例</strong>，所以创建的对象显示的类型也是<code>Parent</code>，不过这个实例对象没有自己的属性（多余的属性比如name，play），再给这个对象添加自己的constructor属性后用来充当原型对象再合适不过了。</p><img src="..\images\前端面试-js\原型链.png" style="zoom:90%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">//&#123;friends:&quot;child&quot;,name:&quot;parent&quot;,play:[1,2,3],__proto__:Parent&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// parent</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getFriends</span>()); <span class="comment">// child</span></span><br></pre></td></tr></table></figure><h3 id="extends-super"><a href="#extends-super" class="headerlink" title="extends+super"></a>extends+super</h3><p>使用<code>extends</code>关键字实现继承，基于<code>es6</code>新引入的<code>class</code>，本质上使用的也是<code>寄生组合式继承</code>，不过还要配合<code>super</code>关键字使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法，会被挂载到构造函数的原型上</span></span><br><span class="line">  <span class="comment">// 即Person.prototype.getName = function() &#123;&#125;</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">//构造函数不是必须写的，如果不写构造函数就相当于书写了以下代码：</span></span><br><span class="line">  <span class="comment">//constructor(name) &#123;</span></span><br><span class="line">  <span class="comment">//  super(name)</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super(),表示调用父类的构造函数</span></span><br><span class="line">    <span class="comment">// 不调用super就会报错</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> asuna = <span class="keyword">new</span> <span class="title class_">Gamer</span>(<span class="string">&#x27;Asuna&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">asuna.<span class="title function_">getName</span>() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure><h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h2><p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p><ul><li>cookie</li><li>sessionStorage</li><li>localStorage</li><li>indexedDB</li></ul><p>其中<code>sessionStorage</code>和<code>localStorage</code>都是<code>H5</code>新增的，在次之前使用的都是cookie。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h4><p><code>Cookie</code>是存储在客户端的<code>小型文本文件（txt）</code>，被用来解决 <code>HTTP</code><strong>无状态</strong>导致的问题。</p><p>作为一段一般不超过 <code>4KB</code> 的小型文本数据（4KB 的大小限制主要针对单个 Cookie），它由一个名称（Name）、一个值（Value）和其它几个用于<strong>控制cookie有效期、安全性、使用范围</strong>的可选属性组成。</p><p>但是<code>cookie</code>在每次请求中都会被发送，如果不使用 <code>HTTPS</code>并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 <code>cookie</code>保持登录态的网站上，如果 <code>cookie</code>被窃取，他人很容易利用你的 <code>cookie</code>来假扮成你登录网站。</p><img src="..\images\前端面试-js\cookie.png" style="zoom:80%"><p>关于<code>cookie</code>常用的属性如下：</p><ul><li><p><strong>Expires</strong></p><p>用于设置 Cookie 的过期时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Expires</span>=<span class="title class_">Wed</span>, <span class="number">21</span> <span class="title class_">Oct</span> <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Max-Age</strong></p><p>用于设置在 Cookie 的有效时间（优先级比<code>Expires</code>高，书写方式也比Expires友好）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Max</span>-<span class="title class_">Age</span>=<span class="number">604800</span> <span class="comment">//单位是s</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Domain</strong></p><p>指定了 <code>Cookie</code> 在哪些域名下生效，<strong>包含了这些域名的请求，才会自动携带cookie</strong>。</p><p>添加cookie的时候，不指定Domain，默认就是<code>当前域名</code>；指定了一个域名，则其子域名也总会被包含；</p><p>比如，在<code>https://www.bilibili.com/</code>页面下添加一个cookie，但是未指定Domain，则Domain就是<code>www.bilibili.com</code></p><p>如果指定Domain为<code>bilibili.com</code>，则实际为<code>.bilibili.com</code>，表示在<code>bilibili.com</code>所有子域名下，这个cookie也生效，这一操作的效果等同于指定Domain为<code>.bilibili.com</code>。</p><p><strong>通过配置Domain可以实现跨子域共享cookie</strong>。</p></li><li><p><strong>Path</strong></p><p>指定了一个 <code>URL</code>路径，只有<strong>包含这个路径的请求，才能自动携带这个cookie</strong></p></li><li><p><strong>Secure</strong></p><p>标记为 <code>Secure</code>的 <code>Cookie</code>，意味着这个cookie包含了重要的信息，不应该被泄漏，<strong>只能通过<code>HTTPS</code>请求，安全地发送给服务器</strong>。</p></li><li><p><strong>HttpOnly</strong></p><p>标记为HttpOnly的请求，只能通过<code>http/https</code>协议来操作。</p></li><li><p><strong>SameSite</strong></p><p>Cookie默认不会在跨域请求中被发送，而跨站请求一定跨域，<code>SameSite</code> 属性用于控制 Cookie 是否应该随<strong>跨站请求</strong>一起发送。它有三个可能的值:</p><ul><li><code>Strict</code>：Cookie 仅在<code>同站</code>请求中发送，即只有当用户从同一站点发起请求时，才会包含 Cookie。</li><li><code>Lax</code>：大多数情况下不发送跨站请求中的 Cookie，但在导航到目标站点（如点击链接）时例外。</li><li><code>None</code>：允许跨站请求中发送 Cookie，但要求请求必须通过 <code>HTTPS</code> 发送（即启用安全传输层）。</li></ul></li></ul><p>然而只配置SameSite属性为None，还不能解决跨站请求不能携带cookie的问题，参考：<a href="https://www.sanye.blog/posts/c0add594.html">前端面试—网络 | 三叶的博客</a>中的<code>withCredentails</code>部分</p><h4 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a><strong>操作方式</strong></h4><ul><li><p><strong>通过js操作cookie</strong></p><ul><li><p>获取当前页面所有cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span></span><br></pre></td></tr></table></figure><p>返回一个<strong>字符串</strong>，包含当前页面的所有cookie的键值对，形如：<code>key=val;key2=val2;......;keys=vals</code>，正因如此，在前端访问某个具体的cookie是比较麻烦的，如果设置为<code>httpOnly</code>，前端更是访问不了。</p><p>如果要查看当前页面的全部cookie的详细信息，可以选择<code>检查页面</code>，前往<code>应用程序-&gt;存储-&gt;cookie</code>中查看。</p></li><li><p>创建一个cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以继续添加其他限制属性，一次只能添加一个cookie</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;key=val;Max-age=3600;Domain=www.sanye.blog&#x27;</span><span class="comment">//使用分号来分割 其他配置项</span></span><br></pre></td></tr></table></figure><p>我们知道，<code>document.cookie</code>，返回一个字符串，包含当前页面的所有cookie的键值对。上述创建cookie的代码的效果貌似是覆盖掉这个字符串，其实不是的，效果真的是添加一个cookie。</p></li><li><p>修改cookie</p><p>关于<code>cookie</code>的修改，首先要确定<code>domain</code>和<code>path</code>属性都是相同的才可以，<strong>这两个属性可以理解为用来限制cookie的作用域</strong>。其中有一个不同的时候，都会创建出一个新的<code>cookie</code>，而不是修改原来的cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;name=bb; domain=aa.net; path=/&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>删除cookie</p><p>最常用的方法就是给<code>cookie</code>设置一个过期的时间，这样<code>cookie</code>过期后会自动被浏览器删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;id=1;Max-age=0&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>通过http操作cookie</strong></p><p><strong>添加cookie</strong></p><p>http通过在响应头中添加<code>Set-Cookie</code>字段，在客户端种cookie，如果有多个 Cookie 就在响应头中设置多个 <code>Set-Cookie</code> 字段。</p><p>通过http操作cookie的方式，与js操作cookie的方式在形式上是不同的，但本质上还是相同的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; [<span class="title class_">Expires</span>=&lt;date&gt;]; [<span class="title class_">Max</span>-<span class="title class_">Age</span>=&lt;non-zero-digit&gt;]; [<span class="title class_">Domain</span>=&lt;domain-value&gt;]; [<span class="title class_">Path</span>=&lt;path-value&gt;]; [<span class="title class_">Secure</span>]; [<span class="title class_">HttpOnly</span>]; </span><br></pre></td></tr></table></figure><p><strong>更新或者删除cookie</strong></p><p>要更新现有的Cookie，只需再次发送带有<code>相同名称</code>的新 <code>Set-Cookie</code> 头。这将覆盖旧的同名Cookie。要删除一个Cookie，可以通过设置其 <code>Expires</code> 或 <code>Max-Age</code> 为过去的时间戳来实现</p></li></ul><h4 id="浏览器行为"><a href="#浏览器行为" class="headerlink" title="浏览器行为"></a><strong>浏览器行为</strong></h4><ul><li>浏览器会在每次请求时，自动附加（携带）与<strong>目标URL</strong>（也就是<strong>请求url</strong>，而不是发起请求所在页面的url）相匹配的所有Cookies。</li><li>如果某个Cookie被标记为 <code>HttpOnly</code>，那么JavaScript代码不能<code>读取或修改</code>这个Cookie，增加了安全性。</li><li>当一个Cookie过期后，浏览器会自动将其从存储中移除，不再随请求一起发送。</li></ul><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p><code>HTML5</code>新方法，IE8及以上浏览器都兼容</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>持久化的本地存储，除非主动删除数据，否则数据永不过期</li><li>localStorage中的<strong>键和值必须是字符串类型</strong>，如果指定为数字，布尔值，或者引用数据类型，则会隐式转化成字符串。</li><li><strong>遵循严格的同源策略</strong>：存储的信息在<code>同一域</code>中是共享的，这个同一域包括<code>子域名</code>，也就是说若两个域名即便只有子域名不同，也不会被认为是同一域名。子域名指的是主域名之前的部分，比如<code>www.sanye.blog</code>中的<code>www</code>就是子域名，<code>sanye.blog</code>就是主域名，一般域名购买，购买的就是主域名。</li><li>当本页操作（新增、修改、删除）了<code>localStorage</code>中的数据的时候，本页面不会触发<code>storage</code>事件，但是别的页面会触发<code>storage</code>事件，这里的其他页面，指的是<code>同源</code>的其他页面。</li><li>大小：5M（跟浏览器厂商有关系）,<code>localStorage</code> 的大小限制主要指的是 <strong>整个域名下所有存储数据的总和</strong>，而不是单个键值对的大小。</li><li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li></ul><h4 id="storage事件补充"><a href="#storage事件补充" class="headerlink" title="storage事件补充"></a><strong>storage事件补充</strong></h4><p>storage有许多api，那哪些常用的api能触发storage事件呢？</p><table><thead><tr><th align="center">方法</th><th align="center">是否触发 <code>storage</code> 事件</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>setItem(key, value)</code></td><td align="center">✅ <strong>会触发</strong></td><td align="center">设置新值或修改现有值</td></tr><tr><td align="center"><code>removeItem(key)</code></td><td align="center">✅ <strong>会触发</strong></td><td align="center">删除指定键值</td></tr><tr><td align="center"><code>clear()</code></td><td align="center">✅ <strong>会触发</strong></td><td align="center">清空整个存储</td></tr><tr><td align="center"><code>getItem(key)</code></td><td align="center">❌ <strong>不会触发</strong></td><td align="center">仅读取数据，无副作用</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;storage&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 当清空token的时候，所有页面退出登录</span></span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">key</span>===<span class="string">&#x27;token&#x27;</span> &amp;&amp; e.<span class="property">newValue</span> === <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">    router.<span class="title function_">navigate</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当一个页面登录的时候，另一个页面也跳转到首页</span></span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">key</span>===<span class="string">&#x27;token&#x27;</span> &amp;&amp; e.<span class="property">oldValue</span> ===<span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">    router.<span class="title function_">navigate</span>(<span class="string">&#x27;/home&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>假设你有两个标签页（Tab A 和 Tab B）打开了同一个网站 <code>example.com</code>，并且这两个标签页都在使用 <code>localStorage</code> 来存储一些数据。</p><ol><li><p><strong>Tab A</strong> 中执行以下 JavaScript 代码来设置一个新的 <code>localStorage</code> 项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Tab A</strong> 不会触发 <code>storage</code> 事件，因为它就是触发这次变更的<code>操作源</code>。</p></li><li><p><strong>Tab B</strong> 中监听 <code>storage</code> 事件，并打印出事件详情：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;storage&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Storage event received:&#x27;</span>, event);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Key:&#x27;</span>, event.<span class="property">key</span>);<span class="comment">//可以得知修改的localstorage中的哪个字段，比如token字段</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Old value:&#x27;</span>, event.<span class="property">oldValue</span>);<span class="comment">// 该字段修改后的新值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;New value:&#x27;</span>, event.<span class="property">newValue</span>);<span class="comment">// 该字段修改前的旧值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;URL:&#x27;</span>, event.<span class="property">url</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>当你在 <strong>Tab A</strong> 中设置了 <code>localStorage</code> 后，<strong>Tab B</strong> 会立即接收到 <code>storage</code> 事件，并输出类似如下的信息：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Storage event received: StorageEvent &#123;…&#125;</span><br><span class="line">Key: key</span><br><span class="line">Old value: null</span><br><span class="line">New value: value</span><br><span class="line">URL: https://example.com/</span><br></pre></td></tr></table></figure></li><li><p>如果你在 <strong>Tab B</strong> 中也设置了相同的 <code>localStorage</code> 项，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;newValue&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Tab B</strong> 自身不会触发 <code>storage</code> 事件，但 <strong>Tab A</strong> 会接收到 <code>storage</code> 事件，并显示相应的更新信息。</p></li></ol><h4 id="常见使用语法"><a href="#常见使用语法" class="headerlink" title="常见使用语法"></a><strong>常见使用语法</strong></h4><p>设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;cfangxu&#x27;</span>);</span><br></pre></td></tr></table></figure><p>获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>获取键名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">key</span>(<span class="number">0</span>) <span class="comment">//获取第一个键名</span></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一次性清除所有存储</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p><code>localStorage</code> 也不是完美的，它有两个缺点：</p><ul><li>无法像<code>Cookie</code>一样设置过期时间</li><li>只能存入<code>字符串</code>，无法直接存对象，如果尝试存储一个对象，它会自动调用该对象的 <code>toString()</code> 方法，这通常会导致数据丢失或无法正确恢复原始对象；存入对象之前必须先<code>序列化</code>。</li></ul><h4 id="和cookie的区别与联系"><a href="#和cookie的区别与联系" class="headerlink" title="和cookie的区别与联系"></a>和cookie的区别与联系</h4><ul><li><strong>过期时间</strong>：<code>localStorage</code> 无法像<code>Cookie</code>一样设置<code>过期时间</code>，数据在本地的存储是<code>持久化</code>的，除非主动删除数据，否则数据<code>永不过期</code>。</li><li><strong>存取方式</strong>：<code>localStorage</code>中的数据必须<code>手动存取</code>，而<code>cookie</code>中的数据是<code>自动存取</code>的</li><li><strong>同源策略</strong>：<code>localStorage</code>严格遵循同源策略，同源页面才能共享同一份<code>localStorage</code>中的数据；虽然 Cookies 也默认遵循同源策略，但可以通过特定的设置来实现<code>跨子域的数据共享</code>。</li><li><strong>大小限制</strong>：二者都有存储大小的限制，每个<code>cookie</code>的存储大小限制是4kB，而每个页面的<code>localStorage</code>的存储大小限制一般是5MB，明显更大。</li><li><strong>存储类型</strong>：二者只能存储<code>字符串</code>。这意味着如果你想要存储对象或其他复杂的数据结构，需要进行<code>序列化</code>和<code>反序列化</code>操作。</li></ul><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code>和 <code>localStorage</code>使用方法基本一致，唯一不同的是<code>生命周期</code>，<strong>一旦页面（会话）关闭，<code>sessionStorage</code> 中的数据将会被删除。</strong></p><h3 id="前端扩展存储方式"><a href="#前端扩展存储方式" class="headerlink" title="前端扩展存储方式"></a>前端扩展存储方式</h3><p>虽然 <code>Web Storage</code>对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。<code>IndexedDB</code>提供了一个解决方案。</p><p><code>indexedDB</code>是一种低级API，用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用<code>索引(index)</code>来实现对该数据的高性能搜索。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>储存量理论上没有上限</li><li>所有操作都是<code>异步</code>的，相比 <code>LocalStorage</code> 同步操作性能更高，尤其是数据量较大时</li><li>原生支持储存<code>JS</code>的对象</li><li>是个正经的数据库，意味着数据库能干的事它都能干</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>操作非常繁琐</li><li>本身有一定门槛</li></ul><p>关于<code>indexedDB</code>的使用基本使用步骤如下：</p><ul><li>打开数据库并且开始一个事务</li><li>创建一个 <code>object store</code></li><li>构建一个请求来执行一些数据库操作，像增加或提取数据等。</li><li>通过监听正确类型的 <code>DOM</code> 事件以等待操作完成。</li><li>在操作结果上进行一些操作（可以在 <code>request</code>对象中找到）</li></ul><p>关于使用<code>indexdb</code>的使用会比较繁琐，大家可以通过使用<code>Godb.js</code>库进行缓存，最大化的降低操作难度</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>标记用户与跟踪用户行为的情况，推荐使用<code>cookie</code></li><li>适合长期保存在本地的数据（令牌），推荐使用<code>localStorage</code></li><li>敏感账号一次性登录，推荐使用<code>sessionStorage</code></li><li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用<code>indexedDB</code></li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是一种创建<strong>交互式网页</strong>应用的<strong>开发技术</strong>, 可以在<strong>不重新加载</strong>整个网页的情况下，<strong>与服务器交换数据</strong>，并且局部更新网页。</p><p><code>Ajax</code>的原理简单来说就是通过<code>XmlHttpRequest(xhr)</code>对象向服务器发送<strong>异步请求</strong>，收到服务器响应的数据后，用<code>Js</code>操作<code>DOM</code>来更新页面。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ul><li><p>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法初始化一个 HTTP 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(method, url, [<span class="keyword">async</span>][, user][, password])</span><br></pre></td></tr></table></figure><ul><li><code>method</code>：表示当前的请求方式，常见的有<code>GET</code>、<code>POST</code></li><li><code>url</code>：服务端地址</li><li><code>async</code>：布尔值，表示是否异步执行操作，默认为<code>true</code></li><li><code>user</code>: 可选的用户名用于认证用途；默认为<code>null</code></li><li><code>password</code>: 可选的密码用于认证用途，默认为<code>null</code></li></ul></li><li><p>构建请求所需的<code>数据内容</code>，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>([body])<span class="comment">//如果请求体中不需要携带数据，什么都不要传入</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件（即<code>监听(on)准备状态(readystate)改变(change)</code>）监听服务器端的通信状态。</p><p>关于<code>XMLHttpRequest.readyState</code>属性有5个状态，用数字来区分，只要 <code>readyState</code>属性值一变化，就会触发一次 <code>readystatechange</code> 事件。</p><ul><li>0（unsent）：<code>open</code>方法还未调用，连接还未建立。</li><li>1（opened)：<code>open</code>方法调用了，但是还未发送请求（还未调用<code>send</code>方法）</li><li>2（headers_recieved）：请求发送了，<code>响应头</code>和<code>响应状态</code>已经接收到了，但是还未开始下载。</li><li>3（loading）：<code>响应体</code>下载中</li><li>4（done）：响应体下载完毕，请求完成。</li></ul><p>这五个状态可以简记为，<code>open</code>前，<code>send</code>前，响应状态+响应头接受但响应体还未开始下载，响应体下载中，响应体下载完毕。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">//注意这里不是ContentType</span></span><br><span class="line"><span class="comment">//xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)：用于设置请求头，告诉服务器请求体的格式。</span></span><br><span class="line"><span class="comment">//xhr.responseType = &#x27;json&#x27;：用于设置响应类型，告诉浏览器如何解析响应体。</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;arraybuffer&#x27;</span>; <span class="comment">// 设置响应类型为二进制数据</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123; <span class="comment">// 整个请求过程完毕</span></span><br><span class="line">        <span class="comment">//状态码是xhr.status不是statusCode</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>) <span class="comment">// 状态文本</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">resopnse</span>)<span class="comment">//拿到响应的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;=<span class="number">400</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;错误信息：&quot;</span> + xhr.<span class="property">status</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于初始化一个 HTTP 请求。这个方法并不发送请求，而是为后续的 request.send() 调用做准备</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://xxxx&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure></li><li><p>onload 是 XMLHttpRequest 的另一个事件处理函数，它仅在请求成功完成（即 readyState &#x3D;&#x3D;&#x3D; 4 且 status 为成功状态码，如 200）时触发，更简洁，适用于只关心成功响应的场景。如果请求失败（如网络错误或服务器返回非 2xx 状态码），<code>onload</code> 不会被触发，而是会触发 <code>onerror</code> 或 <code>ontimeout</code>。</p></li><li><p><strong>接受并处理</strong>服务端向客户端响应的数据结果</p></li><li><p>将处理结果<strong>更新</strong>到 <code>HTML</code>页面中</p></li></ul><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><ul><li><p>也能发送ajax请求，且不需要借助xhr</p></li><li><p>是浏览器内置的api，不需要额外下载</p></li><li><p>和axios一样，也是基于promise的</p></li><li><p>特点是关注分离，不能一步就拿到数据</p></li><li><p>缺点是兼容性不好，部分老版本浏览器不支持这个api，所以fetch用的并不多，了解就好</p></li><li><p>fetch方法的参数：第一个参数是url，第二个参数是一个配置对象，用于自定义请求的行为，常见参数如下，由此可以看出：xhr的open方法的第一个参数是请求的方法，axios的常见写法<code>axios.method</code>也可以认为第一个参数是请求方法，而fetch方法的第一个参数却是url，请求方法在第二个参数中，属于配置属性之一。</p></li></ul><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>method</code></td><td>字符串</td><td>请求方法，默认为 <code>&#39;GET&#39;</code>。常见的值包括 <code>&#39;GET&#39;</code>、<code>&#39;POST&#39;</code>、<code>&#39;PUT&#39;</code>、<code>&#39;DELETE&#39;</code> 等。</td></tr><tr><td><code>headers</code></td><td>对象或 Headers</td><td>设置请求头。例如：<code>&#123; &#39;Content-Type&#39;: &#39;application/json&#39; &#125;</code>。</td></tr><tr><td><code>body</code></td><td>字符串、Blob、FormData 等</td><td>请求体数据，仅适用于非 GET 请求（如 POST、PUT）。</td></tr><tr><td><code>mode</code></td><td>字符串</td><td>请求模式，默认为 <code>&#39;cors&#39;</code>。常见值包括 <code>&#39;cors&#39;</code>、<code>&#39;no-cors&#39;</code>、<code>&#39;same-origin&#39;</code>。</td></tr><tr><td><code>credentials</code></td><td>字符串</td><td>是否携带凭据（如 cookies）。常见值包括 <code>&#39;omit&#39;</code>、<code>&#39;same-origin&#39;</code>、<code>&#39;include&#39;</code>。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fetch返回值是一个promise对象</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://www.sanye.blog&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//不能直接拿到数据，第一步先判断是否成功联系到服务器，输出res也看不到数据的踪迹</span></span><br><span class="line">    <span class="comment">//也就是说不能通过第一个promise对象的值拿到数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器成功&#x27;</span>,res)</span><br><span class="line">    <span class="comment">//res.json()又会返回一个promise对象，返回的数据就是这个promise对象的值</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">json</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//输出，查看数据的结构</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err)&#125;)<span class="comment">//最后调用catch，统一处理错误，至于为什么能捕获全部错误，原理不太清楚</span></span><br></pre></td></tr></table></figure><p>当我们调用then方法的时候只传入成功回调的时候，借助<code>async，await</code>能让代码更简洁，并使用<code>try-catch</code>捕获错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用2次await</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.sanye.blog&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><code>axios</code> 是一个基于<code>promise</code>的网络请求库，在浏览器端借助<code>XHR</code>，在<code>node.js</code>中借助<code>http</code>模块</p><p>有如下特点：</p><ul><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换<code>JSON</code> 数据</li><li>客户端支持防御<code>XSRF</code></li></ul><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>在浏览器中可以通过<code>script</code>标签直接引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在node模块化开发环境中，可以通过<code>npm包</code>的形式下载，需要使用的时候再导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --S //安装到生产环境</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="实现一个简易版的axios"><a href="#实现一个简易版的axios" class="headerlink" title="实现一个简易版的axios"></a>实现一个简易版的axios</h3><h4 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h4><p>构建一个<code>Axios</code>类，核心代码为<code>request</code>方法。从上述代码中，我们可以看出axios其实就是使用<code>promise+xhr</code>实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Axios</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">//因为axios实例并没有什么常用的属性，所以这里没有任何初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心方法request，会自动挂载到Axios.prototype上，传入配置对象，立即返回一个promise对象（状态为pending）</span></span><br><span class="line">    <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">        <span class="comment">//request方法会立即返回一个promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        	<span class="comment">//对象解构赋值，获取到请求url，method（默认值是Get），data，并给这些属性赋予默认值</span></span><br><span class="line">            <span class="keyword">const</span> &#123;url = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;get&#x27;</span>, data = &#123;&#125;&#125; = config; <span class="comment">//实际请求携带的配置参数可能不止这么点</span></span><br><span class="line">            <span class="comment">// 发送ajax请求,可以看出axios在浏览器中是基于xhr的</span></span><br><span class="line">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//用于初始化一个 HTTP 请求。这个方法并不发送请求</span></span><br><span class="line">            <span class="comment">//第三个参数是一个布尔值，表示是否异步执行请求，默认为true，表示异步。</span></span><br><span class="line">            xhr.<span class="title function_">open</span>(method, url[, <span class="literal">true</span>]);</span><br><span class="line">            xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">//当请求被响应，根据响应状态码，改变promise对象的状态</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">                <span class="comment">//调用resolve函数，修改Promise实例的状态为fulfilled, 修改value为xhr.response</span></span><br><span class="line">                <span class="comment">//这一操作，就把异步回调函数内的值传递到外部了，避免依赖这个数据的代码，写在回调函数内</span></span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">response</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title function_">error</span>(<span class="string">&#x27;请求失败&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送请求并携带数据</span></span><br><span class="line">            xhr.<span class="title function_">send</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个axios实例</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span><br><span class="line"><span class="comment">//定义一个axios函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> context.<span class="title function_">request</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于调用request方法会立即返回一个Promise对象，所以调用axios函数也会立即返回一个promise对象</strong></p><h4 id="axios-method"><a href="#axios-method" class="headerlink" title="axios.method()"></a>axios.method()</h4><p>下面是来实现下<code>axios.method()</code>这种形式的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodsArr = [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;post&#x27;</span>];</span><br><span class="line"><span class="comment">//在Axios的prototype上挂载这些方法。这种写法功能等同于直接在Axios类中一个个定义这些方法（类似request方法）</span></span><br><span class="line"><span class="comment">//不过这种写法更简洁。</span></span><br><span class="line">methodsArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[method] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 处理只可能传入2个参数的请求方法</span></span><br><span class="line">        <span class="comment">// 2个参数(url[, config])</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>].<span class="title function_">includes</span>(method)) &#123;</span><br><span class="line">            <span class="comment">//此处的this指向axios实例，所以能调用request方法，同时也说明这些方法本质也是在调用request方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                method,</span><br><span class="line">                <span class="attr">url</span>: <span class="variable language_">arguments</span>[<span class="number">0</span>],</span><br><span class="line">                ...(<span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;)<span class="comment">//如果第二个参数没传入，arguments[1]的值就是undefined，然后展开一个空对象</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3个参数(url[,data[,config]])</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                method,</span><br><span class="line">                <span class="attr">url</span>: <span class="variable language_">arguments</span>[<span class="number">0</span>],</span><br><span class="line">                <span class="attr">data</span>: <span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;,<span class="comment">//arguments[1]是一个数据对象，不需要展开</span></span><br><span class="line">                ...<span class="variable language_">arguments</span>[<span class="number">2</span>] || &#123;&#125;<span class="comment">//arguments[2]是剩余配置属性对象，需要展开</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>arguments 是一个<strong>类数组对象</strong>，它包含了<strong>传递给函数的所有参数</strong>；arguments 对象允许你在不知道具体有多少个参数的情况下，访问所有传递给函数的参数，<strong>即便函数没有声明形参</strong></p></li><li><p><code>get，post</code>这些方法与<code>request</code>方法一样，都挂载到<code>Axios.prototype</code>上</p></li><li><p>这些方法本质是在调用<code>Axios.prototype.request</code>方法，并返回<code>request</code>方法的返回值，就如同<code>axios函数</code>一样</p></li><li><p>无论是调用<code>axios()</code>，还是<code>axios.get()</code>，都会<strong>立即返回一个<code>promise</code>对象</strong>，因为它们本质都是在调用<code>request</code>方法。</p></li></ul><p>我们还期望<strong>axios函数</strong>能直接调用get，post这些方法，而不只是<strong>axios实例</strong>，所以我们还需要做其他处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> context.<span class="title function_">request</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 Axios 原型上的方法挂载到 axios 函数对象上（或者axios函数的原型上），这些方法包括request方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (key !== <span class="string">&#x27;constructor&#x27;</span>) &#123;</span><br><span class="line">    axios[key] = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>把 Axios 原型上的方法，挂载到 axios 函数对象上（或者axios函数的原型对象上）</strong>，这些方法包括request方法。在上述配置之后，就能使用axios函数调用get，post等方法了。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>在线文档关于<code>axios</code>的介绍说实话没有让人看下去的动力，这里写点自己的东西。</p><h4 id="axios-create"><a href="#axios-create" class="headerlink" title="axios.create"></a>axios.create</h4><p><strong>调用<code>axios.create</code>传入一个配置对象，它的返回值具有与axios函数一样的功能，具体来说<code>axios.create</code>的返回值也是一个函数，而不是一个axios实例</strong>，可以像axios函数那样直接调用，也可以调用get，post等方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://smart-shop.itheima.net/index.php?s=/api&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;platform&#x27;</span>: <span class="string">&#x27;H5&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> request)<span class="comment">//function</span></span><br></pre></td></tr></table></figure><p>这样就相当于为每个请求都配置了相同的<code>基地址</code>，<code>超时时间</code>，<code>请求头</code>，起到了<strong>封装</strong>的作用</p><h4 id="添加拦截器"><a href="#添加拦截器" class="headerlink" title="添加拦截器"></a><strong>添加拦截器</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="comment">// 只要有token，就在请求时携带，便于请求需要授权的接口</span></span><br><span class="line">  <span class="comment">// 每次请求都会获取token,也就是说token每次都是现用现取的，如果删除了就取不到了</span></span><br><span class="line">  <span class="keyword">const</span> token = store.<span class="property">getters</span>.<span class="property">token</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Access-Token&#x27;</span>] = token</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码(response.status)都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response.<span class="property">data</span> <span class="comment">//默认会被包装成resolved类型的promise对象</span></span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error) <span class="comment">//如果直接返回error，也会被包装成resolved类型的promise对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>前面我们介绍过，无论是调用<code>axios()</code>，还是<code>axios.get()</code>，都会<strong>立即返回一个<code>promise</code>对象</strong>，因为它们本质都是在调用<code>request</code>方法。<strong>这个立即返回的promise对象的值和状态，由响应拦截器的返回值决定</strong></p><ul><li>响应拦截器中有2个回调函数，响应成功的回调和失败的回调，同时只能调用一个</li><li>如果最终返回的是一个<strong>普通的数据（非Promise对象）</strong>，无论是哪个回调函数返回的，则这个<strong>立即返回的promise对象</strong>的值，就是这个返回的普通数据，状态变为<code>fulfilled</code></li><li>如果返回一个状态为<code>rejected</code>的promise对象，比如<code>Promise.reject(error)</code>，无论是哪个回调函数返回的，则这个立即返回的promise对象的值，就变为error，状态变为<code>rejected</code></li><li>如果返回一个状态为<code>fulfilled</code>的promise对象，比如<code>Promise.resolve(response.data)</code>，无论是哪个回调函数返回的，其效果其实就相当于return <code>response.data</code>。也就是说，最终的 Promise 将获得 <code>response.data</code> 作为其值，并进入 <code>fulfilled</code> 状态。</li><li><strong>无论是在成功的回调函数中，还是在失败的回调函数中</strong>，只要最终返回了<code>Promise.reject()</code>，那么 <code>axios</code> 请求的 <code>Promise</code> 的状态将变为<code>rejected</code>，并触发失败回调链，导致 <code>.catch()</code> 方法被调用；</li></ul><h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a><strong>取消请求</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = axios.<span class="property">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;xxxx&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.<span class="property">token</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取消请求 (请求原因是可选的)</span></span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;主动取消请求&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>axios.CancelToken是一个构造函数，用来获得取消令牌源对象。</li><li>source是一个取消令牌源对象。这个对象包含了两个重要的属性：<ul><li>token: 这是一个实际的取消令牌。你可以将这个令牌传递给 Axios 请求配置中的 cancelToken 属性，从而使得该请求可以被取消。</li><li>cancel: 这是一个函数，调用它可以取消所有关联了<code>source.token</code> 的请求。你可以选择性地提供一个消息参数，这个消息会作为<strong>取消原因</strong>包含在<strong>取消事件</strong>中。调用<code>source.cancel(&#39;取消原因&#39;)</code> 时，它会将关联的 cancelToken 标记为已取消状态，并记录提供的取消原因（如 ‘取消原因’），<strong>这个操作不会直接发送网络请求，而是改变了令牌的状态</strong>。</li></ul></li></ul><p><strong>深入分析</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="comment">//获得取消请求源对象</span></span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(source.<span class="property">token</span>)<span class="comment">//输出token，结构如下</span></span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\取消请求2.png" style="zoom:85%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;主动取消&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(source.<span class="property">token</span>)</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\取消请求.png" style="zoom:80%"><p>Axios 的<code>响应拦截器</code>会检查每个正在处理的请求，是否关联了被标记为<strong>已取消</strong>的 <code>cancelToken</code>。如果匹配，则立即停止该请求的进一步处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给axios实例，添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 判断是否是因为取消操作导致的错误</span></span><br><span class="line">  <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request canceled:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他错误处理</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求失败，请稍后重试&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>简单的来说，我们想要某个请求被取消，那么这个请求必须携带<code>cancelToken</code></li><li>当我们想要取消请求的时候，就调用<code>source.cancel()</code>方法并传入取消的原因，这个操作并不会发送新的请求，而是会修改<code>cancelToken</code>的状态，然后响应拦截器根据<code>cancelToken</code>的状态，判断不再需要处理这个请求</li><li><strong>所以说，请求取消，完全不需要后端配合，请求发送后无论如何都会被响应，取消请求只不过是抛弃了响应结果</strong>。</li></ul><h4 id="使用axios实例发送请求"><a href="#使用axios实例发送请求" class="headerlink" title="使用axios实例发送请求"></a><strong>使用axios实例发送请求</strong></h4><p>我们通常把同一业务功能的<code>api</code>放到一个js文件中，比如和购物车<code>cart</code>相关的接口，都放在<code>cart.js</code>文件中，在这些文件中引入导出的axios函数来发送请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import request from &#x27;index.js&#x27;</span><br></pre></td></tr></table></figure><p>发送请求有<strong>两种</strong>常用写法</p><h5 id="request"><a href="#request" class="headerlink" title="request({})"></a>request({})</h5><p>这种写法是直接传入一个<code>配置对象</code>，<code>请求方法(method)</code>等所有信息都包含在内，我们需要对大部分<strong>配置属性</strong>都熟悉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:</span><br><span class="line">    <span class="attr">data</span>:</span><br><span class="line">    <span class="attr">headers</span>:</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="request-method"><a href="#request-method" class="headerlink" title="request.method()"></a>request.method()</h5><p>这种写法是把<code>请求方法</code>提取到外面，然后传入多个参数来实现的。</p><p>第一个参数指定请求的 <strong>URL</strong></p><p>第二个参数：</p><ul><li>如果是<code>get/delete</code>等请求，就是除了<code>请求体</code>外的<code>配置属性</code>，即不包括<strong>data</strong>属性的配置对象。</li><li>如果是<code>put/post</code>请求，则是<code>data</code>，即<code>请求体</code>数据对象，所以说<strong>第二个参数到底是data还是不包括data属性的配置对象，取决于请求的方法。</strong></li></ul><p>第三个参数，只有<code>put/post</code>请求，可能需要配置第三个参数，<strong>即不包括<code>data</code>属性的配置对象</strong>。</p><p><strong>要注意的是，使用了这种写法：<code>request.method()</code>，再直接传入一个配置对象是不符合语法的，是错误的，必须按照上述的规则填写参数。</strong></p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"><span class="comment">//修改购物车商品信息（这里url是模板字符串，因为使用了path参数）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">updateCartAPI</span> = (<span class="params">&#123; skuId, selected, count &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> request.<span class="title function_">put</span>(<span class="string">`/member/cart/<span class="subst">$&#123;skuId&#125;</span>`</span>, &#123; selected, count &#125;)<span class="comment">//立即返回一个promise对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//delete也要传入data，属于接口不符合规范</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">delCartAPI</span> = (<span class="params">ids</span>) =&gt; <span class="title function_">request</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/member/cart&#x27;</span>, <span class="attr">method</span>: <span class="string">&#x27;delete&#x27;</span>, <span class="attr">data</span>: &#123; ids &#125; &#125;)</span><br></pre></td></tr></table></figure><ul><li><p>配置对象和<code>接口文档</code>的对应关系</p><ul><li><p>path：需要在<strong>url</strong>中直接配置，嵌入在url的<code>资源路径</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/users/&#123;userId&#125;  ---&gt;  /users/123</span><br></pre></td></tr></table></figure></li><li><p>query：在配置对象的<code>params</code>属性中配置，会被放到url的<code>?</code>之后，并且多个参数之间用与号 <code>&amp;</code> 分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;name:&quot;tom&quot;,age:18&#125;  ---&gt;  /users/?name=tom&amp;age=18</span><br></pre></td></tr></table></figure></li><li><p>body：即请求体，在<code>data</code>属性中配置</p></li><li><p>header：在配置对象的<code>headers</code>属性中配置</p></li></ul></li><li><p>配置对象和<code>请求报文</code>的对应关系</p><ul><li>header对应请求报文中的<code>请求头</code></li><li>data对应请求报文中的<code>请求体</code></li><li>method请求方法，资源路径，查询参数等出现在<code>请求行</code>中。</li></ul></li></ul><h3 id="响应结果结构分析"><a href="#响应结果结构分析" class="headerlink" title="响应结果结构分析"></a>响应结果结构分析</h3><img src="..\images\前端面试-js\axios.png" style="zoom:90%"><p>在响应拦截器中，常常通过<code>response.status</code>来判断执行哪个函数，可以注意到<code>status</code>和<code>data</code>是同一级别的数据</p><img src="..\images\前端面试-js\axiso2.png" style="zoom:80%"><p>响应错误对象的<code>response</code>属性则有与响应成功对象<code>一样</code>的结构</p><h2 id="文件上传怎么做"><a href="#文件上传怎么做" class="headerlink" title="文件上传怎么做"></a>文件上传怎么做</h2><img src="..\images\前端面试-js\文件上传.png" style="zoom:75%"><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>借助input标签，点击选择文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> postImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.postImage&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">   postImage.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])<span class="comment">//输出一个File对象</span></span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>选择文件后可以通过<code>e.target.files</code>获取到文件对象File数组</p><p>为什么是<code>files</code>呢，因为如果我们给input标签添加<code>multiply</code>属性，是允许选择多个文件的，也就是多文件上传，不过这要求用户有一定的电脑操作基础，要知道如何选择多个文件。所以开发过程中，使用的方案其实是<code>多次单文件上传</code>，用一个数组存储每次循环的选择的文件对象。</p><h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><img src="..\images\前端面试-js\file.png" style="zoom:80%"><h4 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a><strong>常见属性</strong></h4><ul><li><p>lastModified：文件上次被修改的时间，值是一个时间戳，在浏览器协商缓存中非常重要</p></li><li><p>size属性：表示文件的<strong>字节数（B</strong>），可用来限制文件的大小</p></li><li><p>type属性：表示文件的类型</p></li></ul><p>file对象打印出来是这样的，其中包含的文件数据存储在哪儿？在浏览器环境中，<code>File</code> 对象中的文件数据并不是直接存储在 JavaScript 变量中，而是存储在<strong>浏览器的内存中</strong>或临时存储区域。具体来说，当你通过 <code>&lt;input type=&quot;file&quot;&gt;</code> 选择一个文件后，文件的内容会被读取到浏览器的内存中。JavaScript 可以通过 <code>FileReader</code> API 或其他方法访问这些数据。</p><p>总的来说<strong>，<code>File</code> 对象本身并不直接包含文件数据，而是提供了一个接口，来访问文件的信息和内容</strong></p><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>如果想处理大文件，可以使用 <code>File.slice()</code> 方法来分片读取文件内容。从而实现文件的分片上传。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传文件逻辑，使用fetch+AbortController实现</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">min</span>(start + chunkSize, file.<span class="property">size</span>);</span><br><span class="line">  <span class="keyword">const</span> chunk = file.<span class="property">file</span>.<span class="title function_">slice</span>(start, end);</span><br><span class="line">  <span class="comment">// 当 `FormData` 包含文件(File)时，</span></span><br><span class="line">  <span class="comment">// 会自动设置请求头 `Content-Type` 为 `multipart/form-data`，这是文件上传的标准格式</span></span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">  <span class="comment">// 当第二个参数是 Blob 或 File 类型时，</span></span><br><span class="line">  <span class="comment">// filename 参数会作为文件名写入请求头的 Content-Disposition 部分，</span></span><br><span class="line">  <span class="comment">// 服务器可通过此字段识别原始文件名</span></span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&quot;video&quot;</span>, <span class="keyword">new</span> <span class="title class_">Blob</span>([chunk]), file.<span class="property">name</span>);</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;http://localhost:8081/api/upload&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: formData,</span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!res.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;网络响应失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果文件没有上传完，则继续上传</span></span><br><span class="line">      start = end;</span><br><span class="line">      <span class="keyword">if</span> (end &lt; file.<span class="property">size</span>) &#123;</span><br><span class="line">        <span class="title function_">uploadFile</span>(file);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文件上传完成&quot;</span>);</span><br><span class="line">        file.<span class="property">status</span> = <span class="string">&quot;completed&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;上传过程中出错&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="和Blob对象的关系"><a href="#和Blob对象的关系" class="headerlink" title="和Blob对象的关系"></a><strong>和Blob对象的关系</strong></h4><p>属于Blob类的子类，二者可以随意转换；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Blob</span>([file]);<span class="keyword">new</span> <span class="title class_">File</span>([blob],filename)</span><br></pre></td></tr></table></figure><h4 id="案例：将网络图片转换成File对象"><a href="#案例：将网络图片转换成File对象" class="headerlink" title="案例：将网络图片转换成File对象"></a><strong>案例：将网络图片转换成File对象</strong></h4><p>二进制数据-&gt;Blob对象-&gt;File对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">imageUrlToFile</span> = <span class="keyword">async</span> (<span class="params">url, fileName</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步：使用axios获取网络图片数据</span></span><br><span class="line">    <span class="comment">// img标签也默认会以二进制格式加载图片数据，但不会显式指定 responseType: &#x27;arraybuffer&#x27;。</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(url, &#123; <span class="attr">responseType</span>: <span class="string">&#x27;arraybuffer&#x27;</span> &#125;) <span class="comment">//指定接收二进制数据流</span></span><br><span class="line">    <span class="keyword">const</span> imageData = response.<span class="property">data</span><span class="comment">//返回的是二进制数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：将图片数据转换为Blob对象</span></span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([imageData], &#123;</span><br><span class="line">      <span class="attr">type</span>: response.<span class="property">headers</span>[<span class="string">&#x27;content-type&#x27;</span>]<span class="comment">//这个表达式的值是&quot;image/jpeg&quot;，确保文件类型正确识别</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：根据创建好的Blob对象，创建一个新的File对象</span></span><br><span class="line">    <span class="comment">// blob.type的值:&#x27;image/jpeg&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> file = <span class="keyword">new</span> <span class="title class_">File</span>([blob], fileName, &#123; <span class="attr">type</span>: blob.<span class="property">type</span> &#125;)</span><br><span class="line">    <span class="comment">// 返回的是一个promise对象</span></span><br><span class="line">    <span class="keyword">return</span> file</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;将图片转换为File对象时发生错误:&#x27;</span>, error)</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>responseType</th><th>含义</th></tr></thead><tbody><tr><td><code>&#39;json&#39;</code> (默认)</td><td>自动将响应内容解析为 JSON 对象</td></tr><tr><td><code>&#39;text&#39;</code></td><td>将响应作为字符串返回（UTF-8）</td></tr><tr><td><code>&#39;arraybuffer&#39;</code></td><td>返回原始的二进制数据（ArrayBuffer），适合处理图片、PDF、音频、视频等</td></tr><tr><td><code>&#39;blob&#39;</code></td><td>返回 Blob 对象，适合下载文件、创建对象 URL</td></tr><tr><td><code>&#39;document&#39;</code></td><td>返回 HTML&#x2F;XML 文档对象（主要用于 AJAX 加载网页）</td></tr></tbody></table><p><strong>简单来说，将网络图片转换成file对象，先要把这个图片下载下来，获得这个图片的二进制数据，然后再逐步转换成File对象。</strong></p><p>输出的<code>response</code>格式如下：</p><img src="..\images\前端面试-js\response.png" style="zoom:80%"><p>其中的<code>ArrayBuffer</code>指的是</p><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>故名思义，可以转换文件对象，比如可以把<code>文件对象</code>异步转换成<code>base64</code>格式</p><p>设你有一张 PNG 格式的图片，通过 <code>data URL</code> 和 Base64 编码的方式<strong>内联</strong>到 HTML 文件中，它可能看起来像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Embedded Image&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>data:image/png</code>表示数据的MIME类型，<code>base64</code>表示数据是否经过了 Base64 编码，如果数据未进行 Base64 编码，则应省略此部分。</p><p>这里的 <code>&quot;iVBORw0KGgoAAAANSUhEUgAAAAUA...&quot;</code> 就是该图片经过 Base64 编码后的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//on-change事件，图片选择后触发该回调函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onUploadFile</span> = (<span class="params">uploadFile</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//创建一个reader对象</span></span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>()</span><br><span class="line">  <span class="comment">//uploadFile.raw的值是图片的文件对象File</span></span><br><span class="line">  reader.<span class="title function_">readAsDataURL</span>(uploadFile.<span class="property">raw</span>)</span><br><span class="line">  <span class="comment">//把file对象转化成base64格式是*异步*的，监听reader的onload事件；需要在回调函数中拿到结果result</span></span><br><span class="line">  reader.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//把图片从File对象转换成base64格式的图片，可以用来展示和提交</span></span><br><span class="line">    imageUrl.<span class="property">value</span> = reader.<span class="property">result</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简要步骤如下：</p><ul><li>使用<code>new FileReader()</code>创建一个reader对象</li><li>调用reader的 <code>readAsDataURL</code>，传入一个File对象，</li><li>监听reader的<code>onload</code>事件，这个事件触发后，就代表转换完成，从reader.result中就能拿到base64字符串</li></ul><p>Blob对象也可以使用FileReader的语法</p><h3 id="URL-createObjectURL-file-blob"><a href="#URL-createObjectURL-file-blob" class="headerlink" title="URL.createObjectURL(file&#x2F;blob)"></a>URL.createObjectURL(file&#x2F;blob)</h3><ul><li><p><code>URL.createObjectURL</code>会生成一个指向 Blob 或 File 对象的<strong>临时 URL</strong>。这个 URL 可以被用作 <code>&lt;img&gt;、&lt;video&gt;、&lt;audio&gt;、&lt;a&gt;</code> 等 HTML 元素的 src 或 href 属性，<strong>用来展示</strong>。</p></li><li><p>允许在<code>不暴露文件的实际路径（网络图片）或内容（比如base64格式的图片就会暴露内容）</code>的前提下，显示文件，增加了<code>安全性</code></p></li><li><p>对象 URL 是<code>临时的</code>，浏览器会自动在<code>页面卸载（比如页面更新）</code>时释放这些 URL。举个例子，用户在当前页面拿到我的某个资源的临时URL后，他确实可以使用这个URL下载我的资源，但是一旦关闭或者刷新页面，这个URL就无效了。</p></li><li><p>但是，为了确保最佳性能和避免内存泄漏，应该在不再需要时，显式调用 <code>URL.revokeObjectURL</code>。</p></li></ul><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span>更换图片<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;postImage&quot;</span> <span class="attr">id</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> postImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.postImage&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  postImage.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">src</span>= url</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob:http://&lt;origin&gt;/&lt;unique-identifier&gt;</span><br></pre></td></tr></table></figure><ul><li><code>blob:</code> 指定了这是一个 Blob URL scheme(格式)。</li><li><code>http://&lt;origin&gt;</code>，当前页面的<code>源</code>，例如 <code>http://example.com</code>。对于直接打开的页面，就是<code>null</code></li><li><code>&lt;unique-identifier&gt;</code> 是一个唯一标识符，用来区分不同的 Blob 对象。这个标识符是由浏览器自动生成的，保证在同一页面中每个通过 <code>createObjectURL</code> 创建的 URL 都是独一无二的。</li></ul><img src="..\images\前端面试-js\临时url.png" style="zoom:85%"><h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fd = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">fd.<span class="title function_">append</span>(<span class="string">&#x27;img&#x27;</span>, e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/upload&quot;</span>,</span><br><span class="line">   <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">   <span class="attr">data</span>: fd<span class="comment">//直接当作请求体对象</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><code>FormData</code> 对象允许你构造一组键&#x2F;值对，这组键&#x2F;值对可以被轻松地序列化为 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code> 格式，非常适合用来<strong>模拟 HTML 表单提交</strong>。</p></li><li><p>使用 <code>append()</code> 方法可以向 <code>FormData</code> 对象中添加字段或<strong>文件</strong>。append方法还接收<strong>第三个参数</strong>，当你上传一个文件时，可以通过这个参数<strong>为上传的文件指定一个名称</strong>。如果没有提供这个参数，浏览器通常会使用 <code>File</code> 对象本身的 <code>name</code> 属性值作为文件名。</p></li><li><p><strong>影响服务器端接收到的文件名</strong>：后端通过解析请求获取文件信息时，所使用的文件名就是这里提供的或者是 <code>File</code> 对象默认的文件名。</p></li><li><p>当 <code>FormData</code> 包含文件(File)时，<code>axios</code> 会自动设置请求头 <code>Content-Type</code> 为 <code>multipart/form-data</code>，这是文件上传的标准格式。</p><p>即便是一个和FormData对象内容<code>完全一致</code>的不同对象也做不到这点。</p></li></ul><ul><li><code>FormData</code> 的构造函数 <strong>不接受普通对象（Object）作为参数</strong>，只接受传入一个 HTML <code>&lt;form&gt;</code> 元素（用于自动收集表单数据）或者空构造。</li></ul><h3 id="图像展示方法"><a href="#图像展示方法" class="headerlink" title="图像展示方法"></a>图像展示方法</h3><ul><li>拿到本地图片file对象，转换成<code>base64格式</code>的图片（由图片文件数据编码而来的一个字符串）</li><li>拿到本地图片file对象，生成一个<code>临时url</code>（只能用来展示）</li><li>网络图片链接，会自动发送一个请求获取图片</li></ul><h3 id="文件可上传格式"><a href="#文件可上传格式" class="headerlink" title="文件可上传格式"></a>文件可上传格式</h3><ul><li>file&#x2F;blob（二进制）</li><li>base64（即可展示又可上传，无敌了）</li></ul><h2 id="前端网络安全"><a href="#前端网络安全" class="headerlink" title="前端网络安全"></a>前端网络安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>跨站脚本攻击（Cross-Site Scripting，简称XSS），不叫css主要是为了和防止和层叠样式表（Cascading Style Sheets, CSS）混淆。</p><p>只有动态页面才会受到xss攻击，而纯静态页面则不会</p><p>XSS攻击危害包括：</p><ul><li>窃取cookie</li><li>劫持流量</li><li>插入广告</li><li>置入木马</li><li>获取用户信息</li></ul><p>注入方式主要包括：</p><ul><li>url参数</li><li>用户输入</li></ul><p>简单的来说，只要是用户输入的地方，就是不安全的</p><p>xss可分为以下几类：</p><p>储存过程</p><ul><li>反射型：浏览器提交恶意代码到服务端 ，服务端将恶意代码传回客户端</li><li>储存型：浏览器提交恶意代码到服务端，服务端将恶意代码储存到数据库</li><li>DOM型：恶意代码仅在客户端运行</li></ul><p>其中反射型和dom类型主要通过url参数的方式注入，存储型造成的危害是最持久的，通常通过用户输入的方式注入。</p><p>那如何防止呢？</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="src属性和href属性的区别"><a href="#src属性和href属性的区别" class="headerlink" title="src属性和href属性的区别"></a>src属性和href属性的区别</h3><p><strong>src属性</strong></p><ul><li><code>src</code>（source 的缩写）属性主要用于嵌入外部资源到当前文档中。例如，图像、脚本、框架、音频、视频等元素。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;描述图片&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>href属性</strong></p><ul><li><p><code>href</code>（hypertext reference 的缩写）属性用于定义超链接的目标 URL。它可以出现在多种元素上，如 <code>&lt;a&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;area&gt;</code> 等，用来指向另一个网页、文件、同一页面内的不同位置、样式表、JavaScript 文件等</p></li><li><p>对于 <code>&lt;a&gt;</code> 标签，它指定了用户点击链接后应导航到的位置；对于 <code>&lt;link&gt;</code> 标签，它通常用于引入外部资源，如 CSS 文件，告诉浏览器获取并应用这些资源来渲染页面。</p></li></ul><p><strong>区别</strong></p><ul><li><code>src</code> 用于嵌入外部资源到文档中，而 <code>href</code> 则用于创建超链接或引用外部资源而不直接嵌入文档。简单来说，一个是<strong>嵌入</strong>外部资源到文档，一个<strong>链接</strong>外部资源到文档。</li><li>使用 <code>src</code> 时，浏览器需要下载并处理资源，然后将其<strong>插入到文档流中</strong>，这个过程<strong>可能</strong>会暂停 HTML 解析（就是script标签）；而使用 <code>href</code> 时，特别是对于 <code>&lt;link&gt;</code> 标签，浏览器可以异步加载资源，并且不会阻塞 HTML 解析器。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog">三叶sanye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog/posts/aef189c3.html">https://www.sanye.blog/posts/aef189c3.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.sanye.blog" target="_blank">三叶的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/4b58a1f5.html" title="前端面试---css"><img class="cover" src="/images/cover/%E6%B1%9F%E5%8D%97.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">前端面试---css</div></div><div class="info-2"><div class="info-item-1">css面试题（笔记）</div></div></div></a><a class="pagination-related" href="/posts/f33bd2b9.html" title="前端面试---vue部分"><img class="cover" src="/images/cover/%E5%B0%8F%E9%95%87.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">前端面试---vue部分</div></div><div class="info-2"><div class="info-item-1">vue2+vue3面试题（笔记）</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/%E4%B8%89%E5%8F%B6.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">三叶sanye</div><div class="author-info-description">三叶的小窝</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a><a href="/gallery/"><div class="headline">图库</div><div class="length-num">∞</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="Bilibli"><i class="fa-brands fa-bilibili" style="color:#74c0fc"></i></a><a class="social-icon" href="https://github.com/syhy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:3519450570@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%BD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">浏览器都包含哪些进程？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Browser%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">Browser进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">其他进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">浏览器渲染进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">主线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">事件循环与渲染机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">举例说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebWorker%EF%BC%8CJS%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">WebWorker，JS的多线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9js%E5%BC%95%E6%93%8E%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFV8%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">说说你对js引擎的理解，什么是V8引擎？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%BC%95%E6%93%8E"><span class="toc-number">2.1.</span> <span class="toc-text">js引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V8%E5%BC%95%E6%93%8E"><span class="toc-number">2.2.</span> <span class="toc-text">V8引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">V8 引擎的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Parse"><span class="toc-number">2.3.1.</span> <span class="toc-text">Parse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ignition"><span class="toc-number">2.3.2.</span> <span class="toc-text">Ignition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TurboFan"><span class="toc-number">2.3.3.</span> <span class="toc-text">TurboFan</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V8-%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-JavaScript-%E4%BB%A3%E7%A0%81%E7%9A%84%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">V8 是怎么执行一段 JavaScript 代码的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">大致流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C"><span class="toc-number">2.4.2.</span> <span class="toc-text">解释执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C"><span class="toc-number">2.4.3.</span> <span class="toc-text">编译执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.4.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%85%B6%E4%BB%96%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">2.5.</span> <span class="toc-text">对比其他编程语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80"><span class="toc-number">2.5.1.</span> <span class="toc-text">C语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java"><span class="toc-number">2.5.2.</span> <span class="toc-text">Java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8script%E6%A0%87%E7%AD%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0async%E5%92%8Cdefer%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">在script标签中添加async和defer有什么作用和区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async"><span class="toc-number">3.1.</span> <span class="toc-text">async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">3.2.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">3.3.</span> <span class="toc-text">拓展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">说说你对事件循环的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88js%E6%98%AF%E4%B8%80%E9%97%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">4.1.</span> <span class="toc-text">为什么js是一门单线程语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.2.</span> <span class="toc-text">同步与异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.3.</span> <span class="toc-text">微任务与宏任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.4.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E4%B8%8Eawait"><span class="toc-number">4.5.</span> <span class="toc-text">async与await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E4%BE%8B%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">综合例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">说说js资源加载事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMContentLoaded"><span class="toc-number">5.1.</span> <span class="toc-text">DOMContentLoaded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load"><span class="toc-number">5.2.</span> <span class="toc-text">load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unload%E5%92%8Cbeforeunload"><span class="toc-number">5.3.</span> <span class="toc-text">unload和beforeunload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">说说js的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Number"><span class="toc-number">6.1.1.</span> <span class="toc-text">Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">6.1.2.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean"><span class="toc-number">6.1.3.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol"><span class="toc-number">6.1.4.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Null"><span class="toc-number">6.1.5.</span> <span class="toc-text">Null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Undefined"><span class="toc-number">6.1.6.</span> <span class="toc-text">Undefined</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">引用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array"><span class="toc-number">6.2.1.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function"><span class="toc-number">6.2.2.</span> <span class="toc-text">Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.3.</span> <span class="toc-text">其他类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">6.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">数组的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E"><span class="toc-number">7.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0"><span class="toc-number">7.2.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9"><span class="toc-number">7.3.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5"><span class="toc-number">7.4.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">排序方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.</span> <span class="toc-text">转换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="toc-number">7.7.</span> <span class="toc-text">迭代方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">字符串常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">操作方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#concat"><span class="toc-number">8.1.1.</span> <span class="toc-text">concat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slice-substr-substring"><span class="toc-number">8.1.2.</span> <span class="toc-text">slice() substr() substring()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#indexOf-startWith-includes"><span class="toc-number">8.1.3.</span> <span class="toc-text">indexOf() startWith() includes()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86"><span class="toc-number">8.2.</span> <span class="toc-text">字符串拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D"><span class="toc-number">8.3.</span> <span class="toc-text">模板匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#match"><span class="toc-number">8.3.1.</span> <span class="toc-text">match()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#search"><span class="toc-number">8.3.2.</span> <span class="toc-text">search()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replace"><span class="toc-number">8.3.3.</span> <span class="toc-text">replace()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-2"><span class="toc-number">8.3.4.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">说说js中的正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">创建正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">9.1.1.</span> <span class="toc-text">字面量语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95"><span class="toc-number">9.1.2.</span> <span class="toc-text">构造函数语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">正则表达式语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-number">9.2.1.</span> <span class="toc-text">元字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BB%84"><span class="toc-number">9.2.2.</span> <span class="toc-text">字符组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84-%E6%8D%95%E8%8E%B7%E7%BB%84"><span class="toc-number">9.2.3.</span> <span class="toc-text">分组&#x2F;捕获组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8F%E8%AF%8D"><span class="toc-number">9.2.4.</span> <span class="toc-text">量词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">9.2.5.</span> <span class="toc-text">修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#test"><span class="toc-number">9.3.1.</span> <span class="toc-text">test()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec"><span class="toc-number">9.3.2.</span> <span class="toc-text">exec()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">Object的常见静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-keys"><span class="toc-number">10.1.</span> <span class="toc-text">Object.keys()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-values"><span class="toc-number">10.2.</span> <span class="toc-text">Object.values()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-entries"><span class="toc-number">10.3.</span> <span class="toc-text">Object.entries()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-assign"><span class="toc-number">10.4.</span> <span class="toc-text">Object.assign()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperty"><span class="toc-number">10.5.</span> <span class="toc-text">Object.defineProperty</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof%E5%92%8Cinstanceof"><span class="toc-number">11.</span> <span class="toc-text">typeof和instanceof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">11.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">11.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-3"><span class="toc-number">11.3.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-prototype-toString"><span class="toc-number">11.4.</span> <span class="toc-text">Object.prototype.toString()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-JavaScript-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">谈谈 JavaScript 中的类型转换机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.1.</span> <span class="toc-text">显式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-1"><span class="toc-number">12.1.1.</span> <span class="toc-text">Number()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parseInt"><span class="toc-number">12.1.2.</span> <span class="toc-text">parseInt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-1"><span class="toc-number">12.1.3.</span> <span class="toc-text">String()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean-1"><span class="toc-number">12.1.4.</span> <span class="toc-text">Boolean()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.2.</span> <span class="toc-text">隐式转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript-%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">14.</span> <span class="toc-text">Javascript 数字精度丢失的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number">14.1.</span> <span class="toc-text">为什么会出现精度丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">14.2.</span> <span class="toc-text">如何解决精度缺失问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-JavaScript-%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">15.</span> <span class="toc-text">说说 JavaScript 中内存泄漏的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">15.1.</span> <span class="toc-text">内存泄漏是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">15.2.</span> <span class="toc-text">垃圾自动回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">15.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.2.</span> <span class="toc-text">如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">15.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">15.3.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%83%85%E5%86%B5"><span class="toc-number">15.4.</span> <span class="toc-text">常见内存泄漏情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">15.4.1.</span> <span class="toc-text">意外的全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">15.4.2.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">15.4.3.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">16.</span> <span class="toc-text">说说你对闭包的理解？闭包使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">16.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">16.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">17.</span> <span class="toc-text">说说你对防抖和节流的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">17.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">17.2.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">17.3.</span> <span class="toc-text">节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">17.4.</span> <span class="toc-text">区别与联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">17.5.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%87%BD%E6%95%B0%E7%9A%84apply%EF%BC%8Ccall%EF%BC%8Cbind%E6%96%B9%E6%B3%95"><span class="toc-number">18.</span> <span class="toc-text">说说函数的apply，call，bind方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call"><span class="toc-number">18.1.</span> <span class="toc-text">call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply"><span class="toc-number">18.2.</span> <span class="toc-text">apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">18.3.</span> <span class="toc-text">bind</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1Date"><span class="toc-number">19.</span> <span class="toc-text">说说js中的日期对象Date</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.1.</span> <span class="toc-text">创建日期对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">19.2.</span> <span class="toc-text">获取日期信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">19.3.</span> <span class="toc-text">其他常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">20.</span> <span class="toc-text">深拷贝浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">20.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">20.2.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">20.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">21.</span> <span class="toc-text">说说js中的事件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">21.1.</span> <span class="toc-text">事件与事件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">21.2.</span> <span class="toc-text">事件模型分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">22.</span> <span class="toc-text">讲讲事件代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">23.</span> <span class="toc-text">说说你对BOM的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#window"><span class="toc-number">23.1.</span> <span class="toc-text">window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location"><span class="toc-number">23.2.</span> <span class="toc-text">location</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history"><span class="toc-number">23.3.</span> <span class="toc-text">history</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#navigator"><span class="toc-number">23.4.</span> <span class="toc-text">navigator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#screen"><span class="toc-number">23.5.</span> <span class="toc-text">screen</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">24.</span> <span class="toc-text">DOM常见的操作有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">24.1.</span> <span class="toc-text">DOM是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">24.2.</span> <span class="toc-text">DOM常见的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><span class="toc-number">24.2.1.</span> <span class="toc-text">创建节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9"><span class="toc-number">24.2.2.</span> <span class="toc-text">获取节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%BB%93%E7%82%B9"><span class="toc-number">24.2.3.</span> <span class="toc-text">更新结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%BB%93%E7%82%B9"><span class="toc-number">24.2.4.</span> <span class="toc-text">添加结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9"><span class="toc-number">24.2.5.</span> <span class="toc-text">删除结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodeType"><span class="toc-number">24.3.</span> <span class="toc-text">nodeType</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%BA%95%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">如何实现触底加载，下拉刷新？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7"><span class="toc-number">25.1.</span> <span class="toc-text">定位属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#clientWidth%E5%92%8CscrollWidth"><span class="toc-number">25.1.1.</span> <span class="toc-text">clientWidth和scrollWidth</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scrollLeft%E5%92%8CscrollTop"><span class="toc-number">25.1.2.</span> <span class="toc-text">scrollLeft和scrollTop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#offsetWidth%E5%92%8CclientWidth"><span class="toc-number">25.1.3.</span> <span class="toc-text">offsetWidth和clientWidth</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#offsetLeft%E5%92%8CoffsetTop"><span class="toc-number">25.1.4.</span> <span class="toc-text">offsetLeft和offsetTop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#offsetX%E5%92%8CoffsetY"><span class="toc-number">25.1.5.</span> <span class="toc-text">offsetX和offsetY</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%BA%95%E5%8A%A0%E8%BD%BD"><span class="toc-number">25.2.</span> <span class="toc-text">如何实现触底加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0"><span class="toc-number">25.3.</span> <span class="toc-text">如何实现下拉刷新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E4%B8%AD%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">如何判断一个元素是否在可视区域中？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">26.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">26.2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9dom%E7%9A%84%E5%B8%83%E5%B1%80%E5%B1%9E%E6%80%A7"><span class="toc-number">26.2.1.</span> <span class="toc-text">借助dom的布局属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntersectionObserver"><span class="toc-number">26.2.2.</span> <span class="toc-text">IntersectionObserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getBoundingClientRect"><span class="toc-number">26.2.3.</span> <span class="toc-text">getBoundingClientRect</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">27.</span> <span class="toc-text">实现图片的懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IntersectionObserver-1"><span class="toc-number">27.1.</span> <span class="toc-text">IntersectionObserver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getBoundingClientRect-1"><span class="toc-number">27.2.</span> <span class="toc-text">getBoundingClientRect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E7%9A%84%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8"><span class="toc-number">28.</span> <span class="toc-text">实现列表的无限滚动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getBoundingClientRect-2"><span class="toc-number">28.1.</span> <span class="toc-text">getBoundingClientRect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntersectionObserver-2"><span class="toc-number">28.2.</span> <span class="toc-text">IntersectionObserver</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">29.</span> <span class="toc-text">new操作符到底做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8js%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">30.</span> <span class="toc-text">在js中如何实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">30.1.</span> <span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">30.2.</span> <span class="toc-text">构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">30.3.</span> <span class="toc-text">组合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">30.4.</span> <span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends-super"><span class="toc-number">30.5.</span> <span class="toc-text">extends+super</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">Javascript本地存储的方式有哪些？区别及应用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">31.1.</span> <span class="toc-text">Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">31.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">31.1.2.</span> <span class="toc-text">操作方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="toc-number">31.1.3.</span> <span class="toc-text">浏览器行为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage"><span class="toc-number">31.2.</span> <span class="toc-text">localStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">31.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#storage%E4%BA%8B%E4%BB%B6%E8%A1%A5%E5%85%85"><span class="toc-number">31.2.2.</span> <span class="toc-text">storage事件补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">31.2.3.</span> <span class="toc-text">常见使用语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">31.2.4.</span> <span class="toc-text">和cookie的区别与联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sessionStorage"><span class="toc-number">31.3.</span> <span class="toc-text">sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%89%A9%E5%B1%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">31.4.</span> <span class="toc-text">前端扩展存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">31.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">31.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">31.5.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax"><span class="toc-number">32.</span> <span class="toc-text">ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">32.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">32.2.</span> <span class="toc-text">实现过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetch"><span class="toc-number">33.</span> <span class="toc-text">fetch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-number">34.</span> <span class="toc-text">axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">34.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">34.2.</span> <span class="toc-text">开始使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84axios"><span class="toc-number">34.3.</span> <span class="toc-text">实现一个简易版的axios</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#axios-config"><span class="toc-number">34.3.1.</span> <span class="toc-text">axios(config)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#axios-method"><span class="toc-number">34.3.2.</span> <span class="toc-text">axios.method()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="toc-number">34.4.</span> <span class="toc-text">常见用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#axios-create"><span class="toc-number">34.4.1.</span> <span class="toc-text">axios.create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">34.4.2.</span> <span class="toc-text">添加拦截器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82"><span class="toc-number">34.4.3.</span> <span class="toc-text">取消请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8axios%E5%AE%9E%E4%BE%8B%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-number">34.4.4.</span> <span class="toc-text">使用axios实例发送请求</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#request"><span class="toc-number">34.4.4.1.</span> <span class="toc-text">request({})</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#request-method"><span class="toc-number">34.4.4.2.</span> <span class="toc-text">request.method()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">34.4.4.3.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">34.5.</span> <span class="toc-text">响应结果结构分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">35.</span> <span class="toc-text">文件上传怎么做</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#input%E6%A0%87%E7%AD%BE"><span class="toc-number">35.1.</span> <span class="toc-text">input标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E5%AF%B9%E8%B1%A1"><span class="toc-number">35.2.</span> <span class="toc-text">File对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7"><span class="toc-number">35.2.1.</span> <span class="toc-text">常见属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slice"><span class="toc-number">35.2.2.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8CBlob%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">35.2.3.</span> <span class="toc-text">和Blob对象的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%86%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E6%88%90File%E5%AF%B9%E8%B1%A1"><span class="toc-number">35.2.4.</span> <span class="toc-text">案例：将网络图片转换成File对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader"><span class="toc-number">35.3.</span> <span class="toc-text">FileReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-createObjectURL-file-blob"><span class="toc-number">35.4.</span> <span class="toc-text">URL.createObjectURL(file&#x2F;blob)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FormData"><span class="toc-number">35.5.</span> <span class="toc-text">FormData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%B1%95%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">35.6.</span> <span class="toc-text">图像展示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8F%AF%E4%B8%8A%E4%BC%A0%E6%A0%BC%E5%BC%8F"><span class="toc-number">35.7.</span> <span class="toc-text">文件可上传格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-number">36.</span> <span class="toc-text">前端网络安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-number">36.1.</span> <span class="toc-text">XSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">37.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#src%E5%B1%9E%E6%80%A7%E5%92%8Chref%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">37.1.</span> <span class="toc-text">src属性和href属性的区别</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image:url(/images/cover/云湖少女.png)"><div id="footer-wrap"><div class="footer_custom_text"><div id="sanye"><svg class="icon" aria-hidden="true"><use href="#icon-banquan"></use></svg><span>2024 - 2025 By 三叶sanye</span><svg class="icon" aria-hidden="true"><use href="#icon-sanyecao"></use></svg></div><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/time.js" defer></script><script src="/iconfont/iconfont.js"></script><script src="/bilibiliBanner/banner.js" defer></script><script src="/gallery/background.js" defer></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="/js/busuanzi.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?82b9a7c4e8fee04e39b57c7d4ffd9832"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,display:{position:"left",width:132,height:264},mobile:{show:!0},react:{opacity:.7},dialog:{enable:!1,hitokoto:!1},model:{jsonPath:"/live2d/live2d.json"}})</script></body></html>